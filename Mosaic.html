<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∫–∞–ª–µ–π–¥–æ—Å–∫–æ–ø–æ–≤ (Ultra Fast + Full Logic)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background: radial-gradient(circle at center, #0f172a, #020617);
            min-height: 100vh;
            color: #e2e8f0;
        }
        canvas {
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        /* UI Elements */
        .glass-panel {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .glass-panel:hover {
            border-color: rgba(255, 255, 255, 0.15);
            background: rgba(30, 41, 59, 0.7);
        }
        
        .control-label {
            color: #94a3b8;
            font-size: 0.8rem;
            font-weight: 700;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
            display: block;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            background: rgba(255,255,255,0.1);
            border-radius: 99px;
            height: 6px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8b5cf6;
            cursor: pointer;
            transition: background .15s ease-in-out;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #a78bfa;
        }

        select, input[type="color"] {
            background-color: rgba(15, 23, 42, 0.8);
            border: 1px solid #334155;
            color: white;
            font-size: 0.95rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            box-shadow: 0 4px 14px 0 rgba(99, 102, 241, 0.39);
            font-weight: 600;
            border: none;
            position: relative;
            overflow: hidden;
        }
        .btn-primary:hover {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            transform: translateY(-1px);
        }
        
        .btn-danger {
            background: rgba(239, 68, 68, 0.15);
            color: #fca5a5;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.25);
        }

        .color-swatch {
            width: 100%;
            aspect-ratio: 1/1;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .color-swatch:hover { transform: scale(1.1); z-index: 10; border-color: white; }

        #imageModal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 100;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        #imageModal.show { display: flex; }
    </style>
</head>
<body class="font-sans antialiased selection:bg-indigo-500 selection:text-white">
    
    <div class="container mx-auto p-4 max-w-[1600px]">
        
        <header class="mb-8 text-center pt-4">
            <h1 class="text-4xl md:text-6xl font-black text-transparent bg-clip-text bg-gradient-to-r from-indigo-400 via-purple-400 to-pink-400 mb-3 drop-shadow-lg tracking-tight">
                KaleidoMosaic AI
            </h1>
            <p class="text-slate-400 font-medium text-lg">–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —É–∑–æ—Ä–æ–≤ —Å —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–π –º–æ–∑–∞–∏–∫–æ–π</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-6 items-start">
            
            <div class="lg:col-span-3 space-y-5">
                <div class="glass-panel p-5 rounded-2xl">
                    <h2 class="text-lg font-bold text-white mb-4 flex items-center gap-2">
                        <svg class="w-5 h-5 text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.384-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"></path></svg>
                        –ë–∞–∑–∞ —É–∑–æ—Ä–∞
                    </h2>
                    <div class="space-y-4">
                        <div>
                            <label class="control-label">–¢–∏–ø –≥–µ–æ–º–µ—Ç—Ä–∏–∏</label>
                            <select id="modeCombo" class="w-full p-2.5 rounded-lg focus:ring-2 focus:ring-indigo-500 outline-none cursor-pointer">
                                <option value="Lines">–õ–∏–Ω–∏–∏</option>
                                <option value="Dots">–¢–æ—á–∫–∏</option>
                                <option value="Shapes">–§–∏–≥—É—Ä—ã</option>
                                <option value="Mixed">–°–º–µ—à–∞–Ω–Ω—ã–π</option>
                                <option value="Spiral">–°–ø–∏—Ä–∞–ª—å</option>
                                <option value="Orbit">–û—Ä–±–∏—Ç—ã</option>
                                <option value="DotToShape">–¢–æ—á–∫–∏ –≤ –§–∏–≥—É—Ä—ã</option>
                                <option value="DotsToMixed">–¢–æ—á–∫–∏ –≤ –°–º–µ—à–∞–Ω–Ω—ã–π</option>
                            </select>
                        </div>
                        <div>
                            <label class="control-label flex justify-between">–ß–∞—Å—Ç–∏—Ü: <span id="elementValue" class="text-indigo-400">300</span></label>
                            <input type="range" id="elementSlider" min="50" max="1000" value="300" class="w-full">
                        </div>
                        <div>
                            <label class="control-label flex justify-between">–°–µ–∫—Ç–æ—Ä–∞: <span id="slicesValue" class="text-indigo-400">12</span></label>
                            <input type="range" id="slicesSlider" min="3" max="32" value="12" class="w-full">
                        </div>
                        <div>
                            <label class="control-label flex justify-between">–°–∫–æ—Ä–æ—Å—Ç—å: <span id="animationSpeedValue" class="text-indigo-400">0.1</span></label>
                            <input type="range" id="animationSpeedSlider" min="0" max="0.5" step="0.01" value="0.1" class="w-full">
                        </div>
                    </div>
                </div>

                <div class="glass-panel p-5 rounded-2xl">
                    <h2 class="text-lg font-bold text-white mb-4 flex items-center gap-2">
                        <svg class="w-5 h-5 text-pink-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"></path></svg>
                        –¶–≤–µ—Ç–∞
                    </h2>
                    <div id="paletteGrid" class="grid grid-cols-5 gap-2 mb-4">
                        </div>
                    <div class="grid grid-cols-2 gap-2">
                        <button id="addColorBtn" class="btn-primary py-2 px-3 rounded-lg text-sm shadow-lg">+ –î–æ–±–∞–≤–∏—Ç—å</button>
                        <button id="removeColorBtn" class="btn-danger py-2 px-3 rounded-lg text-sm shadow-lg">- –£–¥–∞–ª–∏—Ç—å</button>
                    </div>
                    <button id="changeBackgroundColorBtn" class="w-full mt-3 py-2 rounded-lg text-sm border border-slate-600 hover:bg-slate-700 transition text-slate-300">–ù–∞—Å—Ç—Ä–æ–∏—Ç—å —Ñ–æ–Ω</button>
                </div>
            </div>

            <div class="lg:col-span-6 flex flex-col gap-6">
                <div class="glass-panel p-1.5 rounded-2xl relative group shadow-2xl shadow-indigo-900/20">
                    <canvas id="previewCanvas" class="w-full h-auto rounded-xl bg-white"></canvas>
                    <div class="absolute top-4 left-4 pointer-events-none">
                         <span class="px-3 py-1 bg-black/60 text-white text-xs font-bold rounded-full backdrop-blur-md border border-white/10">LIVE PREVIEW</span>
                    </div>
                </div>

                <div class="grid grid-cols-2 sm:grid-cols-4 gap-3">
                    <button id="generateBtn" class="btn-primary py-3.5 rounded-xl text-white shadow-lg shadow-indigo-500/30 transition hover:scale-[1.02]">
                        üé≤ –û–±–Ω–æ–≤–∏—Ç—å
                    </button>
                    <button id="animateBtn" class="bg-emerald-600 hover:bg-emerald-500 text-white py-3.5 rounded-xl transition shadow-lg shadow-emerald-500/30 font-semibold hover:scale-[1.02]">
                        ‚ñ∂ –ê–Ω–∏–º–∞—Ü–∏—è
                    </button>
                    <button id="viewBtn" class="bg-slate-700 hover:bg-slate-600 text-white py-3.5 rounded-xl transition font-semibold hover:scale-[1.02]">
                        üëÅÔ∏è Full HD
                    </button>
                    <button id="saveBtn" class="bg-slate-700 hover:bg-slate-600 text-white py-3.5 rounded-xl transition font-semibold hover:scale-[1.02]">
                        üíæ –°–∫–∞—á–∞—Ç—å
                    </button>
                </div>
            </div>

            <div class="lg:col-span-3 space-y-5">
                <div class="glass-panel p-5 rounded-2xl border-t-4 border-t-purple-500">
                    <h2 class="text-lg font-bold text-white mb-4 flex items-center gap-2">
                        <svg class="w-5 h-5 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path></svg>
                        –ú–æ–∑–∞–∏–∫–∞
                    </h2>
                    <div class="space-y-5">
                        <div>
                            <label class="control-label">–°—Ç–∏–ª—å –ø–ª–∏—Ç–∫–∏</label>
                            <select id="mosaicType" class="w-full p-2.5 rounded-lg focus:ring-2 focus:ring-purple-500 cursor-pointer">
                                <option value="RoundedGlass">üßä –°–∫—Ä—É–≥–ª–µ–Ω–Ω–æ–µ —Å—Ç–µ–∫–ª–æ (Best)</option>
                                <option value="CleanSquare">‚¨õ –ß–∏—Å—Ç—ã–π –∫–≤–∞–¥—Ä–∞—Ç</option>
                                <option value="Hexagon">‚¨° –°–æ—Ç—ã (–ì–µ–∫—Å–∞–≥–æ–Ω)</option>
                                <option value="Triangle">üî∫ –¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∏</option>
                                <option value="Broken">üî® –ë–∏—Ç–∞—è –º–æ–∑–∞–∏–∫–∞ (–°–ª—É—á–∞–π–Ω–æ)</option>
                                <option value="Voronoi">üï∏Ô∏è –ü–∞—É—Ç–∏–Ω–∞ (–í–æ—Ä–æ–Ω–æ–π)</option>
                            </select>
                        </div>
                        
                        <div>
                            <label class="control-label flex justify-between">–†–∞–∑–º–µ—Ä –ø–ª–∏—Ç–∫–∏: <span id="tileSizeValue" class="text-purple-400">25</span></label>
                            <input type="range" id="tileSizeSlider" min="10" max="100" value="25" class="w-full">
                        </div>

                        <div>
                            <label class="control-label flex justify-between">–¢–æ–ª—â–∏–Ω–∞ —à–≤–∞: <span id="glueThicknessValue" class="text-purple-400">2</span></label>
                            <input type="range" id="glueThicknessSlider" min="0" max="15" step="0.5" value="2" class="w-full">
                        </div>
                        
                        <div>
                            <label class="control-label flex justify-between">–ò—Å–∫–∞–∂–µ–Ω–∏–µ (Chaos): <span id="chaosValue" class="text-purple-400">0</span></label>
                            <input type="range" id="chaosSlider" min="0" max="10" step="1" value="0" class="w-full" title="–î–æ–±–∞–≤–ª—è–µ—Ç –Ω–µ—Ä–æ–≤–Ω–æ—Å—Ç—å –∫—Ä–∞—è–º">
                        </div>

                        <div>
                            <label class="control-label">–¶–≤–µ—Ç —à–≤–∞ (–ì—Ä—É–Ω—Ç)</label>
                            <div class="flex gap-2">
                                <div id="glueColorBtn" class="h-10 w-full rounded-lg cursor-pointer border border-white/20 shadow-inner"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <div id="imageModal">
        <div class="relative w-full h-full flex flex-col items-center justify-center">
            <canvas id="fullCanvas" class="max-w-[95vw] max-h-[85vh] bg-white shadow-2xl rounded-lg cursor-zoom-out"></canvas>
            <button id="closeModalBtn" class="mt-6 bg-white/90 text-black px-8 py-3 rounded-full font-bold hover:bg-white transition shadow-lg backdrop-blur-md">
                –ó–∞–∫—Ä—ã—Ç—å –ø—Ä–æ—Å–º–æ—Ç—Ä
            </button>
        </div>
    </div>

    <div id="colorPickerModal" class="fixed inset-0 bg-black/80 hidden items-center justify-center z-[200] backdrop-blur-sm">
        <div class="bg-slate-800 p-6 rounded-2xl max-w-xs w-full border border-slate-600 shadow-2xl">
            <h3 class="text-white text-lg font-bold mb-4">–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ü–≤–µ—Ç–∞</h3>
            <input type="color" id="modalColorInput" class="w-full h-14 rounded-lg mb-4 cursor-pointer border-2 border-slate-600">
            <label class="text-slate-300 text-xs font-bold uppercase mb-2 block">–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å (Alpha)</label>
            <input type="range" id="modalAlphaInput" min="0" max="1" step="0.01" class="w-full mb-6">
            <div class="flex justify-end gap-2">
                <button id="modalCancelBtn" class="px-4 py-2 text-slate-300 hover:text-white font-medium">–û—Ç–º–µ–Ω–∞</button>
                <button id="modalSaveBtn" class="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-500 font-bold shadow-lg">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            </div>
        </div>
    </div>

    <script>
        /* --- CORE CONSTANTS --- */
        const PREVIEW_SIZE = 800; // High res preview
        const FULL_SIZE = 1600;
        let CURRENT_SIZE = PREVIEW_SIZE;
        
        /* --- STATE MANAGEMENT --- */
        const state = {
            elements: 300,
            slices: 12,
            speed: 0.1,
            mode: 'Lines',
            mosaic: {
                type: 'RoundedGlass',
                size: 25,
                gap: 2,
                chaos: 0, // Randomness in tile placement
                color: [20, 20, 20, 1.0] // Dark grout default
            },
            backgroundColor: [20, 20, 30, 1], // Dark background
            palette: [
                [255, 100, 100, 1], 
                [100, 255, 100, 1], 
                [100, 100, 255, 1], 
                [255, 255, 100, 1],
                [255, 0, 255, 0.8]
            ],
            isAnimating: false,
            animId: null,
        };

        /* --- OPTIMIZED MOSAIC MASK GENERATOR (UNCHANGED & FAST) --- */
        class MosaicMaskGenerator {
            constructor() {
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
            }

            createMask(width, height, settings) {
                this.canvas.width = width;
                this.canvas.height = height;
                const ctx = this.ctx;
                const { type, size, gap, chaos, color } = settings;
                
                // 1. Fill with Grout Color
                ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]})`;
                ctx.fillRect(0, 0, width, height);

                // 2. Cut out the holes
                ctx.globalCompositeOperation = 'destination-out';
                ctx.fillStyle = 'black';

                const cols = Math.ceil(width / size) + 2;
                const rows = Math.ceil(height / size) + 2;

                if (type === 'Hexagon') {
                    this._drawHexGrid(ctx, cols, rows, size, gap, width, height);
                } else if (type === 'Triangle') {
                    this._drawTriGrid(ctx, cols, rows, size, gap);
                } else if (type === 'Voronoi') {
                    this._drawVoronoi(ctx, width, height, size, gap);
                } else {
                    this._drawSquareGrid(ctx, cols, rows, size, gap, chaos, type);
                }

                // 3. Add 3D Effects
                ctx.globalCompositeOperation = 'source-over';
                if (type !== 'CleanSquare') {
                    this._drawLightingOverlay(ctx, width, height, type, size, gap);
                }

                return this.canvas;
            }

            _drawSquareGrid(ctx, cols, rows, size, gap, chaos, type) {
                const tileSize = Math.max(1, size - gap);
                const cornerRadius = type === 'RoundedGlass' ? tileSize * 0.25 : (type === 'Broken' ? 0 : 2);

                for (let y = -1; y < rows; y++) {
                    for (let x = -1; x < cols; x++) {
                        let tx = x * size + gap/2;
                        let ty = y * size + gap/2;
                        if (chaos > 0 || type === 'Broken') {
                            tx += (Math.random() - 0.5) * (chaos * 2 + (type === 'Broken' ? size*0.5 : 0));
                            ty += (Math.random() - 0.5) * (chaos * 2 + (type === 'Broken' ? size*0.5 : 0));
                        }
                        let w = tileSize;
                        let h = tileSize;
                        if (type === 'Broken') {
                            w *= (0.8 + Math.random()*0.4);
                            h *= (0.8 + Math.random()*0.4);
                        }
                        this._roundedRect(ctx, tx, ty, w, h, cornerRadius);
                        ctx.fill();
                    }
                }
            }

            _drawHexGrid(ctx, cols, rows, size, gap, w, h) {
                const hexHeight = size;
                const hexWidth = Math.sqrt(3) * hexHeight;
                const vertDist = hexHeight * 1.5;
                const horizDist = hexWidth;
                const effectiveSize = size - gap/2;

                for (let r = -1; r < rows * 1.5; r++) {
                    for (let c = -1; c < cols * 1.5; c++) {
                        const xOffset = (r % 2) * (horizDist / 2);
                        const cx = c * horizDist + xOffset;
                        const cy = r * vertDist;
                        this._polygon(ctx, cx, cy, effectiveSize, 6);
                        ctx.fill();
                    }
                }
            }

            _drawTriGrid(ctx, cols, rows, size, gap) {
                const height = size * Math.sqrt(3) / 2;
                const effectiveSize = size - gap;
                for (let y = -1; y < rows; y++) {
                    for (let x = -1; x < cols; x++) {
                        const cx = x * (size/2);
                        const cy = y * height;
                        const up = (x + y) % 2 === 0;
                        this._triangle(ctx, cx, cy, effectiveSize, up);
                        ctx.fill();
                    }
                }
            }

            _drawVoronoi(ctx, width, height, size, gap) {
                const count = (width*height) / (size*size) * 2;
                for(let i=0; i<count; i++) {
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    const s = size * (0.5 + Math.random());
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(Math.random() * Math.PI * 2);
                    ctx.fillRect(-s/2 + gap, -s/2 + gap, s - gap*2, s - gap*2);
                    ctx.restore();
                }
            }

            _drawLightingOverlay(ctx, width, height, type, size, gap) {
                if (type === 'RoundedGlass' || type === 'Hexagon') {
                    const grad = ctx.createLinearGradient(0, 0, width, height);
                    grad.addColorStop(0, 'rgba(255,255,255,0.0)');
                    grad.addColorStop(0.5, 'rgba(255,255,255,0.1)');
                    grad.addColorStop(1, 'rgba(0,0,0,0.2)');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0,0,width,height);
                }
            }

            _roundedRect(ctx, x, y, w, h, r) {
                ctx.beginPath();
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                ctx.moveTo(x + r, y);
                ctx.arcTo(x + w, y, x + w, y + h, r);
                ctx.arcTo(x + w, y + h, x, y + h, r);
                ctx.arcTo(x, y + h, x, y, r);
                ctx.arcTo(x, y, x + w, y, r);
                ctx.closePath();
            }

            _polygon(ctx, x, y, radius, sides) {
                if (sides < 3) return;
                const a = (Math.PI * 2) / sides;
                ctx.beginPath();
                for (let i = 0; i < sides; i++) {
                    ctx.lineTo(x + radius * Math.cos(a * i), y + radius * Math.sin(a * i));
                }
                ctx.closePath();
            }

            _triangle(ctx, x, y, size, up) {
                const h = size * Math.sqrt(3) / 2;
                ctx.beginPath();
                if (up) {
                    ctx.moveTo(x, y - h/2);
                    ctx.lineTo(x + size/2, y + h/2);
                    ctx.lineTo(x - size/2, y + h/2);
                } else {
                    ctx.moveTo(x, y + h/2);
                    ctx.lineTo(x + size/2, y - h/2);
                    ctx.lineTo(x - size/2, y - h/2);
                }
                ctx.closePath();
            }
        }

        /* --- KALEIDOSCOPE LOGIC (RESTORED FROM ORIGINAL) --- */
        class KaleidoGenerator {
            constructor(size) {
                this.size = size;
                this.elementsData = [];
                this.branch_settings = {
                    size: 150,
                    angle: 0.4,
                    scale: 0.67,
                    iterations: Math.max(1, Math.floor(state.elements / 100)),
                    offset: 0,
                    spiral_density: 0.05,
                };
                this.initElements();
            }

            initElements() {
                this.elementsData = [];
                const count = state.elements;
                const angle = 360 / state.slices;
                
                if (state.mode === 'Lines') {
                    for (let i = 0; i < count; i++) {
                        this.elementsData.push({
                            r1: Math.random(),
                            theta1: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            r2: Math.random(),
                            theta2: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * state.palette.length),
                            lineWidth: Math.floor(Math.random() * 4) + 1
                        });
                    }
                } else if (state.mode === 'Dots') {
                    for (let i = 0; i < count; i++) {
                        this.elementsData.push({
                            r: Math.random(),
                            theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * state.palette.length),
                            size_dot: Math.random() * 6 + 2
                        });
                    }
                } else if (state.mode === 'Shapes') {
                    for (let i = 0; i < count; i++) {
                        this.elementsData.push({
                            r: Math.random(),
                            theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * state.palette.length),
                            size_sq: Math.random() * 15 + 5
                        });
                    }
                } else if (state.mode === 'Mixed') {
                    for (let i = 0; i < count; i++) {
                        const type = ['Lines', 'Dots', 'Shapes'][Math.floor(Math.random() * 3)];
                        if (type === 'Lines') {
                            this.elementsData.push({
                                type: 'Lines',
                                r1: Math.random(),
                                theta1: (Math.random() * angle - angle / 2) * Math.PI / 180,
                                r2: Math.random(),
                                theta2: (Math.random() * angle - angle / 2) * Math.PI / 180,
                                colorIdx: Math.floor(Math.random() * state.palette.length),
                                lineWidth: Math.floor(Math.random() * 4) + 1
                            });
                        } else if (type === 'Dots') {
                            this.elementsData.push({
                                type: 'Dots',
                                r: Math.random(),
                                theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                                colorIdx: Math.floor(Math.random() * state.palette.length),
                                size_dot: Math.random() * 6 + 2
                            });
                        } else {
                            this.elementsData.push({
                                type: 'Shapes',
                                r: Math.random(),
                                theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                                colorIdx: Math.floor(Math.random() * state.palette.length),
                                size_sq: Math.random() * 15 + 5
                            });
                        }
                    }
                } else if (state.mode === 'Spiral') {
                    const spiral_count = Math.max(10, Math.floor(count / 10));
                    for (let i = 0; i < spiral_count; i++) {
                        this.elementsData.push({
                            theta_start: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            color_idx: Math.floor(Math.random() * state.palette.length)
                        });
                    }
                } else if (state.mode === 'Orbit') {
                     // Orbit uses specific fixed elements
                     const diameter = this.size;
                     const a = 0.266746, b = 0.321596, c = 0.223138;
                     this.elementsData = [
                        { width: diameter * a, top: (diameter/2 - (diameter*a/2)) * 0.60, left: diameter/2 - (diameter*a/2), blink: 'blink-lightest', speed: 5*a },
                        { width: diameter * a, top: (diameter/2 - (diameter*a/2)) * 1.22, left: (diameter/2 - (diameter*a/2)) * 0.65, blink: 'blink-lightest', speed: 5*a },
                        { width: diameter * a, top: (diameter/2 - (diameter*a/2)) * 1.22, right: (diameter/2 - (diameter*a/2)) * 0.65, blink: 'blink-lightest', speed: 5*a },
                        { width: diameter * b, top: (diameter/2 - (diameter*b/2)) * 0.52, left: diameter*b/7, blink: 'blink-lightest', speed: 5*b },
                        { width: diameter * b, top: (diameter/2 - (diameter*b/2)) * 0.52, right: diameter*b/7, blink: 'blink-lightest', speed: 5*b },
                        { width: diameter * b, bottom: 0, left: diameter/2 - (diameter*b/2), blink: 'blink', speed: 5*b },
                        { width: diameter * c, top: diameter*c/15, left: diameter*c * 1.23, blink: 'blink-lightest', speed: 6*c },
                        { width: diameter * c, top: diameter*c/15, right: diameter*c * 1.23, blink: 'blink-lightest', speed: 6*c },
                        { width: diameter * c, bottom: diameter*c/2.3, left: diameter*c * 0.55, blink: 'blink-lightest', speed: 6*c },
                        { width: diameter * c, bottom: diameter*c * 1.3, left: diameter*c * 0.05, blink: 'blink-lightest', speed: 6*c },
                        { width: diameter * c, bottom: diameter*c/2.3, right: diameter*c * 0.55, blink: 'blink-lightest', speed: 6*c },
                        { width: diameter * c, bottom: diameter*c * 1.3, right: diameter*c * 0.05, blink: 'blink-lightest', speed: 6*c },
                        { width: diameter * a, top: diameter/2 - (diameter*a/2), left: diameter/2 - (diameter*a/2), blink: 'blink', speed: 3 }
                    ];
                } else if (state.mode === 'DotToShape') {
                    for (let i = 0; i < count; i++) {
                        this.elementsData.push({
                            r: Math.random(),
                            theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * state.palette.length),
                            size_dot: Math.random() * 6 + 2,
                            size_sq: Math.random() * 15 + 5
                        });
                    }
                } else if (state.mode === 'DotsToMixed') {
                    for (let i = 0; i < count; i++) {
                        const type = ['Lines', 'Dots', 'Shapes'][Math.floor(Math.random() * 3)];
                        this.elementsData.push({
                            r: Math.random(),
                            theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * state.palette.length),
                            size_dot: Math.random() * 6 + 2,
                            type: type,
                            r1: type === 'Lines' ? Math.random() : null,
                            theta1: type === 'Lines' ? (Math.random() * angle - angle / 2) * Math.PI / 180 : null,
                            r2: type === 'Lines' ? Math.random() : null,
                            theta2: type === 'Lines' ? (Math.random() * angle - angle / 2) * Math.PI / 180 : null,
                            lineWidth: type === 'Lines' ? Math.floor(Math.random() * 4) + 1 : null,
                            size_sq: type === 'Shapes' ? Math.random() * 15 + 5 : null
                        });
                    }
                }
            }

            _interpolateColor(color1, color2, factor) {
                return [
                    Math.round(color1[0] * (1 - factor) + color2[0] * factor),
                    Math.round(color1[1] * (1 - factor) + color2[1] * factor),
                    Math.round(color1[2] * (1 - factor) + color2[2] * factor),
                    color1[3] * (1 - factor) + color2[3] * factor
                ];
            }

            // Helper for Orbit Mode
            _makeTrianglifyPattern(width, height, t) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                const cell_size = 50;
                for (let i = 0; i < width; i += cell_size) {
                    for (let j = 0; j < height; j += cell_size) {
                        const points = [[i, j], [i + cell_size, j], [i + cell_size, j + cell_size], [i, j + cell_size]];
                        const color1 = state.palette[Math.floor(Math.random() * state.palette.length)];
                        const color2 = state.palette[Math.floor(Math.random() * state.palette.length)];
                        const factor = t ? (Math.sin(t + i * 0.1 + j * 0.1) + 1) / 2 : 0;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color1, color2, factor).join(',')})`;
                        ctx.beginPath();
                        ctx.moveTo(points[0][0], points[0][1]); ctx.lineTo(points[1][0], points[1][1]); ctx.lineTo(points[2][0], points[2][1]); ctx.fill();
                        ctx.fillStyle = `rgba(${this._interpolateColor(color2, color1, factor).join(',')})`;
                        ctx.beginPath();
                        ctx.moveTo(points[0][0], points[0][1]); ctx.lineTo(points[2][0], points[2][1]); ctx.lineTo(points[3][0], points[3][1]); ctx.fill();
                    }
                }
                return canvas;
            }

            generateFrame(ctx, time) {
                const bg = state.backgroundColor;
                ctx.fillStyle = `rgba(${bg[0]}, ${bg[1]}, ${bg[2]}, ${bg[3]})`;
                ctx.fillRect(0, 0, this.size, this.size);

                const radius = this.size / 2;
                const cx = radius;
                const cy = radius;
                const sliceAngle = (360 / state.slices) * (Math.PI / 180);

                ctx.save();
                ctx.translate(cx, cy);
                
                // Slow global rotation
                ctx.rotate(time * 0.2);

                for (let s = 0; s < state.slices; s++) {
                    ctx.save();
                    ctx.rotate(s * sliceAngle);
                    if (s % 2 === 1) ctx.scale(1, -1); // Mirroring

                    this._drawElements(ctx, radius, time);
                    ctx.restore();
                }
                ctx.restore();
            }

            _drawElements(ctx, radius, t) {
                const mode = state.mode;
                const palette = state.palette;
                const cx = 0; // We are already translated
                const cy = 0;

                if (mode === 'Orbit') {
                    // Orbit mode draws specific elements relative to center
                    const diameter = this.size;
                    for (const config of this.elementsData) {
                        const width = config.width;
                        const height = width;
                        // Coordinates are relative to top-left of a full canvas, convert to center-relative
                        let x = config.left !== undefined ? config.left : diameter - config.right - width;
                        let y = config.top !== undefined ? config.top : diameter - config.bottom - height;
                        
                        // Adjust because we are at (0,0) center, but coords were 0-diameter
                        x = (x - diameter/2) * (1 + Math.sin(t) * 0.3);
                        y = (y - diameter/2) * (1 + Math.cos(t) * 0.3);
                        
                        const opacity = config.blink === 'blink' ? 0.5 + 0.5 * Math.sin(t / config.speed) :
                                        config.blink === 'blink-lighter' ? 0.3 + 0.2 * Math.sin(t / config.speed) :
                                        0.375 + 0.375 * Math.sin(t / config.speed);
                        
                        // Trianglify is heavy, optimize by only generating once per second or use simple color?
                        // For performance, we generate it. If it lags, we can cache it.
                        const pattern = this._makeTrianglifyPattern(width, height, t);
                        
                        ctx.save();
                        ctx.globalAlpha = opacity;
                        ctx.drawImage(pattern, x, y, width, height);
                        ctx.globalAlpha = 1;
                        ctx.strokeStyle = `rgba(0, 0, 255, ${0.5 + Math.sin(t) * 0.5})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(x + width / 2, y + height / 2, width / 2, 0, 2 * Math.PI);
                        ctx.stroke();
                        ctx.restore();
                    }
                    return; 
                }
                
                // Standard Slice Modes
                for (let i = 0; i < this.elementsData.length; i++) {
                    const d = this.elementsData[i];
                    let color = palette[0];
                    let nextColor = palette[1];
                    if (d.colorIdx !== undefined) {
                         color = palette[d.colorIdx % palette.length];
                         nextColor = palette[(d.colorIdx + 1) % palette.length];
                    }

                    const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                    const mixedColor = this._interpolateColor(color, nextColor, colorFactor);
                    const colorStr = `rgba(${mixedColor.join(',')})`;
                    
                    ctx.fillStyle = colorStr;
                    ctx.strokeStyle = colorStr;
                    const thetaOffset = Math.sin(t + i * 0.3) * 0.4;

                    // SPIRAL Logic
                    if (mode === 'Spiral') {
                        let theta_start = d.theta_start + t * 0.3;
                        const next_color_idx = (d.color_idx + 1) % palette.length;
                        const s = this.branch_settings;
                         for (let r = 0; r < radius; r += 5) { // increased step for perf
                            const theta = theta_start + r * s.spiral_density;
                            const x = r * Math.cos(theta);
                            const y = r * Math.sin(theta);
                            const width = Math.max(2, 4 + Math.sin(r * 0.03 + t) * 5);
                            ctx.beginPath();
                            ctx.arc(x, y, width, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                        continue;
                    }

                    // LINES Logic
                    if (mode === 'Lines' || (mode === 'Mixed' && d.type === 'Lines') || (mode === 'DotsToMixed' && d.type === 'Lines')) {
                        const x1 = d.r1 * radius * Math.cos(d.theta1 + thetaOffset);
                        const y1 = d.r1 * radius * Math.sin(d.theta1 + thetaOffset);
                        const x2 = d.r2 * radius * Math.cos(d.theta2 + thetaOffset);
                        const y2 = d.r2 * radius * Math.sin(d.theta2 + thetaOffset);
                        
                        // Morph logic
                        let lw = d.lineWidth * (1 + Math.sin(t + i * 0.3) * 0.8);
                        if (mode === 'DotsToMixed') {
                            const shapeFactor = (Math.sin(t * 2) + 1) / 2;
                            if (shapeFactor < 0.5) { /* Draw nothing or dot */ } 
                            else { lw *= (shapeFactor * 2 - 1); }
                        }

                        ctx.lineWidth = lw;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                    
                    // DOTS Logic
                    else if (mode === 'Dots' || (mode === 'Mixed' && d.type === 'Dots') || (mode === 'DotsToMixed' && (d.type === 'Dots' || ((Math.sin(t*2)+1)/2 < 0.5)))) {
                        const x = d.r * radius * Math.cos(d.theta + thetaOffset);
                        const y = d.r * radius * Math.sin(d.theta + thetaOffset);
                        let size = d.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                        
                        if (mode === 'DotsToMixed') {
                             const shapeFactor = (Math.sin(t * 2) + 1) / 2;
                             if (shapeFactor < 0.5) size *= (1 - shapeFactor * 2);
                             else if (d.type === 'Dots') size *= (shapeFactor * 2 - 1);
                             else size = 0;
                        }

                        if (size > 0) {
                            ctx.beginPath();
                            ctx.arc(x, y, size, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    } 
                    
                    // SHAPES Logic
                    else if (mode === 'Shapes' || (mode === 'Mixed' && d.type === 'Shapes') || (mode === 'DotsToMixed' && d.type === 'Shapes')) {
                        const x = d.r * radius * Math.cos(d.theta + thetaOffset);
                        const y = d.r * radius * Math.sin(d.theta + thetaOffset);
                        let size = d.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8);
                        
                        if (mode === 'DotsToMixed') {
                             const shapeFactor = (Math.sin(t * 2) + 1) / 2;
                             if (shapeFactor > 0.5) size *= (shapeFactor * 2 - 1);
                             else size = 0;
                        }

                        if (size > 0) {
                            ctx.fillRect(x - size, y - size, size * 2, size * 2);
                        }
                    }

                    // DOT TO SHAPE Logic
                    else if (mode === 'DotToShape') {
                        const x = d.r * radius * Math.cos(d.theta + thetaOffset);
                        const y = d.r * radius * Math.sin(d.theta + thetaOffset);
                        const size_dot = d.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                        const size_sq = d.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8);
                        const shapeFactor = (Math.sin(t * 2) + 1) / 2;
                        const size = size_dot * (1 - shapeFactor) + size_sq * shapeFactor;
                        const cornerRadius = size * (1 - shapeFactor);
                        
                        ctx.beginPath();
                        ctx.moveTo(x - size + cornerRadius, y - size);
                        ctx.lineTo(x + size - cornerRadius, y - size);
                        ctx.arcTo(x + size, y - size, x + size, y - size + cornerRadius, cornerRadius);
                        ctx.lineTo(x + size, y + size - cornerRadius);
                        ctx.arcTo(x + size, y + size, x + size - cornerRadius, y + size, cornerRadius);
                        ctx.lineTo(x - size + cornerRadius, y + size);
                        ctx.arcTo(x - size, y + size, x - size, y + size - cornerRadius, cornerRadius);
                        ctx.lineTo(x - size, y - size + cornerRadius);
                        ctx.arcTo(x - size, y - size, x - size + cornerRadius, y - size, cornerRadius);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }
        }

        /* --- APP CONTROLLER --- */
        const previewCanvas = document.getElementById('previewCanvas');
        const fullCanvas = document.getElementById('fullCanvas');
        const maskGenerator = new MosaicMaskGenerator();
        let kaleido = new KaleidoGenerator(CURRENT_SIZE);
        let mosaicMask = null;

        // DOM Elements
        const ui = {
            mode: document.getElementById('modeCombo'),
            elements: document.getElementById('elementSlider'),
            slices: document.getElementById('slicesSlider'),
            speed: document.getElementById('animationSpeedSlider'),
            mosaicType: document.getElementById('mosaicType'),
            tileSize: document.getElementById('tileSizeSlider'),
            glueThickness: document.getElementById('glueThicknessSlider'),
            chaos: document.getElementById('chaosSlider'),
            elementVal: document.getElementById('elementValue'),
            slicesVal: document.getElementById('slicesValue'),
            speedVal: document.getElementById('animationSpeedValue'),
            tileVal: document.getElementById('tileSizeValue'),
            glueVal: document.getElementById('glueThicknessValue'),
            chaosVal: document.getElementById('chaosValue'),
            glueColorBtn: document.getElementById('glueColorBtn')
        };

        /* --- INITIALIZATION --- */
        function init() {
            resizePreview();
            updateValues();
            updatePaletteUI();
            updateGlueColorUI();
            regenerateAll(); // First draw
            
            // Event Listeners
            window.addEventListener('resize', resizePreview);
            ui.mode.addEventListener('change', (e) => { 
                state.mode = e.target.value; 
                kaleido.initElements(); 
                drawFrame(0);
            });
            ui.elements.addEventListener('input', (e) => { state.elements = parseInt(e.target.value); ui.elementVal.innerText = state.elements; kaleido.initElements(); });
            ui.slices.addEventListener('input', (e) => { state.slices = parseInt(e.target.value); ui.slicesVal.innerText = state.slices; kaleido.initElements(); });
            ui.speed.addEventListener('input', (e) => { state.speed = parseFloat(e.target.value); ui.speedVal.innerText = state.speed; });
            
            // Mosaic Listeners (Re-generate mask only)
            const updateMosaic = () => {
                state.mosaic.type = ui.mosaicType.value;
                state.mosaic.size = parseInt(ui.tileSize.value);
                state.mosaic.gap = parseFloat(ui.glueThickness.value);
                state.mosaic.chaos = parseInt(ui.chaos.value);
                ui.tileVal.innerText = state.mosaic.size;
                ui.glueVal.innerText = state.mosaic.gap;
                ui.chaosVal.innerText = state.mosaic.chaos;
                generateMask(CURRENT_SIZE);
                if (!state.isAnimating) drawFrame(0);
            };

            ui.mosaicType.addEventListener('change', updateMosaic);
            ui.tileSize.addEventListener('input', updateMosaic);
            ui.glueThickness.addEventListener('input', updateMosaic);
            ui.chaos.addEventListener('input', updateMosaic);

            // Buttons
            document.getElementById('generateBtn').addEventListener('click', () => { kaleido.initElements(); if (!state.isAnimating) drawFrame(0); });
            document.getElementById('animateBtn').addEventListener('click', toggleAnimation);
            document.getElementById('viewBtn').addEventListener('click', openFullView);
            document.getElementById('saveBtn').addEventListener('click', saveImage);
            document.getElementById('closeModalBtn').addEventListener('click', closeModal);
            
            // Color Pickers
            setupColorPickers();
        }

        function resizePreview() {
            const containerWidth = document.querySelector('.lg\\:col-span-6').clientWidth;
            CURRENT_SIZE = Math.min(containerWidth, 800); 
            previewCanvas.width = CURRENT_SIZE;
            previewCanvas.height = CURRENT_SIZE;
            kaleido.size = CURRENT_SIZE;
            generateMask(CURRENT_SIZE);
            if (!state.isAnimating) drawFrame(0);
        }

        function regenerateAll() {
            kaleido.initElements();
            generateMask(CURRENT_SIZE);
            drawFrame(0);
        }

        function generateMask(size) {
            mosaicMask = maskGenerator.createMask(size, size, state.mosaic);
        }

        function drawFrame(timestamp) {
            // Use performance.now() if timestamp is 0 for initial draw
            const t = timestamp || performance.now();
            const time = t * 0.001 * state.speed; 
            const ctx = previewCanvas.getContext('2d');
            
            kaleido.generateFrame(ctx, time);
            
            if (mosaicMask) {
                ctx.drawImage(mosaicMask, 0, 0);
            }
        }

        function animateLoop(timestamp) {
            if (!state.isAnimating) return;
            drawFrame(timestamp);
            state.animId = requestAnimationFrame(animateLoop);
        }

        function toggleAnimation() {
            state.isAnimating = !state.isAnimating;
            const btn = document.getElementById('animateBtn');
            if (state.isAnimating) {
                btn.innerText = "‚èπ –°—Ç–æ–ø";
                btn.classList.add('bg-red-600', 'hover:bg-red-500');
                btn.classList.remove('bg-emerald-600', 'hover:bg-emerald-500');
                requestAnimationFrame(animateLoop);
            } else {
                btn.innerText = "‚ñ∂ –ê–Ω–∏–º–∞—Ü–∏—è";
                btn.classList.remove('bg-red-600', 'hover:bg-red-500');
                btn.classList.add('bg-emerald-600', 'hover:bg-emerald-500');
                cancelAnimationFrame(state.animId);
            }
        }

        /* --- FULL SCREEN LOGIC --- */
        function openFullView() {
            const modal = document.getElementById('imageModal');
            modal.classList.add('show');
            fullCanvas.width = FULL_SIZE;
            fullCanvas.height = FULL_SIZE;
            
            const fullMask = maskGenerator.createMask(FULL_SIZE, FULL_SIZE, state.mosaic);
            const fullKaleido = new KaleidoGenerator(FULL_SIZE);
            fullKaleido.elementsData = kaleido.elementsData; 
            
            const ctx = fullCanvas.getContext('2d');
            fullKaleido.generateFrame(ctx, performance.now() * 0.001 * state.speed);
            ctx.drawImage(fullMask, 0, 0);
        }

        function closeModal() {
            document.getElementById('imageModal').classList.remove('show');
        }

        function saveImage() {
            const saveSize = 2000;
            const cvs = document.createElement('canvas');
            cvs.width = saveSize;
            cvs.height = saveSize;
            const ctx = cvs.getContext('2d');

            const k = new KaleidoGenerator(saveSize);
            k.elementsData = kaleido.elementsData;
            
            const m = maskGenerator.createMask(saveSize, saveSize, state.mosaic);

            k.generateFrame(ctx, performance.now() * 0.001 * state.speed);
            ctx.drawImage(m, 0, 0);

            const link = document.createElement('a');
            link.download = `KaleidoMosaic_${Date.now()}.png`;
            link.href = cvs.toDataURL('image/png');
            link.click();
        }

        /* --- UI HELPER FUNCTIONS --- */
        function updateValues() { }

        function updatePaletteUI() {
            const grid = document.getElementById('paletteGrid');
            grid.innerHTML = '';
            state.palette.forEach((col, idx) => {
                const div = document.createElement('div');
                div.className = 'color-swatch';
                div.style.backgroundColor = `rgba(${col[0]},${col[1]},${col[2]},${col[3]})`;
                div.onclick = () => openColorModal('palette', idx);
                grid.appendChild(div);
            });
        }

        function updateGlueColorUI() {
            const col = state.mosaic.color;
            document.getElementById('glueColorBtn').style.backgroundColor = `rgba(${col[0]},${col[1]},${col[2]},${col[3]})`;
        }

        /* --- COLOR MODAL LOGIC --- */
        let editingType = null; 
        let editingIndex = -1;
        
        const modal = {
            el: document.getElementById('colorPickerModal'),
            input: document.getElementById('modalColorInput'),
            alpha: document.getElementById('modalAlphaInput'),
            save: document.getElementById('modalSaveBtn'),
            cancel: document.getElementById('modalCancelBtn')
        };

        function openColorModal(type, index) {
            editingType = type;
            editingIndex = index;
            modal.el.style.display = 'flex';
            
            let col;
            if (type === 'palette') col = state.palette[index];
            else if (type === 'glue') col = state.mosaic.color;
            else if (type === 'bg') col = state.backgroundColor;

            modal.input.value = rgbToHex(col);
            modal.alpha.value = col[3];
        }

        function setupColorPickers() {
            document.getElementById('addColorBtn').onclick = () => {
                if (state.palette.length < 12) {
                    state.palette.push([Math.random()*255|0, Math.random()*255|0, Math.random()*255|0, 1]);
                    updatePaletteUI();
                    kaleido.initElements();
                }
            };
            document.getElementById('removeColorBtn').onclick = () => {
                if (state.palette.length > 2) {
                    state.palette.pop();
                    updatePaletteUI();
                    kaleido.initElements();
                }
            };
            ui.glueColorBtn.onclick = () => openColorModal('glue');
            document.getElementById('changeBackgroundColorBtn').onclick = () => openColorModal('bg');

            modal.cancel.onclick = () => modal.el.style.display = 'none';
            modal.save.onclick = () => {
                const hex = modal.input.value;
                const r = parseInt(hex.substr(1,2), 16);
                const g = parseInt(hex.substr(3,2), 16);
                const b = parseInt(hex.substr(5,2), 16);
                const a = parseFloat(modal.alpha.value);
                const newCol = [r,g,b,a];

                if (editingType === 'palette') {
                    state.palette[editingIndex] = newCol;
                    updatePaletteUI();
                    kaleido.initElements();
                } else if (editingType === 'glue') {
                    state.mosaic.color = newCol;
                    updateGlueColorUI();
                    generateMask(CURRENT_SIZE);
                } else if (editingType === 'bg') {
                    state.backgroundColor = newCol;
                }
                
                modal.el.style.display = 'none';
                if (!state.isAnimating) drawFrame(0);
            };
        }

        function rgbToHex(c) {
            return "#" + ((1 << 24) + (c[0] << 16) + (c[1] << 8) + c[2]).toString(16).slice(1);
        }

        // Start
        init();

    </script>
</body>
</html>
