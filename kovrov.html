<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ü–∞—Ç—Ç–µ—Ä–Ω–æ–≤</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --gold-primary: #d4af37;
            --gold-hover: #b5952f;
            --dark-bg: #0f172a;
            --panel-bg: #1e293b;
        }
        body {
            background-color: var(--dark-bg);
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%231e293b' fill-opacity='0.4'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            color: #e2e8f0;
            font-family: 'Inter', sans-serif;
        }
        h1, h2, h3, .serif {
            font-family: 'Playfair Display', serif;
        }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #475569; }

        .checkbox-wrapper input:checked + div {
            background-color: var(--gold-primary);
            border-color: var(--gold-primary);
        }
        .checkbox-wrapper input:checked + div svg {
            display: block;
        }

        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--gold-primary);
            margin-top: -6px;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #334155;
            border-radius: 2px;
        }

        .rug-texture {
            box-shadow: 0 20px 50px -12px rgba(0, 0, 0, 0.7);
            border: 1px solid #334155;
        }

        .btn-gold {
            background: linear-gradient(135deg, #d4af37 0%, #aa8c2c 100%);
            color: #1a1a1a;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.2);
        }
        .btn-gold:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.3);
            filter: brightness(1.1);
        }
        .btn-outline {
            border: 1px solid #475569;
            color: #cbd5e1;
            transition: all 0.2s;
        }
        .btn-outline:hover {
            border-color: var(--gold-primary);
            color: var(--gold-primary);
        }

        .control-group {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.05);
        }

        .color-swatch {
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .color-swatch:hover {
            transform: scale(1.2) rotate(5deg);
            z-index: 10;
            box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }

        .loader {
            border-top-color: var(--gold-primary);
            -webkit-animation: spinner 1.5s linear infinite;
            animation: spinner 1.5s linear infinite;
        }
        @keyframes spinner { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <header class="bg-slate-900/90 backdrop-blur-md border-b border-slate-800 sticky top-0 z-40">
        <div class="container mx-auto px-6 py-4 flex justify-between items-center">
            <div class="flex items-center gap-3">
                <div class="w-8 h-8 bg-gradient-to-br from-yellow-400 to-yellow-700 rounded-sm rotate-45 shadow-lg shadow-yellow-900/50"></div>
                <h1 class="text-2xl font-bold text-white tracking-wide"><span class="text-yellow-500">–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ü–∞—Ç—Ç–µ—Ä–Ω–æ–≤</h1>
            </div>
            <button id="homeBtn" class="text-sm text-slate-400 hover:text-white transition-colors flex items-center gap-2 border border-slate-600 rounded px-3 py-1.5 hover:border-yellow-500 hover:text-yellow-500">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5"/><path d="M12 19l-7-7 7-7"/></svg>
                –ù–∞–∑–∞–¥
            </button>
        </div>
    </header>

    <main class="flex-1 container mx-auto p-4 lg:p-6 grid grid-cols-1 lg:grid-cols-12 gap-8">
        
        <aside class="lg:col-span-4 space-y-6">
            
            <div class="control-group p-6 rounded-xl shadow-xl">
                <h2 class="text-lg font-semibold text-yellow-500 mb-5 border-b border-slate-700 pb-2">–ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –£–∑–æ—Ä–∞</h2>
                
                <div class="space-y-5">
                    <label class="checkbox-wrapper flex items-center cursor-pointer group">
                        <input type="checkbox" id="persianMode" class="hidden">
                        <div class="w-5 h-5 border-2 border-slate-500 rounded mr-3 flex items-center justify-center transition-colors group-hover:border-yellow-500 bg-slate-800">
                            <svg class="w-3 h-3 text-slate-900 hidden pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="4" d="M5 13l4 4L19 7"></path></svg>
                        </div>
                        <span class="text-sm font-medium text-yellow-500 group-hover:text-yellow-400">–ü–µ—Ä—Å–∏–¥—Å–∫–∏–π —Å—Ç–∏–ª—å (–ß–µ—Ç–∫–∞—è –∫–∞–π–º–∞)</span>
                    </label>

                    <div>
                        <label class="text-xs uppercase tracking-wider text-slate-400 font-semibold mb-2 block">–°—Ç–∏–ª—å –ø–ª–µ—Ç–µ–Ω–∏—è</label>
                        <select id="modeCombo" class="w-full bg-slate-800 border border-slate-600 rounded-lg px-4 py-2.5 text-white focus:ring-2 focus:ring-yellow-500 focus:border-transparent outline-none transition-all">
                            <option>–õ–∏–Ω–∏–∏</option>
                            <option>–¢–æ—á–∫–∏</option>
                            <option>–§–∏–≥—É—Ä—ã</option>
                            <option>–°–º–µ—à–∞–Ω–Ω—ã–π</option>
                            <option>–°–ø–∏—Ä–∞–ª—å</option>
                            <option>–û—Ä–±–∏—Ç—ã</option>
                            <option>–¢–æ—á–∫–∏ –≤ –§–∏–≥—É—Ä—ã</option>
                            <option>–¢–æ—á–∫–∏ –≤ –°–º–µ—à–∞–Ω–Ω—ã–π</option>
                            <option>–ö–æ–≤–µ—Ä</option>
                            <option>–û—Ä–≥–∞–Ω–∏—á–µ—Å–∫–∏–π</option>
                        </select>
                    </div>

                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label class="text-xs text-slate-400 mb-1 block">–ü–ª–æ—Ç–Ω–æ—Å—Ç—å —É–∑–ª–æ–≤: <span id="elementValue" class="text-yellow-400">600</span></label>
                            <input type="range" id="elementSlider" min="100" max="2000" value="600" class="w-full">
                        </div>
                        <div>
                            <label class="text-xs text-slate-400 mb-1 block">–°–∏–º–º–µ—Ç—Ä–∏—è: <span id="slicesValue" class="text-yellow-400">13</span></label>
                            <input type="range" id="slicesSlider" min="3" max="40" value="13" class="w-full">
                        </div>
                    </div>

                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label class="text-xs text-slate-400 mb-1 block">–¢–∞–π–ª—ã (–®–∏—Ä): <span id="tileWidthValue" class="text-yellow-400">2</span></label>
                            <input type="range" id="tileWidthSlider" min="1" max="10" value="2" class="w-full">
                        </div>
                        <div>
                            <label class="text-xs text-slate-400 mb-1 block">–¢–∞–π–ª—ã (–í—ã—Å): <span id="tileHeightValue" class="text-yellow-400">3</span></label>
                            <input type="range" id="tileHeightSlider" min="1" max="5" value="3" class="w-full">
                        </div>
                    </div>
                </div>
            </div>

            <div class="control-group p-6 rounded-xl shadow-xl">
                <h2 class="text-lg font-semibold text-yellow-500 mb-5 border-b border-slate-700 pb-2">–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –§–æ–Ω–∞</h2>
                <div class="space-y-5">
                    <div>
                        <label class="text-xs text-slate-400 mb-1 block">–ü–ª–æ—Ç–Ω–æ—Å—Ç—å —Ñ–æ–Ω–∞: <span id="bgDensityValue" class="text-yellow-400">100%</span></label>
                        <input type="range" id="bgDensitySlider" min="0" max="300" value="100" class="w-full">
                    </div>
                    <div>
                        <label class="text-xs text-slate-400 mb-1 block">–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å —Ñ–æ–Ω–∞: <span id="bgOpacityValue" class="text-yellow-400">0.1</span></label>
                        <input type="range" id="bgOpacitySlider" min="0" max="1" step="0.01" value="0.1" class="w-full">
                    </div>
                </div>
            </div>

            <div class="control-group p-6 rounded-xl shadow-xl">
                <div class="flex justify-between items-center mb-4 border-b border-slate-700 pb-2">
                    <h2 class="text-lg font-semibold text-yellow-500">–ù–∏—Ç–∏ –∏ –¶–≤–µ—Ç–∞</h2>
                    <button id="changeBackgroundColorBtn" class="text-xs bg-slate-700 hover:bg-slate-600 px-2 py-1 rounded text-white transition">–¶–≤–µ—Ç –æ—Å–Ω–æ–≤–∞–Ω–∏—è</button>
                </div>

                <div id="paletteContainer" class="grid grid-cols-5 gap-3 mb-4">
                </div>

                <div class="flex gap-2">
                    <button id="addColorBtn" class="flex-1 btn-outline py-2 rounded-lg text-sm font-medium">+ –î–æ–±–∞–≤–∏—Ç—å</button>
                    <button id="removeColorBtn" class="flex-1 btn-outline py-2 rounded-lg text-sm font-medium hover:border-red-500 hover:text-red-500">- –£–¥–∞–ª–∏—Ç—å</button>
                </div>
            </div>

            <div class="bg-gradient-to-r from-slate-800 to-slate-900 p-6 rounded-xl shadow-xl border border-slate-700">
                <button id="generateBtn" class="w-full btn-gold py-3.5 rounded-lg text-lg mb-4 shadow-lg shadow-yellow-900/20">
                    –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –£–∑–æ—Ä
                </button>
                <div class="grid grid-cols-2 gap-3">
                    <button id="viewBtn" class="btn-outline bg-slate-800 py-2.5 rounded-lg text-sm">üëÅÔ∏è –ü—Ä–æ—Å–º–æ—Ç—Ä HD</button>
                    <button id="saveBtn" class="btn-outline bg-slate-800 py-2.5 rounded-lg text-sm">üíæ PNG</button>
                    <button id="savePdfBtn" class="col-span-2 btn-outline bg-slate-800 py-2.5 rounded-lg text-sm">üìÑ –≠–∫—Å–ø–æ—Ä—Ç –≤ PDF</button>
                </div>
            </div>

        </aside>

        <div class="lg:col-span-8 flex flex-col justify-center">
            <div class="relative group">
                <div class="absolute -inset-1 bg-gradient-to-r from-yellow-600 to-yellow-300 rounded-xl blur opacity-25 group-hover:opacity-50 transition duration-1000 group-hover:duration-200"></div>
                
                <div class="relative bg-white rounded-lg overflow-hidden rug-texture flex items-center justify-center min-h-[400px] lg:min-h-[600px]">
                     <div id="loadingOverlay" class="absolute inset-0 bg-slate-900/80 z-10 hidden flex-col items-center justify-center">
                        <div class="loader ease-linear rounded-full border-4 border-t-4 border-slate-200 h-12 w-12 mb-4"></div>
                        <h2 class="text-center text-white text-xl font-semibold">–¢–∫–∞—á–µ—Å—Ç–≤–æ...</h2>
                    </div>
                    
                    <canvas id="previewCanvas" class="max-w-full max-h-[80vh] object-contain shadow-inner"></canvas>
                    
                    <div id="emptyState" class="absolute inset-0 flex items-center justify-center pointer-events-none">
                        <div class="text-center text-slate-400">
                            <p class="text-lg font-serif italic opacity-50">"–ö–∞–∂–¥—ã–π –∫–æ–≤–µ—Ä —Ä–∞—Å—Å–∫–∞–∑—ã–≤–∞–µ—Ç –∏—Å—Ç–æ—Ä–∏—é"</p>
                            <p class="text-sm mt-2">–ù–∞–∂–º–∏—Ç–µ "–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å"</p>
                        </div>
                    </div>
                </div>
            </div>
            <div class="flex justify-between mt-4 text-slate-500 text-xs px-2">
                <span>Simulation Engine: v2.5 (Distinct Outlines)</span>
                <span>–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ü–∞—Ç—Ç–µ—Ä–Ω–æ–≤</span>
            </div>
        </div>

    </main>

    <div id="imageModal" class="fixed inset-0 bg-slate-950/90 hidden flex items-center justify-center p-4 z-50 backdrop-blur-sm">
        <div class="bg-slate-900 p-2 rounded-xl max-w-[95vw] max-h-[95vh] overflow-auto border border-slate-700 shadow-2xl relative">
            <button id="closeModalBtn" class="absolute top-4 right-4 bg-red-500 hover:bg-red-600 text-white w-8 h-8 rounded-full flex items-center justify-center shadow-lg z-10">√ó</button>
            <canvas id="fullCanvas" class="mx-auto rounded shadow-2xl"></canvas>
        </div>
    </div>

    <div id="pdfModal" class="fixed inset-0 bg-black/80 hidden flex items-center justify-center p-4 z-50 backdrop-blur-sm">
        <div class="control-group bg-slate-800 p-8 rounded-xl max-w-md w-full border border-slate-600 shadow-2xl">
            <h2 class="text-2xl font-serif font-bold mb-6 text-yellow-500">–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≠–∫—Å–ø–æ—Ä—Ç–∞</h2>
            
            <label class="block text-sm font-medium mb-2 text-slate-300">–§–æ—Ä–º–∞—Ç –±—É–º–∞–≥–∏</label>
            <select id="paperSize" class="w-full p-3 border border-slate-600 rounded-lg bg-slate-900 text-white mb-4 focus:ring-2 focus:ring-yellow-500 outline-none">
                <option value="a4-portrait">A4 –ü–æ—Ä—Ç—Ä–µ—Ç</option>
                <option value="a4-landscape">A4 –ê–ª—å–±–æ–º</option>
                <option value="a3-portrait">A3 –ü–æ—Ä—Ç—Ä–µ—Ç</option>
                <option value="a3-landscape">A3 –ê–ª—å–±–æ–º</option>
                <option value="custom">–°–≤–æ–π —Ä–∞–∑–º–µ—Ä</option>
            </select>
            
            <div id="customSizeDiv" class="hidden space-y-3 mb-6 p-4 bg-slate-900 rounded-lg border border-slate-700">
                <div>
                    <label class="text-xs text-slate-400">–®–∏—Ä–∏–Ω–∞ (—Å–º)</label>
                    <input type="number" id="customWidth" class="w-full bg-slate-800 border border-slate-600 rounded p-2 text-white" value="21">
                </div>
                <div>
                    <label class="text-xs text-slate-400">–í—ã—Å–æ—Ç–∞ (—Å–º)</label>
                    <input type="number" id="customHeight" class="w-full bg-slate-800 border border-slate-600 rounded p-2 text-white" value="29.7">
                </div>
            </div>

            <div class="flex gap-3 mt-6">
                <button id="closePdfModalBtn" class="flex-1 py-3 rounded-lg border border-slate-600 text-slate-300 hover:bg-slate-700">–û—Ç–º–µ–Ω–∞</button>
                <button id="generatePdfBtn" class="flex-1 py-3 rounded-lg btn-gold shadow-lg">–°–∫–∞—á–∞—Ç—å PDF (Fit to Page)</button>
            </div>
        </div>
    </div>

    <script>
        const DPI = 300;
        const CM_TO_INCH = 1 / 2.54;
        const MAIN_CM = 15;
        const BORDER_CM = 1;
        const PREVIEW_TILE_PX = 300;
        const PREVIEW_BORDER_PX = 20;

        let backgroundColor = [30, 41, 59, 1]; 
        
        const DEFAULT_PALETTE = {
            '1': [180, 83, 9, 1],   
            '2': [29, 78, 216, 1],  
            '3': [185, 28, 28, 1],  
            '4': [234, 179, 8, 1],  
            '5': [20, 83, 45, 1]    
        };
        
        const AVAILABLE_COLORS = [
            [124, 45, 18, 1], [234, 88, 12, 1], [251, 191, 36, 1],
            [67, 56, 202, 1], [30, 58, 138, 1], [15, 23, 42, 1],   
            [190, 24, 93, 1], [131, 24, 67, 1], [255, 255, 255, 1] 
        ];

        let palette = JSON.parse(JSON.stringify(DEFAULT_PALETTE));
        let colorIndex = 0;
        let currentSeed = Math.random() * 1e9 | 0;
        let currentImage = null;

        class PRNG {
            constructor(seed) {
                this.seed = seed % 2147483647;
                if (this.seed <= 0) this.seed += 2147483646;
            }
            next() { return this.seed = (this.seed * 16807) % 2147483647; }
            random() { return (this.next() - 1) / 2147483646; }
        }

        // --- Helper Functions ---
        function drawShape(ctx, shapeType, x, y, size, rotation, color) {
            ctx.fillStyle = `rgba(${color.join(',')})`;
            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.shadowBlur = 2; 
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.beginPath();
            
            if (shapeType === 'square') ctx.rect(-size, -size, size * 2, size * 2);
            else if (shapeType === 'circle') ctx.arc(0, 0, size, 0, 2 * Math.PI);
            else if (shapeType === 'triangle') {
                ctx.moveTo(0, -size);
                ctx.lineTo(size * Math.sqrt(3) / 2, size / 2);
                ctx.lineTo(-size * Math.sqrt(3) / 2, size / 2);
                ctx.closePath();
            } else if (shapeType === 'diamond') {
                ctx.moveTo(0, -size); ctx.lineTo(size, 0); ctx.lineTo(0, size); ctx.lineTo(-size, 0); ctx.closePath();
            } else if (shapeType === 'star') {
                let rot = Math.PI / 2 * 3; let step = Math.PI / 5; ctx.moveTo(0, -size);
                for (let j = 0; j < 5; j++) {
                    ctx.lineTo(Math.cos(rot) * size, Math.sin(rot) * size); rot += step;
                    ctx.lineTo(Math.cos(rot) * (size / 2.6), Math.sin(rot) * (size / 2.6)); rot += step;
                } ctx.closePath();
            } else if (shapeType === 'flower') {
                for (let p = 0; p < 6; p++) {
                    ctx.save(); ctx.rotate(p * Math.PI / 3);
                    ctx.ellipse(size / 2, 0, size / 2, size / 4, 0, 0, 2 * Math.PI); ctx.restore();
                } ctx.arc(0, 0, size / 4, 0, 2 * Math.PI);
            } else if (shapeType === 'bird') {
                ctx.moveTo(-size, size / 2); ctx.quadraticCurveTo(0, -size, size, 0);
                ctx.quadraticCurveTo(0, size, -size, size / 2); ctx.closePath();
            } else if (shapeType === 'boteh') {
                ctx.moveTo(0, -size);
                ctx.bezierCurveTo(size * 0.8, -size * 0.8, size * 1.2, -size * 0.2, size, 0);
                ctx.bezierCurveTo(size * 0.8, size * 0.2, size * 0.4, size * 0.4, 0, size * 0.3);
                ctx.bezierCurveTo(-size * 0.4, size * 0.4, -size * 0.8, size * 0.2, -size * 0.5, 0);
                ctx.bezierCurveTo(-size * 0.8, -size * 0.2, -size * 0.4, -size * 0.8, 0, -size);
                ctx.closePath();
            }
            ctx.fill();
            ctx.restore();
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }

        function createNoiseCanvas(opacity = 0.05) {
            const canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 200;
            const ctx = canvas.getContext('2d');
            const idata = ctx.createImageData(200, 200);
            const buffer32 = new Uint32Array(idata.data.buffer);
            const len = buffer32.length;
            for (let i = 0; i < len; i++) {
                if (Math.random() < 0.5) buffer32[i] = (Math.floor(255 * opacity) << 24); 
            }
            ctx.putImageData(idata, 0, 0);
            return canvas;
        }

        function createWeavePattern(scale = 1) {
            const canvas = document.createElement('canvas');
            const s = 4 * scale; 
            canvas.width = s;
            canvas.height = s;
            const ctx = canvas.getContext('2d');
            ctx.strokeStyle = "rgba(0,0,0,0.1)";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0,0); ctx.lineTo(s,s);
            ctx.moveTo(s,0); ctx.lineTo(0,s);
            ctx.stroke();
            return canvas;
        }

        function applyRugTexture(ctx, width, height, scale = 1) {
            ctx.save();
            ctx.globalCompositeOperation = 'multiply';
            const weaveCanvas = createWeavePattern(Math.max(1, scale));
            const weavePattern = ctx.createPattern(weaveCanvas, 'repeat');
            ctx.fillStyle = weavePattern;
            ctx.fillRect(0, 0, width, height);

            ctx.globalCompositeOperation = 'overlay';
            const noiseCanvas = createNoiseCanvas(0.15); 
            const noisePattern = ctx.createPattern(noiseCanvas, 'repeat');
            ctx.fillStyle = noisePattern;
            ctx.fillRect(0, 0, width, height);

            ctx.globalCompositeOperation = 'multiply';
            const gradient = ctx.createRadialGradient(width/2, height/2, Math.min(width, height)*0.3, width/2, height/2, Math.min(width, height)*0.8);
            gradient.addColorStop(0, "rgba(0,0,0,0)");
            gradient.addColorStop(1, "rgba(0,0,0,0.2)");
            ctx.fillStyle = gradient;
            ctx.fillRect(0,0,width,height);
            ctx.restore();
        }

        // --- Generator Class ---
        class KaleidoGenerator {
            constructor(tile_size, palette, mode, sectors, elements, slices, prng, isPersian = false) {
                this.tile_size = tile_size;
                this.palette = Object.values(palette);
                this.mode = mode;
                this.sectors = isPersian ? Math.max(slices, 16) : slices; 
                this.base_elements = elements;
                this.slices = slices;
                this.isPersian = isPersian;
                this.sizeScale = this.tile_size / PREVIEW_TILE_PX;
                this.elements = Math.round(this.base_elements * Math.pow(this.sizeScale, 2));
                this.prng = prng;
                this.elementsData = [];
                this.initElements();
            }

            initElements() {
                const random = this.prng.random.bind(this.prng);
                this.elementsData = [];
                const angle = 360 / this.sectors;
                let shapeTypes = ['square', 'circle', 'triangle', 'diamond', 'star', 'flower', 'bird', 'boteh'];
                
                if (this.isPersian) {
                    shapeTypes = ['boteh', 'flower', 'star', 'diamond', 'bird'];
                }

                for (let i = 0; i < this.elements; i++) {
                    const r = Math.pow(random(), 0.5);
                    const theta = (random() - 0.5) * angle * Math.PI / 180;
                    const colorIdx = Math.floor(random() * this.palette.length);
                    
                    let elem = { r, theta, colorIdx };
                    const forceShape = this.isPersian && random() < 0.4;

                    if (!forceShape && (this.mode === 'Lines' || (this.mode === 'Mixed' && random() < 0.33))) {
                        elem.type = 'Lines';
                        elem.r1 = 0; elem.theta1 = 0; elem.r2 = Math.sqrt(random()); elem.theta2 = theta;
                        elem.lineWidth = (Math.floor(random() * 4) + 1) * this.sizeScale;
                    } else if (!forceShape && (this.mode === 'Dots' || (this.mode === 'Mixed' && random() < 0.66))) {
                        elem.type = 'Dots';
                        elem.size_dot = ((1 - r) * 10 + 5) * this.sizeScale;
                    } else {
                        elem.type = 'Shapes';
                        elem.size_sq = ((1 - r) * 20 + 8) * this.sizeScale;
                        elem.shapeType = shapeTypes[Math.floor(random() * shapeTypes.length)];
                        elem.rotation = random() * 2 * Math.PI;
                    }
                    this.elementsData.push(elem);
                }
                
                if(this.mode === 'Spiral') {
                     const spiral_count = Math.floor(this.elements / 10);
                     this.elementsData = [];
                     for(let i=0; i<spiral_count; i++) this.elementsData.push({theta_start: (random()*angle-angle/2)*Math.PI/180, color_idx: Math.floor(random()*this.palette.length)});
                }
            }

            generateTile(canvas) {
                const ctx = canvas.getContext('2d');
                canvas.width = this.tile_size;
                canvas.height = this.tile_size;
                
                const radius = this.tile_size / 2;
                const cx = radius, cy = radius;
                const angle = 360 / this.sectors;

                const wedgeCanvas = document.createElement('canvas');
                wedgeCanvas.width = this.tile_size;
                wedgeCanvas.height = this.tile_size;
                const wCtx = wedgeCanvas.getContext('2d');

                this.elementsData.forEach(d => {
                    const safeIndex = d.colorIdx % this.palette.length;
                    const color = this.palette[safeIndex] || [0,0,0,1]; 

                    wCtx.fillStyle = `rgba(${color.join(',')})`;
                    wCtx.strokeStyle = `rgba(${color.join(',')})`;
                    wCtx.shadowColor = "rgba(0,0,0,0.1)";
                    wCtx.shadowBlur = 2;
                    
                    if (d.type === 'Lines') {
                        let r1=d.r1||0, t1=d.theta1||0, r2=d.r2||d.r, t2=d.theta2||d.theta;
                        wCtx.lineWidth = d.lineWidth || 2;
                        wCtx.beginPath();
                        wCtx.moveTo(cx + r1 * radius * Math.cos(t1), cy + r1 * radius * Math.sin(t1));
                        wCtx.quadraticCurveTo(cx, cy, cx + r2 * radius * Math.cos(t2), cy + r2 * radius * Math.sin(t2));
                        wCtx.stroke();
                    } else if (d.type === 'Dots') {
                        let size = d.size_dot || 5;
                        wCtx.beginPath();
                        wCtx.arc(cx + d.r * radius * Math.cos(d.theta), cy + d.r * radius * Math.sin(d.theta), size, 0, 2*Math.PI);
                        wCtx.fill();
                    } else if (this.mode === 'Spiral') {
                         const current_color = this.palette[d.color_idx % this.palette.length] || [0,0,0,1];
                         for (let r = 0; r < radius; r += 2 * this.sizeScale) {
                            const theta = d.theta_start + r * 0.05;
                            const x = cx + r * Math.cos(theta);
                            const y = cy + r * Math.sin(theta);
                            wCtx.fillStyle = `rgba(${current_color.join(',')})`; 
                            wCtx.beginPath(); wCtx.arc(x, y, (2 + Math.random()*3)*this.sizeScale, 0, 2*Math.PI); wCtx.fill();
                         }
                    } else {
                        let size = d.size_sq || 10;
                        drawShape(wCtx, d.shapeType, cx + d.r * radius * Math.cos(d.theta), cy + d.r * radius * Math.sin(d.theta), size, d.rotation, color);
                    }
                });

                for (let i = 0; i < this.sectors; i++) {
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(i * angle * Math.PI / 180);
                    if (i % 2 === 1) ctx.scale(-1, 1);
                    
                    ctx.beginPath();
                    ctx.moveTo(0,0);
                    ctx.arc(0,0, radius*1.5, -0.1, (angle * Math.PI / 180) + 0.1);
                    ctx.closePath();
                    
                    ctx.drawImage(wedgeCanvas, -cx, -cy);
                    ctx.restore();
                }
                
                ctx.globalCompositeOperation = 'destination-in';
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
            }
        }

        // --- –§—É–Ω–∫—Ü–∏—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ —Å–ª–æ–∂–Ω–æ–≥–æ –±–æ—Ä–¥—é—Ä–∞ ---
        function drawComplexBorder(ctx, w, h, borderPx, palette, prng, isPersian) {
            const colors = Object.values(palette);
            const random = prng.random.bind(prng);
            if (colors.length === 0) return;

            const mainColor = colors[0] || [0,0,0,1];
            const secColor = colors[1] || colors[0] || [255,255,255,1];
            const accentColor = colors[2] || secColor;

            // 1. –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç—É—Ä
            ctx.lineWidth = borderPx;
            ctx.strokeStyle = `rgba(${mainColor.join(',')})`;
            ctx.strokeRect(borderPx/2, borderPx/2, w - borderPx, h - borderPx);

            if (isPersian) {
                const innerBandWidth = borderPx * 0.4;
                const innerOffset = borderPx * 0.6;
                
                ctx.strokeStyle = `rgba(${secColor.join(',')})`;
                ctx.lineWidth = innerBandWidth;
                ctx.strokeRect(innerOffset, innerOffset, w - innerOffset*2, h - innerOffset*2);

                const motifSpacing = borderPx * 1.2;
                const motifSize = borderPx * 0.3;
                const shape = ['boteh', 'star', 'flower'][Math.floor(random() * 3)];
                
                for(let x = borderPx; x < w - borderPx; x += motifSpacing) {
                    drawShape(ctx, shape, x, borderPx/2, motifSize, Math.PI, accentColor);
                    drawShape(ctx, shape, x, h - borderPx/2, motifSize, 0, accentColor);
                }
                for(let y = borderPx; y < h - borderPx; y += motifSpacing) {
                    drawShape(ctx, shape, borderPx/2, y, motifSize, Math.PI/2, accentColor);
                    drawShape(ctx, shape, w - borderPx/2, y, motifSize, -Math.PI/2, accentColor);
                }
            } else {
                ctx.strokeStyle = `rgba(${secColor.join(',')})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 10]);
                ctx.strokeRect(borderPx/4, borderPx/4, w - borderPx/2, h - borderPx/2);
                ctx.setLineDash([]);
                
                const dotSize = borderPx * 0.3;
                ctx.fillStyle = `rgba(${accentColor.join(',')})`;
                ctx.beginPath(); ctx.arc(borderPx/2, borderPx/2, dotSize, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(w-borderPx/2, borderPx/2, dotSize, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(borderPx/2, h-borderPx/2, dotSize, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(w-borderPx/2, h-borderPx/2, dotSize, 0, Math.PI*2); ctx.fill();
            }
        }

        function drawBackgroundDecorations(ctx, w, h, palette, prng, mode, scale = 1, userDensityFactor = 1, userOpacity = 0.1) {
            const colors = Object.values(palette);
            const random = prng.random.bind(prng);
            
            const baseDensity = Math.floor((w * h) / 6000);
            const density = Math.floor(baseDensity * userDensityFactor);
            
            if (mode === 'Lines') {
                ctx.lineWidth = 1.5 * scale;
                for(let i=0; i<density; i++) {
                    const col = colors[Math.floor(random() * colors.length)];
                    ctx.strokeStyle = `rgba(${col[0]},${col[1]},${col[2]}, ${userOpacity})`;
                    ctx.beginPath();
                    ctx.moveTo(random()*w, random()*h);
                    ctx.bezierCurveTo(random()*w, random()*h, random()*w, random()*h, random()*w, random()*h);
                    ctx.stroke();
                }
            } else if (mode === 'Spiral') {
                for(let i=0; i<density/2; i++) {
                    const col = colors[Math.floor(random() * colors.length)];
                    ctx.strokeStyle = `rgba(${col[0]},${col[1]},${col[2]}, ${userOpacity})`;
                    const cx = random()*w, cy = random()*h;
                    ctx.beginPath();
                    for(let t=0; t<10; t+=0.5) {
                        const r = t * 5 * scale;
                        ctx.lineTo(cx + r*Math.cos(t), cy + r*Math.sin(t));
                    }
                    ctx.stroke();
                }
            } else if (mode === 'Orbit') {
                 for(let i=0; i<density/1.5; i++) {
                    const col = colors[Math.floor(random() * colors.length)];
                    ctx.strokeStyle = `rgba(${col[0]},${col[1]},${col[2]}, ${userOpacity})`;
                    const cx = random()*w, cy = random()*h;
                    const r = random() * 50 * scale;
                    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
                    ctx.beginPath(); ctx.arc(cx, cy, r + 5*scale, 0, Math.PI*2); ctx.stroke();
                }
            } else if (mode === 'Shapes' || mode === 'DotToShape') {
                const shapes = ['square', 'triangle', 'diamond'];
                for(let i=0; i<density; i++) {
                    const col = colors[Math.floor(random() * colors.length)];
                    const type = shapes[Math.floor(random()*shapes.length)];
                    drawShape(ctx, type, random()*w, random()*h, (random()*15+5)*scale, random()*Math.PI, [...col.slice(0,3), userOpacity]);
                }
            } else if (mode === 'Carpet') {
                 const step = 20 * scale;
                 const effectiveDensity = Math.max(5, step / userDensityFactor); 
                 for(let x=0; x<w; x+=effectiveDensity) {
                     ctx.strokeStyle = `rgba(255,255,255,${userOpacity * 0.3})`;
                     ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
                 }
                 for(let y=0; y<h; y+=effectiveDensity) {
                     ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
                 }
            } else {
                for(let i=0; i<density; i++) {
                    const col = colors[Math.floor(random() * colors.length)];
                    ctx.fillStyle = `rgba(${col[0]},${col[1]},${col[2]}, ${userOpacity})`;
                    const x = random() * w;
                    const y = random() * h;
                    const s = (random() * 20 + 5) * scale;
                    
                    if(random() > 0.5) {
                        ctx.beginPath(); ctx.arc(x, y, s, 0, 2*Math.PI); ctx.fill();
                    } else {
                        ctx.save(); ctx.translate(x,y); ctx.rotate(random());
                        ctx.fillRect(-s/2, -s/2, s, s); ctx.restore();
                    }
                }
            }
        }

        // --- Layout Logic ---
        function createPatternCanvas(targetPxWidth, targetPxHeight, borderPx, tileWidth, tileHeight, mode, elements, slices, seed, isPersian) {
             const prng = new PRNG(seed);
             
             const bgDensityInput = parseInt(document.getElementById('bgDensitySlider').value);
             const bgOpacityInput = parseFloat(document.getElementById('bgOpacitySlider').value);
             const bgDensityFactor = bgDensityInput / 100; 
             
             const canvas = document.createElement('canvas');
             canvas.width = targetPxWidth;
             canvas.height = targetPxHeight;
             const ctx = canvas.getContext('2d');
             
             // 1. –ó–∞–ª–∏–≤–∫–∞ —Ñ–æ–Ω–∞
             ctx.fillStyle = `rgba(${backgroundColor.join(',')})`;
             ctx.fillRect(0, 0, targetPxWidth, targetPxHeight);
             
             const effectiveBorder = isPersian ? borderPx * 1.5 : borderPx;
             // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ü–≤–µ—Ç –æ–±–≤–æ–¥–∫–∏ –¥–ª—è –ü–µ—Ä—Å–∏–¥—Å–∫–æ–≥–æ —Å—Ç–∏–ª—è (–±–µ—Ä–µ–º –≤—Ç–æ—Ä–æ–π –∏–ª–∏ –ø–µ—Ä–≤—ã–π —Ü–≤–µ—Ç –ø–∞–ª–∏—Ç—Ä—ã)
             const outlineColor = Object.values(palette)[1] || [255,215,0,1];
             const outlineRgba = `rgba(${outlineColor.join(',')})`;

             // 2. –†–∞—Å—á–µ—Ç –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏
             let innerW = targetPxWidth - 2 * effectiveBorder;
             let innerH = targetPxHeight - 2 * effectiveBorder;
             
             // === –õ–û–ì–ò–ö–ê –ü–†–Ø–ú–û–£–ì–û–õ–¨–ù–û–°–¢–ò ===
             let topBottomPadding = 0;
             if (tileWidth === tileHeight || Math.abs(tileWidth - tileHeight) < 1) {
                 topBottomPadding = targetPxHeight * 0.15;
                 innerH -= (topBottomPadding * 2);
             }

             // 3. –§–æ–Ω–æ–≤—ã–π —É–∑–æ—Ä (–ü–æ–ª–µ)
             drawBackgroundDecorations(ctx, targetPxWidth, targetPxHeight, palette, prng, mode, 1, bgDensityFactor, bgOpacityInput);
             
             // –ï—Å–ª–∏ –ø–µ—Ä—Å–∏–¥—Å–∫–∏–π, –¥–µ–ª–∞–µ–º –ø–æ–ª–µ –±–æ–ª–µ–µ "–∫–æ–≤—Ä–æ–≤—ã–º" - –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–π—Å—è –º–µ–ª–∫–∏–π –ø–∞—Ç—Ç–µ—Ä–Ω
             if(isPersian) {
                 const tilePx = Math.min(innerW/tileWidth, innerH/tileHeight) / 2; // –ú–µ–ª—å—á–µ –ø–∞—Ç—Ç–µ—Ä–Ω
                 const gen = new KaleidoGenerator(tilePx, palette, mode, slices, elements, slices, prng, isPersian);
                 const tileCanvas = document.createElement('canvas');
                 gen.generateTile(tileCanvas);
                 
                 const startX = effectiveBorder;
                 const startY = effectiveBorder + topBottomPadding;
                 
                 // –ó–∞–ø–æ–ª–Ω—è–µ–º –≤—Å–µ –ø–æ–ª–µ –º–µ–ª–∫–∏–º –ø–∞—Ç—Ç–µ—Ä–Ω–æ–º
                 for(let y = startY; y < startY + innerH; y+=tilePx) {
                     for(let x = startX; x < startX + innerW; x+=tilePx) {
                          // Clip to make sure we don't draw over border
                          if(x + tilePx <= startX + innerW && y + tilePx <= startY + innerH)
                             ctx.drawImage(tileCanvas, x, y, tilePx, tilePx);
                     }
                 }

                 // 4. –£–≥–æ–ª–∫–∏ (Spandrels) - –ö–ª–∞—Å—Å–∏–∫–∞ –ü–µ—Ä—Å–∏–∏ –° –û–ë–í–û–î–ö–û–ô
                 const cornerSize = Math.min(innerW, innerH) * 0.4;
                 const cornerGen = new KaleidoGenerator(cornerSize * 2, palette, 'Shapes', slices*1.5, elements, slices, prng, true);
                 const cornerCanvas = document.createElement('canvas');
                 cornerGen.generateTile(cornerCanvas);
                 
                 // Helper to draw corner with background and stroke
                 const drawCorner = (x, y, w, h, drawX, drawY) => {
                     ctx.save();
                     ctx.beginPath(); 
                     ctx.rect(x, y, w, h); 
                     
                     // Background for contrast
                     ctx.fillStyle = `rgba(${backgroundColor.join(',')})`;
                     ctx.fill();

                     ctx.clip();
                     ctx.drawImage(cornerCanvas, drawX, drawY);
                     ctx.restore();

                     // Stroke (Outline)
                     ctx.lineWidth = borderPx * 0.3;
                     ctx.strokeStyle = outlineRgba;
                     ctx.strokeRect(x, y, w, h);
                 };

                 // Top Left
                 drawCorner(effectiveBorder, effectiveBorder + topBottomPadding, cornerSize, cornerSize, effectiveBorder - cornerSize, effectiveBorder + topBottomPadding - cornerSize);
                 // Top Right
                 drawCorner(targetPxWidth - effectiveBorder - cornerSize, effectiveBorder + topBottomPadding, cornerSize, cornerSize, targetPxWidth - effectiveBorder - cornerSize, effectiveBorder + topBottomPadding - cornerSize);
                 // Bottom Left
                 drawCorner(effectiveBorder, targetPxHeight - effectiveBorder - topBottomPadding - cornerSize, cornerSize, cornerSize, effectiveBorder - cornerSize, targetPxHeight - effectiveBorder - topBottomPadding - cornerSize);
                 // Bottom Right
                 drawCorner(targetPxWidth - effectiveBorder - cornerSize, targetPxHeight - effectiveBorder - topBottomPadding - cornerSize, cornerSize, cornerSize, targetPxWidth - effectiveBorder - cornerSize, targetPxHeight - effectiveBorder - topBottomPadding - cornerSize);

             } else {
                 // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —Ä–µ–∂–∏–º (–¢–∞–π–ª—ã)
                 const tilePx = Math.min(innerW / tileWidth, innerH / tileHeight);
                 const gen = new KaleidoGenerator(tilePx * 0.98, palette, mode, slices, elements, slices, prng, false);
                 const tileCanvas = document.createElement('canvas');
                 gen.generateTile(tileCanvas); 

                 const startX = effectiveBorder + (innerW - tileWidth * tilePx) / 2;
                 const startY = effectiveBorder + topBottomPadding + (innerH - tileHeight * tilePx) / 2;

                 for(let tx=0; tx < tileWidth; tx++) {
                     for(let ty=0; ty < tileHeight; ty++) {
                         ctx.drawImage(tileCanvas, startX + tx*tilePx, startY + ty*tilePx);
                     }
                 }
             }

             // 5. –ü–µ—Ä—Å–∏–¥—Å–∫–∏–π –ú–µ–¥–∞–ª—å–æ–Ω (–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç) –° –û–ë–í–û–î–ö–û–ô
             if (isPersian) {
                 const medallionSize = Math.min(innerW, innerH) * 0.5;
                 const centerX = targetPxWidth / 2;
                 const centerY = targetPxHeight / 2;
                 
                 // –†–∏—Å—É–µ–º –ü–û–î–õ–û–ñ–ö–£
                 ctx.fillStyle = `rgba(${backgroundColor.join(',')})`; 
                 ctx.shadowColor = "rgba(0,0,0,0.5)";
                 ctx.shadowBlur = 30;
                 ctx.beginPath();
                 // –†–æ–º–±–æ–≤–∏–¥–Ω–∞—è –ø–æ–¥–ª–æ–∂–∫–∞
                 ctx.moveTo(centerX, centerY - medallionSize/1.8);
                 ctx.lineTo(centerX + medallionSize/1.8, centerY);
                 ctx.lineTo(centerX, centerY + medallionSize/1.8);
                 ctx.lineTo(centerX - medallionSize/1.8, centerY);
                 ctx.closePath();
                 ctx.fill();
                 ctx.shadowBlur = 0;

                 // –û–ë–í–û–î–ö–ê –ü–û–î–õ–û–ñ–ö–ò
                 ctx.lineWidth = borderPx * 0.5;
                 ctx.strokeStyle = outlineRgba;
                 ctx.stroke();

                 // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∞–º–æ–≥–æ –º–µ–¥–∞–ª—å–æ–Ω–∞
                 const medGen = new KaleidoGenerator(medallionSize, palette, 'Shapes', slices*2, elements*0.8, slices*2, prng, true);
                 const medCanvas = document.createElement('canvas');
                 medGen.generateTile(medCanvas);
                 
                 ctx.drawImage(medCanvas, centerX - medallionSize/2, centerY - medallionSize/2);
             }

             // 6. –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ë–∞—Ö—Ä–æ–º—ã/–•–µ–¥–µ—Ä–∞
             if (topBottomPadding > 0) {
                 const mainBorderColor = Object.values(palette)[0] || [0,0,0,1];
                 const secondaryColor = Object.values(palette)[1] || mainBorderColor;
                 ctx.fillStyle = `rgba(${secondaryColor[0]}, ${secondaryColor[1]}, ${secondaryColor[2]}, 0.2)`;
                 ctx.fillRect(effectiveBorder, effectiveBorder, targetPxWidth - 2*effectiveBorder, topBottomPadding);
                 ctx.fillRect(effectiveBorder, targetPxHeight - effectiveBorder - topBottomPadding, targetPxWidth - 2*effectiveBorder, topBottomPadding);
                 
                 ctx.strokeStyle = `rgba(${mainBorderColor.join(',')})`;
                 ctx.lineWidth = 2;
                 const lineStep = 10;
                 for(let x = effectiveBorder; x < targetPxWidth - effectiveBorder; x += lineStep) {
                     ctx.beginPath(); ctx.moveTo(x, effectiveBorder); ctx.lineTo(x, effectiveBorder + topBottomPadding); ctx.stroke();
                 }
                 for(let x = effectiveBorder; x < targetPxWidth - effectiveBorder; x += lineStep) {
                     ctx.beginPath(); ctx.moveTo(x, targetPxHeight - effectiveBorder - topBottomPadding); ctx.lineTo(x, targetPxHeight - effectiveBorder); ctx.stroke();
                 }
             }

             // 7. –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –°–ª–æ–∂–Ω–æ–≥–æ –ë–æ—Ä–¥—é—Ä–∞
             drawComplexBorder(ctx, targetPxWidth, targetPxHeight, effectiveBorder, palette, prng, isPersian);

             // 8. –§–∏–Ω–∞–ª—å–Ω–∞—è —Ç–µ–∫—Å—Ç—É—Ä–∞
             applyRugTexture(ctx, targetPxWidth, targetPxHeight, targetPxWidth/1000);

             return canvas;
        }

        /* --- UI Functions --- */

        function updatePaletteUI() {
            const container = document.getElementById('paletteContainer');
            container.innerHTML = '';
            Object.entries(palette).forEach(([key, color], idx) => {
                const btn = document.createElement('button');
                btn.className = 'color-swatch w-8 h-8 rounded-full border-2 border-slate-500 shadow-sm focus:outline-none focus:ring-2 focus:ring-yellow-400';
                btn.style.backgroundColor = `rgba(${color.join(',')})`;
                btn.onclick = () => openColorPicker(key);
                container.appendChild(btn);
            });
        }

        function openColorPicker(key) {
            const color = palette[key];
            const hex = `#${((1 << 24) + (color[0] << 16) + (color[1] << 8) + color[2]).toString(16).slice(1)}`;
            
            const input = document.createElement('input');
            input.type = 'color';
            input.value = hex;
            input.click();
            input.onchange = (e) => {
                const bigint = parseInt(e.target.value.slice(1), 16);
                palette[key] = [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255, color[3]];
                updatePaletteUI();
            };
        }

        function generate() {
            document.getElementById('loadingOverlay').classList.remove('hidden');
            document.getElementById('emptyState').classList.add('hidden');
            document.getElementById('loadingOverlay').style.display = 'flex';

            setTimeout(() => {
                const modeCombo = document.getElementById('modeCombo');
                const modeValue = modeCombo.value;
                const map = { '–õ–∏–Ω–∏–∏':'Lines', '–¢–æ—á–∫–∏':'Dots', '–§–∏–≥—É—Ä—ã':'Shapes', '–°–º–µ—à–∞–Ω–Ω—ã–π':'Mixed', '–°–ø–∏—Ä–∞–ª—å':'Spiral', '–û—Ä–±–∏—Ç—ã':'Orbit', '–¢–æ—á–∫–∏ –≤ –§–∏–≥—É—Ä—ã':'DotToShape', '–¢–æ—á–∫–∏ –≤ –°–º–µ—à–∞–Ω–Ω—ã–π':'DotsToMixed', '–ö–æ–≤–µ—Ä':'Carpet', '–û—Ä–≥–∞–Ω–∏—á–µ—Å–∫–∏–π':'Organic'};
                const modeKey = map[modeValue] || 'Mixed';

                const elements = parseInt(document.getElementById('elementSlider').value);
                const slices = parseInt(document.getElementById('slicesSlider').value);
                const tileW = parseInt(document.getElementById('tileWidthSlider').value);
                const tileH = parseInt(document.getElementById('tileHeightSlider').value);
                
                const isPersian = document.getElementById('persianMode').checked;

                currentSeed = Math.random() * 1e9 | 0;
                
                // –†–∞–∑–º–µ—Ä—ã –ø—Ä–µ–≤—å—é
                const targetW = PREVIEW_TILE_PX * tileW + 2 * PREVIEW_BORDER_PX;
                let targetH = PREVIEW_TILE_PX * tileH + 2 * PREVIEW_BORDER_PX;
                
                if (tileW === tileH) {
                     targetH += (targetH * 0.3); 
                }

                const finalCanvas = createPatternCanvas(targetW, targetH, PREVIEW_BORDER_PX, tileW, tileH, modeKey, elements, slices, currentSeed, isPersian);
                
                const preview = document.getElementById('previewCanvas');
                preview.width = targetW;
                preview.height = targetH;
                const pCtx = preview.getContext('2d');
                pCtx.drawImage(finalCanvas, 0, 0);
                
                currentImage = finalCanvas;
                
                document.getElementById('loadingOverlay').classList.add('hidden');
                document.getElementById('loadingOverlay').style.display = 'none';
            }, 50);
        }

        document.getElementById('generateBtn').addEventListener('click', generate);
        
        document.getElementById('saveBtn').addEventListener('click', () => {
            if(!currentImage) return alert('–°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ —É–∑–æ—Ä');
            const link = document.createElement('a');
            link.download = 'Royal_Rug_' + Date.now() + '.png';
            link.href = currentImage.toDataURL();
            link.click();
        });

        document.getElementById('viewBtn').addEventListener('click', () => {
            if(!currentImage) return alert('–°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ —É–∑–æ—Ä');
            const fullC = document.getElementById('fullCanvas');
            fullC.width = currentImage.width;
            fullC.height = currentImage.height;
            fullC.getContext('2d').drawImage(currentImage, 0, 0);
            document.getElementById('imageModal').classList.remove('hidden');
        });

        document.getElementById('closeModalBtn').addEventListener('click', () => {
            document.getElementById('imageModal').classList.add('hidden');
        });
        
        document.getElementById('addColorBtn').addEventListener('click', () => {
            const nextIdx = Object.keys(palette).length + 1;
            if(nextIdx > 20) return;
            palette[nextIdx.toString()] = AVAILABLE_COLORS[Math.floor(Math.random()*AVAILABLE_COLORS.length)];
            updatePaletteUI();
        });
        
        document.getElementById('removeColorBtn').addEventListener('click', () => {
             const keys = Object.keys(palette);
             if(keys.length > 1) {
                 delete palette[keys[keys.length-1]];
                 updatePaletteUI();
             }
        });
        
        document.getElementById('changeBackgroundColorBtn').addEventListener('click', () => {
             const input = document.createElement('input');
             input.type = 'color';
             input.click();
             input.onchange = (e) => {
                const bigint = parseInt(e.target.value.slice(1), 16);
                backgroundColor = [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255, 1];
             };
        });

        document.getElementById('savePdfBtn').addEventListener('click', () => document.getElementById('pdfModal').classList.remove('hidden'));
        document.getElementById('closePdfModalBtn').addEventListener('click', () => document.getElementById('pdfModal').classList.add('hidden'));

        document.getElementById('paperSize').addEventListener('change', (e) => {
             document.getElementById('customSizeDiv').classList.toggle('hidden', e.target.value !== 'custom');
        });

        document.getElementById('generatePdfBtn').addEventListener('click', () => {
             if(!currentImage) return;
             const { jsPDF } = window.jspdf;
             const doc = new jsPDF({ orientation: currentImage.width > currentImage.height ? 'l' : 'p'});
             
             // PDF Fit-to-Page Logic (Ignore Aspect Ratio Stretch)
             const pdfWidth = doc.internal.pageSize.getWidth();
             const pdfHeight = doc.internal.pageSize.getHeight();
             
             doc.addImage(currentImage.toDataURL(), 'PNG', 0, 0, pdfWidth, pdfHeight);
             doc.save('Royal_Rug.pdf');
             document.getElementById('pdfModal').classList.add('hidden');
        });

        document.getElementById('homeBtn').addEventListener('click', () => window.location.href = 'main.html');

        ['element', 'slices', 'tileWidth', 'tileHeight'].forEach(id => {
            document.getElementById(id+'Slider').addEventListener('input', (e) => {
                document.getElementById(id+'Value').innerText = e.target.value;
            });
        });

        document.getElementById('bgDensitySlider').addEventListener('input', (e) => {
            document.getElementById('bgDensityValue').innerText = e.target.value + '%';
        });
        document.getElementById('bgOpacitySlider').addEventListener('input', (e) => {
            document.getElementById('bgOpacityValue').innerText = e.target.value;
        });

        updatePaletteUI();
    </script>
</body>
</html>
