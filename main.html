<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор калейдоскопов</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background: linear-gradient(135deg, #6b7280, #4c1d95);
            min-height: 100vh;
        }
        canvas {
            background-color: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
        }
        .color-btn {
            width: 100%;
            height: 36px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            transition: transform 0.2s;
        }
        .color-btn:hover {
            transform: scale(1.05);
        }
        .delete-btn {
            background: #e74c3c;
            color: white;
            padding: 6px;
            border-radius: 6px;
            font-size: 12px;
            transition: background 0.3s;
        }
        .delete-btn:hover {
            background: #c0392b;
        }
        #previewCanvas {
            max-width: 300px;
            width: 100%;
            aspect-ratio: 1/1;
        }
        #fullCanvas {
            max-width: 800px;
            width: 100%;
            aspect-ratio: 1/1;
        }
        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        }
        .custom-range::-webkit-slider-thumb {
            background: #7c3aed;
        }
        .custom-range::-moz-range-thumb {
            background: #7c3aed;
        }
        #imageModal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 50;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        #imageModal.show {
            display: flex;
        }
        details summary {
            cursor: pointer;
            font-size: 1.25rem;
            font-weight: 600;
            color: #4c1d95;
            padding: 0.5rem;
        }
        details summary:hover {
            color: #7c3aed;
        }
        details p {
            margin-top: 0.5rem;
            color: #374151;
        }
        #animateBtn, #recordBtn {
            background: linear-gradient(45deg, #7c3aed, #4c1d95);
            color: white;
            transition: transform 0.3s, background 0.3s;
        }
        #animateBtn:hover, #recordBtn:hover {
            transform: scale(1.05);
            background: linear-gradient(45deg, #9f67ff, #6b46c1);
        }
        #animateBtn.active, #recordBtn.active {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.75rem;
        }
        .action-buttons button {
            flex: 1;
            padding: 0.75rem;
            font-size: 0.9rem;
        }
    </style>
</head>
<body class="font-sans text-gray-900">
    <div class="container mx-auto p-4 sm:p-6 md:p-8 max-w-7xl">
        <details class="card p-4 rounded-xl shadow-lg mb-6">
            <summary>Инструкции</summary>
            <p>Добро пожаловать в Генератор калейдоскопов! Следуйте этим шагам:</p>
            <ul class="list-disc pl-5 mt-2">
                <li><strong>Выбор узора:</strong> Выберите тип узора (Линии, Точки, Фигуры, Смешанный, Спираль, Орбиты, Точки в Фигуры, Точки в Смешанный).</li>
                <li><strong>Настройка параметров:</strong> Регулируйте количество элементов (100–1000), секторов (3–40) и скорость анимации (0.05–0.5).</li>
                <li><strong>Палитра:</strong> Добавляйте до 20 цветов, удаляйте или изменяйте их.</li>
                <li><strong>Генерация:</strong> Нажмите "Сгенерировать" для создания узора.</li>
                <li><strong>Анимация:</strong> Нажмите "Анимировать" для запуска плавной анимации. Повторное нажатие останавливает.</li>
                <li><strong>Запись видео:</strong> Нажмите "Старт/Стоп запись" для записи анимации. Нажмите "Скачать видео" для сохранения в WebM.</li>
                <li><strong>Просмотр:</strong> Нажмите "Открыть полное изображение" для просмотра анимированного узора.</li>
                <li><strong>Сохранение:</strong> Нажмите "Сохранить изображение" для скачивания PNG (статичное изображение).</li>
                <li><strong>Возврат:</strong> Нажмите "← Вернуться" для возврата на главную.</li>
            </ul>
        </details>
        <h1 class="text-3xl sm:text-4xl font-extrabold text-center text-white mb-8 drop-shadow-lg">Генератор калейдоскопов</h1>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <div class="space-y-6">
                <div class="card p-6 rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 text-indigo-700">Настройки узора</h2>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium mb-1 text-gray-700">Тип узора</label>
                            <select id="modeCombo" class="w-full p-3 border border-gray-300 rounded-lg bg-white focus:ring-2 focus:ring-indigo-500" title="Выберите тип узора">
                                <option>Линии</option>
                                <option>Точки</option>
                                <option>Фигуры</option>
                                <option>Смешанный</option>
                                <option>Спираль</option>
                                <option>Орбиты</option>
                                <option>Точки в Фигуры</option>
                                <option>Точки в Смешанный</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-1 text-gray-700">Количество элементов: <span id="elementValue" class="font-bold">300</span></label>
                            <input type="range" id="elementSlider" min="100" max="1000" value="300" class="w-full custom-range" title="Количество элементов">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-1 text-gray-700">Количество секторов: <span id="slicesValue" class="font-bold">13</span></label>
                            <input type="range" id="slicesSlider" min="3" max="40" value="13" class="w-full custom-range" title="Количество секторов">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-1 text-gray-700">Скорость анимации: <span id="animationSpeedValue" class="font-bold">0.1</span></label>
                            <input type="range" id="animationSpeedSlider" min="0.05" max="0.5" step="0.01" value="0.1" class="w-full custom-range" title="Скорость анимации">
                        </div>
                    </div>
                </div>
                <div class="card p-6 rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 text-indigo-700">Палитра цветов</h2>
                    <div class="overflow-x-auto">
                        <table id="paletteTable" class="w-full border-collapse mb-4">
                            <thead>
                                <tr>
                                    <th class="border-b-2 p-3 text-left text-gray-700 w-16">Ключ</th>
                                    <th class="border-b-2 p-3 text-left text-gray-700">Цвет</th>
                                    <th class="border-b-2 p-3 text-left text-gray-700 w-24">Действие</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-3">
                        <button id="addColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 transition-colors" title="Добавить цвет">Добавить цвет</button>
                        <button id="removeColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 transition-colors" title="Удалить последний цвет">Удалить последний</button>
                    </div>
                </div>
            </div>
            <div class="space-y-6">
                <div class="card p-6 rounded-xl shadow-lg flex justify-center items-center">
                    <div>
                        <h2 class="text-xl font-semibold mb-4 text-indigo-700 text-center">Предпросмотр</h2>
                        <canvas id="previewCanvas" class="mx-auto"></canvas>
                    </div>
                </div>
                <div class="card p-6 rounded-xl shadow-lg">
                    <div class="action-buttons">
                        <button id="generateBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="Создать узор">Сгенерировать</button>
                        <button id="animateBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="Запустить/остановить анимацию">Анимировать</button>
                        <button id="recordBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="Начать/остановить запись видео">Старт запись</button>
                        <button id="downloadVideoBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="Скачать записанное видео" disabled>Скачать видео</button>
                        <button id="viewBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="Открыть узор">Открыть полное изображение</button>
                        <button id="saveBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="Сохранить узор">Сохранить изображение</button>
                    </div>
                </div>
            </div>
        </div>
        <button id="home" class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 transition-colors" style="margin-top: 20px;" title="Вернуться">← Вернуться</button>
        <div id="imageModal" class="fixed inset-0 bg-black bg-opacity-70 hidden flex items-center justify-center p-4 z-50">
            <div class="bg-white p-6 rounded-xl max-w-[90vw] max-h-[90vh] overflow-auto">
                <canvas id="fullCanvas" class="mx-auto"></canvas>
                <div class="text-center mt-4">
                    <button id="closeModalBtn" class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 transition-colors" title="Закрыть">Закрыть</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const DPI = 300;
        const CM_TO_INCH = 1 / 2.54;
        const MAIN_CM = 15;
        const MAIN_PX = Math.round(MAIN_CM * CM_TO_INCH * DPI);
        const CANVAS_PX = MAIN_PX;
        let ANIMATION_SPEED = 0.1;

        const DEFAULT_PALETTE = {
            '1': [245, 245, 220, 1],
            '2': [0, 0, 0, 1],
            '3': [255, 255, 0, 1],
            '4': [255, 0, 255, 1]
        };

        const AVAILABLE_COLORS = [
            [245, 245, 220, 1],
            [255, 255, 0, 1],
            [0, 0, 0, 1],
            [255, 0, 255, 1],
            [144, 238, 144, 1]
        ];

        let colorIndex = 0;

        class KaleidoGenerator {
            constructor(size_px, palette, mode = 'Lines', sectors = 12, elements = 300, slices = 13) {
                this.size = size_px;
                this.palette = Object.values(palette);
                this.mode = mode;
                this.sectors = sectors;
                this.elements = Math.min(elements, 500);
                this.slices = slices;
                this.branch_settings = {
                    size: 150,
                    angle: 0.4,
                    scale: 0.67,
                    iterations: Math.max(1, Math.floor(elements / 100)),
                    offset: 0,
                    spiral_density: 0.05,
                };
                this.elementsData = [];
                this.initElements();
            }

            initElements() {
                this.elementsData = [];
                const angle = 360 / this.sectors;
                if (this.mode === 'Lines') {
                    for (let i = 0; i < this.elements; i++) {
                        this.elementsData.push({
                            r1: Math.random(),
                            theta1: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            r2: Math.random(),
                            theta2: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * this.palette.length),
                            lineWidth: Math.floor(Math.random() * 4) + 1
                        });
                    }
                } else if (this.mode === 'Dots') {
                    for (let i = 0; i < this.elements; i++) {
                        this.elementsData.push({
                            r: Math.random(),
                            theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * this.palette.length),
                            size_dot: Math.random() * 6 + 2
                        });
                    }
                } else if (this.mode === 'Shapes') {
                    for (let i = 0; i < this.elements; i++) {
                        this.elementsData.push({
                            r: Math.random(),
                            theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * this.palette.length),
                            size_sq: Math.random() * 15 + 5
                        });
                    }
                } else if (this.mode === 'Mixed') {
                    for (let i = 0; i < this.elements; i++) {
                        const type = ['Lines', 'Dots', 'Shapes'][Math.floor(Math.random() * 3)];
                        if (type === 'Lines') {
                            this.elementsData.push({
                                type: 'Lines',
                                r1: Math.random(),
                                theta1: (Math.random() * angle - angle / 2) * Math.PI / 180,
                                r2: Math.random(),
                                theta2: (Math.random() * angle - angle / 2) * Math.PI / 180,
                                colorIdx: Math.floor(Math.random() * this.palette.length),
                                lineWidth: Math.floor(Math.random() * 4) + 1
                            });
                        } else if (type === 'Dots') {
                            this.elementsData.push({
                                type: 'Dots',
                                r: Math.random(),
                                theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                                colorIdx: Math.floor(Math.random() * this.palette.length),
                                size_dot: Math.random() * 6 + 2
                            });
                        } else {
                            this.elementsData.push({
                                type: 'Shapes',
                                r: Math.random(),
                                theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                                colorIdx: Math.floor(Math.random() * this.palette.length),
                                size_sq: Math.random() * 15 + 5
                            });
                        }
                    }
                } else if (this.mode === 'Spiral') {
                    const spiral_count = Math.floor(this.elements / 10);
                    for (let i = 0; i < spiral_count; i++) {
                        this.elementsData.push({
                            theta_start: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            color_idx: Math.floor(Math.random() * this.palette.length)
                        });
                    }
                } else if (this.mode === 'Orbit') {
                    const diameter = this.size;
                    const a = 0.266746, b = 0.321596, c = 0.223138;
                    this.elementsData = [
                        { class: 'a', width: diameter * a, top: (diameter/2 - (diameter*a/2)) * 0.60, left: diameter/2 - (diameter*a/2), blink: 'blink-lightest', speed: 5*a, delay: 2*a },
                        { class: 'a', width: diameter * a, top: (diameter/2 - (diameter*a/2)) * 1.22, left: (diameter/2 - (diameter*a/2)) * 0.65, blink: 'blink-lightest', speed: 5*a, delay: 1*a },
                        { class: 'a', width: diameter * a, top: (diameter/2 - (diameter*a/2)) * 1.22, right: (diameter/2 - (diameter*a/2)) * 0.65, blink: 'blink-lightest', speed: 5*a, delay: 1*a },
                        { class: 'b', width: diameter * b, top: (diameter/2 - (diameter*b/2)) * 0.52, left: diameter*b/7, blink: 'blink-lightest', speed: 5*b, delay: 1*b },
                        { class: 'b', width: diameter * b, top: (diameter/2 - (diameter*b/2)) * 0.52, right: diameter*b/7, blink: 'blink-lightest', speed: 5*b, delay: 1*b },
                        { class: 'b', width: diameter * b, bottom: 0, left: diameter/2 - (diameter*b/2), blink: 'blink', speed: 5*b, delay: 2*b },
                        { class: 'c', width: diameter * c, top: diameter*c/15, left: diameter*c * 1.23, blink: 'blink-lightest', speed: 6*c, delay: 3*c },
                        { class: 'c', width: diameter * c, top: diameter*c/15, right: diameter*c * 1.23, blink: 'blink-lightest', speed: 6*c, delay: 2*c },
                        { class: 'c', width: diameter * c, bottom: diameter*c/2.3, left: diameter*c * 0.55, blink: 'blink-lightest', speed: 6*c, delay: 4*c },
                        { class: 'c', width: diameter * c, bottom: diameter*c * 1.3, left: diameter*c * 0.05, blink: 'blink-lightest', speed: 6*c, delay: 3*c },
                        { class: 'c', width: diameter * c, bottom: diameter*c/2.3, right: diameter*c * 0.55, blink: 'blink-lightest', speed: 6*c, delay: 2*c },
                        { class: 'c', width: diameter * c, bottom: diameter*c * 1.3, right: diameter*c * 0.05, blink: 'blink-lightest', speed: 6*c, delay: 3*c },
                        { class: 'center', width: diameter * a, top: diameter/2 - (diameter*a/2), left: diameter/2 - (diameter*a/2), blink: 'blink', speed: 3, delay: 0 },
                        { class: 'tile-cover', width: diameter, top: 0, left: 0, blink: 'blink', speed: 3, delay: 1 },
                        { class: 'tile-back', width: diameter, top: 0, left: 0, blink: 'blink', speed: 5, delay: 2 },
                    ];
                } else if (this.mode === 'DotToShape') {
                    for (let i = 0; i < this.elements; i++) {
                        this.elementsData.push({
                            r: Math.random(),
                            theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * this.palette.length),
                            size_dot: Math.random() * 6 + 2,
                            size_sq: Math.random() * 15 + 5
                        });
                    }
                } else if (this.mode === 'DotsToMixed') {
                    for (let i = 0; i < this.elements; i++) {
                        const type = ['Lines', 'Dots', 'Shapes'][Math.floor(Math.random() * 3)];
                        this.elementsData.push({
                            r: Math.random(),
                            theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * this.palette.length),
                            size_dot: Math.random() * 6 + 2,
                            type: type,
                            r1: type === 'Lines' ? Math.random() : null,
                            theta1: type === 'Lines' ? (Math.random() * angle - angle / 2) * Math.PI / 180 : null,
                            r2: type === 'Lines' ? Math.random() : null,
                            theta2: type === 'Lines' ? (Math.random() * angle - angle / 2) * Math.PI / 180 : null,
                            lineWidth: type === 'Lines' ? Math.floor(Math.random() * 4) + 1 : null,
                            size_sq: type === 'Shapes' ? Math.random() * 15 + 5 : null
                        });
                    }
                }
            }

            generate(canvas, animate = false, animationTime = 0) {
                const ctx = canvas.getContext('2d');
                canvas.width = this.size;
                canvas.height = this.size;
                const gradient = ctx.createLinearGradient(0, 0, this.size, this.size);
                const hue = animate ? (Math.sin(animationTime * 0.3) * 30 + 270) % 360 : 270;
                gradient.addColorStop(0, `hsl(${hue}, 50%, 95%)`);
                gradient.addColorStop(1, `hsl(${(hue + 30) % 360}, 50%, 85%)`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.size, this.size);
                ctx.globalAlpha = animate ? 0.9 : 1.0;
                const main = this._makeKaleidoSquare(animate, animationTime);
                ctx.drawImage(main, 0, 0);
                ctx.globalAlpha = 1.0;
            }

            _interpolateColor(color1, color2, factor) {
                return [
                    Math.round(color1[0] * (1 - factor) + color2[0] * factor),
                    Math.round(color1[1] * (1 - factor) + color2[1] * factor),
                    Math.round(color1[2] * (1 - factor) + color2[2] * factor),
                    color1[3] * (1 - factor) + color2[3] * factor
                ];
            }

            _makeTrianglifyPattern(width, height, t) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                const cell_size = 50;
                for (let i = 0; i < width; i += cell_size) {
                    for (let j = 0; j < height; j += cell_size) {
                        const points = [
                            [i, j],
                            [i + cell_size, j],
                            [i + cell_size, j + cell_size],
                            [i, j + cell_size],
                        ];
                        const color1 = this.palette[Math.floor(Math.random() * this.palette.length)];
                        const color2 = this.palette[Math.floor(Math.random() * this.palette.length)];
                        const factor = t ? (Math.sin(t + i * 0.1 + j * 0.1) + 1) / 2 : 0;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color1, color2, factor).join(',')})`;
                        ctx.beginPath();
                        ctx.moveTo(points[0][0], points[0][1]);
                        ctx.lineTo(points[1][0], points[1][1]);
                        ctx.lineTo(points[2][0], points[2][1]);
                        ctx.fill();
                        ctx.fillStyle = `rgba(${this._interpolateColor(color2, color1, factor).join(',')})`;
                        ctx.beginPath();
                        ctx.moveTo(points[0][0], points[0][1]);
                        ctx.lineTo(points[2][0], points[2][1]);
                        ctx.lineTo(points[3][0], points[3][1]);
                        ctx.fill();
                    }
                }
                return canvas;
            }

            _makeKaleidoSquare(animate, animationTime) {
                const canvas = document.createElement('canvas');
                canvas.width = this.size;
                canvas.height = this.size;
                const ctx = canvas.getContext('2d');
                const radius = this.size / 2;
                const angle = 360 / this.sectors;
                const cx = radius, cy = radius;

                const t = animate ? animationTime * ANIMATION_SPEED : 0;
                const rotationOffset = Math.sin(t) * 0.4;

                if (this.mode === 'Lines') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.strokeStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        const x1 = cx + data.r1 * radius * Math.cos(data.theta1 + thetaOffset);
                        const y1 = cy + data.r1 * radius * Math.sin(data.theta1 + thetaOffset);
                        const x2 = cx + data.r2 * radius * Math.cos(data.theta2 + thetaOffset);
                        const y2 = cy + data.r2 * radius * Math.sin(data.theta2 + thetaOffset);
                        ctx.lineWidth = data.lineWidth * (1 + Math.sin(t + i * 0.3) * 0.8);
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                } else if (this.mode === 'Dots') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                        const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                        const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                        ctx.beginPath();
                        ctx.arc(x, y, size_dot, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                } else if (this.mode === 'Shapes') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                        const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                        const size_sq = data.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8);
                        ctx.fillRect(x - size_sq, y - size_sq, size_sq * 2, size_sq * 2);
                    }
                } else if (this.mode === 'Mixed') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        ctx.strokeStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        if (data.type === 'Lines') {
                            const x1 = cx + data.r1 * radius * Math.cos(data.theta1 + thetaOffset);
                            const y1 = cy + data.r1 * radius * Math.sin(data.theta1 + thetaOffset);
                            const x2 = cx + data.r2 * radius * Math.cos(data.theta2 + thetaOffset);
                            const y2 = cy + data.r2 * radius * Math.sin(data.theta2 + thetaOffset);
                            ctx.lineWidth = data.lineWidth * (1 + Math.sin(t + i * 0.3) * 0.8);
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        } else if (data.type === 'Dots') {
                            const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                            const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                            const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                            ctx.beginPath();
                            ctx.arc(x, y, size_dot, 0, 2 * Math.PI);
                            ctx.fill();
                        } else {
                            const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                            const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                            const size_sq = data.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8);
                            ctx.fillRect(x - size_sq, y - size_sq, size_sq * 2, size_sq * 2);
                        }
                    }
                } else if (this.mode === 'Spiral') {
                    const s = this.branch_settings;
                    for (let i = 0; i < this.elementsData.length; i++) {
                        let theta_start = this.elementsData[i].theta_start + t * 0.3;
                        let color_idx = this.elementsData[i].color_idx;
                        const next_color_idx = (color_idx + 1) % this.palette.length;
                        for (let r = 0; r < radius; r += 2) {
                            const theta = theta_start + r * s.spiral_density;
                            const x = cx + r * Math.cos(theta);
                            const y = cy + r * Math.sin(theta);
                            const colorFactor = (Math.sin(t + r * 0.02) + 1) / 2;
                            const r_col = Math.round(this.palette[color_idx][0] * (1 - colorFactor) + this.palette[next_color_idx][0] * colorFactor);
                            const g_col = Math.round(this.palette[color_idx][1] * (1 - colorFactor) + this.palette[next_color_idx][1] * colorFactor);
                            const b_col = Math.round(this.palette[color_idx][2] * (1 - colorFactor) + this.palette[next_color_idx][2] * colorFactor);
                            const a_col = this.palette[color_idx][3] * (1 - colorFactor) + this.palette[next_color_idx][3] * colorFactor;
                            const width = Math.max(2, 4 + Math.sin(r * 0.03 + t) * 5);
                            ctx.fillStyle = `rgba(${r_col}, ${g_col}, ${b_col}, ${a_col})`;
                            ctx.beginPath();
                            ctx.arc(x, y, width, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    }
                } else if (this.mode === 'Orbit') {
                    const diameter = this.size;
                    for (const config of this.elementsData) {
                        const width = config.width;
                        const height = width;
                        let x = config.left !== undefined ? config.left : diameter - config.right - width;
                        let y = config.top !== undefined ? config.top : diameter - config.bottom - height;
                        x = cx + (x - diameter/2) * (1 + Math.sin(t) * 0.3);
                        y = cy + (y - diameter/2) * (1 + Math.cos(t) * 0.3);
                        const opacity = config.blink === 'blink' ? 0.5 + 0.5 * Math.sin(t / config.speed) :
                                        config.blink === 'blink-lighter' ? 0.3 + 0.2 * Math.sin(t / config.speed) :
                                        0.375 + 0.375 * Math.sin(t / config.speed);
                        const pattern = this._makeTrianglifyPattern(width, height, t);
                        ctx.globalAlpha = opacity;
                        ctx.drawImage(pattern, x, y, width, height);
                        ctx.globalAlpha = 1;
                        ctx.strokeStyle = `rgba(0, 0, 255, ${0.5 + Math.sin(t) * 0.5})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(x + width / 2, y + height / 2, width / 2, 0, 2 * Math.PI);
                        ctx.stroke();
                    }
                } else if (this.mode === 'DotToShape') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                        const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                        const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                        const size_sq = data.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8);
                        const shapeFactor = (Math.sin(t * 2) + 1) / 2;
                        const size = size_dot * (1 - shapeFactor) + size_sq * shapeFactor;
                        const cornerRadius = size * (1 - shapeFactor);
                        ctx.beginPath();
                        ctx.moveTo(x - size + cornerRadius, y - size);
                        ctx.lineTo(x + size - cornerRadius, y - size);
                        ctx.arcTo(x + size, y - size, x + size, y - size + cornerRadius, cornerRadius);
                        ctx.lineTo(x + size, y + size - cornerRadius);
                        ctx.arcTo(x + size, y + size, x + size - cornerRadius, y + size, cornerRadius);
                        ctx.lineTo(x - size + cornerRadius, y + size);
                        ctx.arcTo(x - size, y + size, x - size, y + size - cornerRadius, cornerRadius);
                        ctx.lineTo(x - size, y - size + cornerRadius);
                        ctx.arcTo(x - size, y - size, x - size + cornerRadius, y - size, cornerRadius);
                        ctx.closePath();
                        ctx.fill();
                    }
                } else if (this.mode === 'DotsToMixed') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        ctx.strokeStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                        const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                        const shapeFactor = (Math.sin(t * 2) + 1) / 2;
                        if (shapeFactor < 0.5) {
                            const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                            ctx.beginPath();
                            ctx.arc(x, y, size_dot * (1 - shapeFactor * 2), 0, 2 * Math.PI);
                            ctx.fill();
                        } else {
                            if (data.type === 'Lines') {
                                const x1 = cx + data.r1 * radius * Math.cos(data.theta1 + thetaOffset);
                                const y1 = cy + data.r1 * radius * Math.sin(data.theta1 + thetaOffset);
                                const x2 = cx + data.r2 * radius * Math.cos(data.theta2 + thetaOffset);
                                const y2 = cy + data.r2 * radius * Math.sin(data.theta2 + thetaOffset);
                                ctx.lineWidth = data.lineWidth * (1 + Math.sin(t + i * 0.3) * 0.8) * (shapeFactor * 2 - 1);
                                ctx.beginPath();
                                ctx.moveTo(x1, y1);
                                ctx.lineTo(x2, y2);
                                ctx.stroke();
                            } else if (data.type === 'Dots') {
                                const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8) * (shapeFactor * 2 - 1);
                                ctx.beginPath();
                                ctx.arc(x, y, size_dot, 0, 2 * Math.PI);
                                ctx.fill();
                            } else {
                                const size_sq = data.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8) * (shapeFactor * 2 - 1);
                                ctx.fillRect(x - size_sq, y - size_sq, size_sq * 2, size_sq * 2);
                            }
                        }
                    }
                }

                const full = document.createElement('canvas');
                full.width = this.size;
                full.height = this.size;
                const fullCtx = full.getContext('2d');
                const gradient = fullCtx.createLinearGradient(0, 0, this.size, this.size);
                const hue = animate ? (Math.sin(t * 0.3) * 30 + 270) % 360 : 270;
                gradient.addColorStop(0, `hsl(${hue}, 50%, 95%)`);
                gradient.addColorStop(1, `hsl(${(hue + 30) % 360}, 50%, 85%)`);
                fullCtx.fillStyle = gradient;
                fullCtx.fillRect(0, 0, this.size, this.size);
                for (let i = 0; i < this.sectors; i++) {
                    fullCtx.save();
                    fullCtx.translate(cx, cy);
                    fullCtx.rotate((angle * i + rotationOffset) * Math.PI / 180);
                    if (i % 2 === 1) {
                        fullCtx.scale(-1, 1);
                    }
                    fullCtx.drawImage(canvas, -cx, -cy);
                    fullCtx.restore();
                }
                return full;
            }

            _drawShape(x, y, angle, size, ctx, points, t) {
                this._drawBranch(x, y, angle, size, 1, ctx, points, t);
                this._drawBranch(x, y, angle, size, -1, ctx, points, t);
            }

            _drawBranch(x, y, angle, size, direction, ctx, points, t) {
                const s = this.branch_settings;
                const new_angle = angle + (s.angle * direction + s.offset) + Math.sin(t) * 0.3;
                const new_size = size * s.scale * (1 + Math.sin(t) * 0.2);
                const x2 = x + Math.cos(new_angle) * new_size;
                const y2 = y + Math.sin(new_angle) * new_size;
                const color = this.palette[Math.floor(Math.random() * this.palette.length)];
                const nextColor = this.palette[(Math.floor(Math.random() * this.palette.length) + 1) % this.palette.length];
                const colorFactor = (Math.sin(t) + 1) / 2;
                ctx.strokeStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                ctx.lineWidth = 2 * (1 + Math.sin(t) * 0.8);
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                points.push({ x: x2, y: y2, angle: new_angle, size: new_size });
            }
        }

        let palette = loadPalette();
        let currentImage = null;
        let isAnimating = false;
        let isFullAnimating = false;
        let isRecording = false;
        let animationFrameId = null;
        let fullAnimationFrameId = null;
        let startTime = null;
        let fullStartTime = null;
        let generator = null;
        let mediaRecorder = null;
        let recordedChunks = [];

        function loadPalette() {
            const generatedColors = localStorage.getItem('generatedColors');
            if (generatedColors) {
                try {
                    const colors = JSON.parse(generatedColors);
                    if (Array.isArray(colors) && colors.every(c => /^#[0-9A-Fa-f]{6}$/.test(c))) {
                        const newPalette = {};
                        colors.forEach((color, index) => {
                            const rgb = hexToRgb(color);
                            newPalette[(index + 1).toString()] = [...rgb, 1];
                        });
                        localStorage.setItem('palette', JSON.stringify(newPalette));
                        return newPalette;
                    }
                } catch (e) {
                    console.error('Error parsing generatedColors:', e);
                }
            }

            const saved = localStorage.getItem('palette');
            if (saved) {
                try {
                    const json = JSON.parse(saved);
                    if (Object.keys(json).every(k => Array.isArray(json[k]) && json[k].length === 4 && json[k].slice(0, 3).every(c => Number.isInteger(c) && c >= 0 && c <= 255) && json[k][3] >= 0 && json[k][3] <= 1)) {
                        return json;
                    }
                } catch (e) {
                    console.error('Error parsing saved palette:', e);
                }
            }

            return DEFAULT_PALETTE;
        }

        function savePalette() {
            localStorage.setItem('palette', JSON.stringify(palette));
        }

        function updatePaletteTable() {
            const tbody = document.querySelector('#paletteTable tbody');
            tbody.innerHTML = '';
            Object.entries(palette).forEach(([key, color], index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="border-b p-3 text-center text-gray-700">${key}</td>
                    <td class="border-b p-3">
                        <button class="color-btn" style="background-color: rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]});" title="Изменить цвет"></button>
                    </td>
                    <td class="border-b p-3">
                        <button class="delete-btn" title="Удалить цвет">Удалить</button>
                    </td>
                `;
                row.querySelector('.color-btn').addEventListener('click', () => changeColor(index));
                row.querySelector('.delete-btn').addEventListener('click', () => removeSpecificColor(key));
                tbody.appendChild(row);
            });
        }

        function addColor() {
            if (Object.keys(palette).length >= 20) {
                alert('Максимум 20 цветов!');
                return;
            }
            const newKey = (Object.keys(palette).length + 1).toString();
            palette[newKey] = AVAILABLE_COLORS[colorIndex % AVAILABLE_COLORS.length];
            colorIndex++;
            updatePaletteTable();
            savePalette();
        }

        function removeColor() {
            if (Object.keys(palette).length <= 1) {
                alert('Минимум 1 цвет!');
                return;
            }
            const keys = Object.keys(palette);
            delete palette[keys[keys.length - 1]];
            updatePaletteTable();
            savePalette();
        }

        function removeSpecificColor(key) {
            if (Object.keys(palette).length <= 1) {
                alert('Минимум 1 цвет!');
                return;
            }
            delete palette[key];
            const newPalette = {};
            Object.values(palette).forEach((color, index) => {
                newPalette[(index + 1).toString()] = color;
            });
            palette = newPalette;
            updatePaletteTable();
            savePalette();
        }

        function changeColor(row) {
            const key = Object.keys(palette)[row];
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white p-6 rounded-lg max-w-sm w-full">
                    <h3 class="text-lg font-semibold mb-4">Выбор цвета для ключа ${key}</h3>
                    <input type="color" id="colorPicker" value="${rgbToHex(palette[key])}" class="w-full h-12 mb-4">
                    <label class="block text-sm font-medium mb-1">Прозрачность: <span id="opacityValue">${palette[key][3]}</span></label>
                    <input type="range" id="opacitySlider" min="0" max="1" step="0.01" value="${palette[key][3]}" class="w-full mb-4">
                    <div class="flex justify-end gap-3">
                        <button id="cancelBtn" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">Отмена</button>
                        <button id="saveColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700">Сохранить</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            document.getElementById('opacitySlider').addEventListener('input', (e) => {
                document.getElementById('opacityValue').textContent = e.target.value;
            });

            document.getElementById('saveColorBtn').addEventListener('click', () => {
                const color = hexToRgb(document.getElementById('colorPicker').value);
                const opacity = parseFloat(document.getElementById('opacitySlider').value);
                palette[key] = [...color, opacity];
                updatePaletteTable();
                savePalette();
                document.body.removeChild(modal);
            });

            document.getElementById('cancelBtn').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
        }

        function rgbToHex([r, g, b]) {
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
        }

        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
        }

        function generate() {
            stopAnimation();
            stopFullAnimation();
            stopRecording();
            const modeMap = {
                'Линии': 'Lines',
                'Точки': 'Dots',
                'Фигуры': 'Shapes',
                'Смешанный': 'Mixed',
                'Спираль': 'Spiral',
                'Орбиты': 'Orbit',
                'Точки в Фигуры': 'DotToShape',
                'Точки в Смешанный': 'DotsToMixed'
            };
            const mode = modeMap[document.getElementById('modeCombo').value];
            const elements = parseInt(document.getElementById('elementSlider').value);
            const slices = parseInt(document.getElementById('slicesSlider').value);
            generator = new KaleidoGenerator(MAIN_PX, palette, mode, 12, elements, slices);
            const canvas = document.getElementById('previewCanvas');
            canvas.width = CANVAS_PX;
            canvas.height = CANVAS_PX;
            generator.generate(canvas);
            currentImage = canvas;
        }

        function animate() {
            if (!currentImage || !generator) {
                alert('Сначала сгенерируйте узор!');
                return;
            }
            isAnimating = !isAnimating;
            const animateBtn = document.getElementById('animateBtn');
            if (isAnimating) {
                animateBtn.textContent = 'Остановить';
                animateBtn.classList.add('active');
                startTime = Date.now();
                requestAnimationFrame(animateLoop);
            } else {
                animateBtn.textContent = 'Анимировать';
                animateBtn.classList.remove('active');
                cancelAnimationFrame(animationFrameId);
            }
        }

        function animateLoop() {
            if (!isAnimating || !generator) {
                return;
            }
            const canvas = document.getElementById('previewCanvas');
            if (!canvas) {
                stopAnimation();
                return;
            }
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                stopAnimation();
                return;
            }
            canvas.width = CANVAS_PX;
            const elapsedTime = (Date.now() - startTime) / 1000;
            generator.generate(canvas, true, elapsedTime);
            currentImage = canvas;
            animationFrameId = requestAnimationFrame(animateLoop);
        }

        function stopAnimation() {
            if (isAnimating) {
                isAnimating = false;
                const animateBtn = document.getElementById('animateBtn');
                animateBtn.textContent = 'Анимировать';
                animateBtn.classList.remove('active');
                cancelAnimationFrame(animationFrameId);
            }
        }

        function openFullImage() {
            if (!currentImage || !generator) {
                alert('Сначала сгенерируйте узор!');
                return;
            }
            stopAnimation();
            const modal = document.getElementById('imageModal');
            const fullCanvas = document.getElementById('fullCanvas');
            fullCanvas.width = CANVAS_PX;
            fullCanvas.height = CANVAS_PX;
            const gen = new KaleidoGenerator(MAIN_PX, palette,
                document.getElementById('modeCombo').value === 'Линии' ? 'Lines' :
                document.getElementById('modeCombo').value === 'Точки' ? 'Dots' :
                document.getElementById('modeCombo').value === 'Фигуры' ? 'Shapes' :
                document.getElementById('modeCombo').value === 'Смешанный' ? 'Mixed' :
                document.getElementById('modeCombo').value === 'Спираль' ? 'Spiral' :
                document.getElementById('modeCombo').value === 'Орбиты' ? 'Orbit' :
                document.getElementById('modeCombo').value === 'Точки в Фигуры' ? 'DotToShape' :
                'DotsToMixed',
                12,
                parseInt(document.getElementById('elementSlider').value),
                parseInt(document.getElementById('slicesSlider').value)
            );
            isFullAnimating = true;
            fullStartTime = Date.now();
            gen.generate(fullCanvas, true, 0);
            modal.classList.add('show');
            requestAnimationFrame(() => animateFullLoop(gen));
        }

        function animateFullLoop(generator) {
            if (!isFullAnimating || !generator) {
                return;
            }
            const fullCanvas = document.getElementById('fullCanvas');
            if (!fullCanvas) {
                stopFullAnimation();
                return;
            }
            const ctx = fullCanvas.getContext('2d');
            if (!ctx) {
                stopFullAnimation();
                return;
            }
            fullCanvas.width = CANVAS_PX;
            const elapsedTime = (Date.now() - fullStartTime) / 1000;
            generator.generate(fullCanvas, true, elapsedTime);
            fullAnimationFrameId = requestAnimationFrame(() => animateFullLoop(generator));
        }

        function stopFullAnimation() {
            if (isFullAnimating) {
                isFullAnimating = false;
                cancelAnimationFrame(fullAnimationFrameId);
            }
        }

        function save() {
            stopAnimation();
            if (!currentImage || !generator) {
                alert('Сначала сгенерируйте узор!');
                return;
            }
            const fullCanvas = document.createElement('canvas');
            fullCanvas.width = CANVAS_PX;
            fullCanvas.height = CANVAS_PX;
            const gen = new KaleidoGenerator(MAIN_PX, palette,
                document.getElementById('modeCombo').value === 'Линии' ? 'Lines' :
                document.getElementById('modeCombo').value === 'Точки' ? 'Dots' :
                document.getElementById('modeCombo').value === 'Фигуры' ? 'Shapes' :
                document.getElementById('modeCombo').value === 'Смешанный' ? 'Mixed' :
                document.getElementById('modeCombo').value === 'Спираль' ? 'Spiral' :
                document.getElementById('modeCombo').value === 'Орбиты' ? 'Orbit' :
                document.getElementById('modeCombo').value === 'Точки в Фигуры' ? 'DotToShape' :
                'DotsToMixed',
                12,
                parseInt(document.getElementById('elementSlider').value),
                parseInt(document.getElementById('slicesSlider').value)
            );
            gen.generate(fullCanvas);
            const link = document.createElement('a');
            link.download = 'калейдоскоп.png';
            link.href = fullCanvas.toDataURL('image/png');
            link.click();
        }

        function startStopRecording() {
            if (!currentImage || !generator) {
                alert('Сначала сгенерируйте узор!');
                return;
            }
            const recordBtn = document.getElementById('recordBtn');
            const downloadVideoBtn = document.getElementById('downloadVideoBtn');
            if (!isRecording) {
                if (!isAnimating) {
                    isAnimating = true;
                    startTime = Date.now();
                    requestAnimationFrame(animateLoop);
                    document.getElementById('animateBtn').textContent = 'Остановить';
                    document.getElementById('animateBtn').classList.add('active');
                }
                recordedChunks = [];
                const canvas = document.getElementById('previewCanvas');
                const stream = canvas.captureStream(60);
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'video/webm;codecs=vp9',
                    videoBitsPerSecond: 500000000
                });
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                mediaRecorder.onstop = () => {
                    downloadVideoBtn.disabled = false;
                };
                mediaRecorder.start();
                isRecording = true;
                recordBtn.textContent = 'Стоп запись';
                recordBtn.classList.add('active');
            } else {
                mediaRecorder.stop();
                isRecording = false;
                recordBtn.textContent = 'Старт запись';
                recordBtn.classList.remove('active');
            }
        }

        function downloadVideo() {
            if (recordedChunks.length === 0) {
                alert('Нет записанного видео для скачивания!');
                return;
            }
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'калейдоскоп.webm';
            link.click();
            URL.revokeObjectURL(url);
            document.getElementById('downloadVideoBtn').disabled = true;
        }

        document.getElementById('elementSlider').addEventListener('input', (e) => {
            document.getElementById('elementValue').textContent = e.target.value;
            stopAnimation();
            stopFullAnimation();
            stopRecording();
        });

        document.getElementById('slicesSlider').addEventListener('input', (e) => {
            document.getElementById('slicesValue').textContent = e.target.value;
            stopAnimation();
            stopFullAnimation();
            stopRecording();
        });

        document.getElementById('animationSpeedSlider').addEventListener('input', (e) => {
            ANIMATION_SPEED = parseFloat(e.target.value);
            document.getElementById('animationSpeedValue').textContent = ANIMATION_SPEED.toFixed(2);
        });

        document.getElementById('modeCombo').addEventListener('change', () => {
            stopAnimation();
            stopFullAnimation();
            stopRecording();
        });

        document.getElementById('addColorBtn').addEventListener('click', () => {
            addColor();
            stopAnimation();
            stopFullAnimation();
            stopRecording();
        });

        document.getElementById('removeColorBtn').addEventListener('click', () => {
            removeColor();
            stopAnimation();
            stopFullAnimation();
            stopRecording();
        });

        document.getElementById('generateBtn').addEventListener('click', generate);
        document.getElementById('animateBtn').addEventListener('click', animate);
        document.getElementById('recordBtn').addEventListener('click', startStopRecording);
        document.getElementById('downloadVideoBtn').addEventListener('click', downloadVideo);
        document.getElementById('viewBtn').addEventListener('click', openFullImage);
        document.getElementById('saveBtn').addEventListener('click', save);
        document.getElementById('closeModalBtn').addEventListener('click', () => {
            stopFullAnimation();
            document.getElementById('imageModal').classList.remove('show');
        });

        document.getElementById('home').addEventListener('click', () => {
            stopAnimation();
            stopFullAnimation();
            stopRecording();
            window.location.href = 'index.html';
        });

        function stopRecording() {
            if (isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                document.getElementById('recordBtn').textContent = 'Старт запись';
                document.getElementById('recordBtn').classList.remove('active');
                document.getElementById('downloadVideoBtn').disabled = recordedChunks.length === 0;
            }
        }

        updatePaletteTable();
    </script>
</body>
</html>
