<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∫–∞–ª–µ–π–¥–æ—Å–∫–æ–ø–æ–≤</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background: linear-gradient(135deg, #6b7280, #4c1d95);
            min-height: 100vh;
        }
        canvas {
            background-color: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
        }
        .color-btn {
            width: 100%;
            height: 36px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            transition: transform 0.2s;
        }
        .color-btn:hover {
            transform: scale(1.05);
        }
        .delete-btn {
            background: #e74c3c;
            color: white;
            padding: 6px;
            border-radius: 6px;
            font-size: 12px;
            transition: background 0.3s;
        }
        .delete-btn:hover {
            background: #c0392b;
        }
        #previewCanvas {
            max-width: 300px;
            width: 100%;
            aspect-ratio: 1/1;
        }
        #fullCanvas {
            max-width: 800px;
            width: 100%;
            aspect-ratio: 1/1;
        }
        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        #backgroundColorPreview {
            width: 100%;
            height: 36px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
        }
        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        }
        .custom-range::-webkit-slider-thumb {
            background: #7c3aed;
        }
        .custom-range::-moz-range-thumb {
            background: #7c3aed;
        }
        #imageModal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 50;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        #imageModal.show {
            display: flex;
        }
        details summary {
            cursor: pointer;
            font-size: 1.25rem;
            font-weight: 600;
            color: #4c1d95;
            padding: 0.5rem;
        }
        details summary:hover {
            color: #7c3aed;
        }
        details p {
            margin-top: 0.5rem;
            color: #374151;
        }
        #animateBtn, #recordBtn {
            background: linear-gradient(45deg, #7c3aed, #4c1d95);
            color: white;
            transition: transform 0.3s, background 0.3s;
        }
        #animateBtn:hover, #recordBtn:hover {
            transform: scale(1.05);
            background: linear-gradient(45deg, #9f67ff, #6b46c1);
        }
        #animateBtn.active, #recordBtn.active {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.75rem;
        }
        .action-buttons button {
            flex: 1;
            padding: 0.75rem;
            font-size: 0.9rem;
        }
        /* Styles for image upload preview */
        #sourceImageContainer img {
            border: 3px solid #7c3aed;
            transition: all 0.3s ease;
        }
    </style>
</head>
<body class="font-sans text-gray-900">
    <div class="container mx-auto p-4 sm:p-6 md:p-8 max-w-7xl">
        <details class="card p-4 rounded-xl shadow-lg mb-6">
            <summary>–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏</summary>
            <p>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∫–∞–ª–µ–π–¥–æ—Å–∫–æ–ø–æ–≤! –°–ª–µ–¥—É–π—Ç–µ —ç—Ç–∏–º —à–∞–≥–∞–º:</p>
            <ul class="list-disc pl-5 mt-2">
                <li><strong>–í—ã–±–æ—Ä —É–∑–æ—Ä–∞:</strong> –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø —É–∑–æ—Ä–∞ (–õ–∏–Ω–∏–∏, –¢–æ—á–∫–∏, –§–∏–≥—É—Ä—ã –∏ –¥—Ä.).</li>
                <li><strong>–ü–∞–ª–∏—Ç—Ä–∞ –∏–∑ —Ñ–æ—Ç–æ:</strong> –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∫–∞—Ä—Ç–∏–Ω—É (–Ω–∞–ø—Ä–∏–º–µ—Ä, –í–∞–Ω –ì–æ–≥–∞), —á—Ç–æ–±—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞—Ç—å –ø–∞–ª–∏—Ç—Ä—É –∏–∑ 7-9 —Ü–≤–µ—Ç–æ–≤.</li>
                <li><strong>–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤:</strong> –†–µ–≥—É–ª–∏—Ä—É–π—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, —Å–µ–∫—Ç–æ—Ä–æ–≤ –∏ —Å–∫–æ—Ä–æ—Å—Ç—å.</li>
                <li><strong>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è:</strong> –ù–∞–∂–º–∏—Ç–µ "–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å" –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —É–∑–æ—Ä–∞.</li>
                <li><strong>–ê–Ω–∏–º–∞—Ü–∏—è –∏ –∑–∞–ø–∏—Å—å:</strong> –°–æ–∑–¥–∞–≤–∞–π—Ç–µ –∂–∏–≤—ã–µ —É–∑–æ—Ä—ã –∏ —Å–æ—Ö—Ä–∞–Ω—è–π—Ç–µ –≤–∏–¥–µ–æ.</li>
            </ul>
        </details>
        <h1 class="text-3xl sm:text-4xl font-extrabold text-center text-white mb-8 drop-shadow-lg">–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∫–∞–ª–µ–π–¥–æ—Å–∫–æ–ø–æ–≤</h1>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <div class="space-y-6">
                <div class="card p-6 rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 text-indigo-700">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–∑–æ—Ä–∞</h2>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium mb-1 text-gray-700">–¢–∏–ø —É–∑–æ—Ä–∞</label>
                            <select id="modeCombo" class="w-full p-3 border border-gray-300 rounded-lg bg-white focus:ring-2 focus:ring-indigo-500">
                                <option>–õ–∏–Ω–∏–∏</option>
                                <option>–¢–æ—á–∫–∏</option>
                                <option>–§–∏–≥—É—Ä—ã</option>
                                <option>–°–º–µ—à–∞–Ω–Ω—ã–π</option>
                                <option>–°–ø–∏—Ä–∞–ª—å</option>
                                <option>–û—Ä–±–∏—Ç—ã</option>
                                <option>–¢–æ—á–∫–∏ –≤ –§–∏–≥—É—Ä—ã</option>
                                <option>–¢–æ—á–∫–∏ –≤ –°–º–µ—à–∞–Ω–Ω—ã–π</option>
                                <option value="Crystal">–ö—Ä–∏—Å—Ç–∞–ª–ª–∏—á–µ—Å–∫–æ–µ (–∏–∑–±—Ä–∞–Ω–Ω–æ–µ)</option>
                                <option value="Sphere">3–î –°–§–ï–†–ê (–∏–∑–±—Ä–∞–Ω–Ω–æ–µ)</option>
                                <option value="Kovrov">–ö–æ–≤–µ—Ä (–∏–∑–±—Ä–∞–Ω–Ω–æ–µ)</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-1 text-gray-700">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤: <span id="elementValue" class="font-bold">300</span></label>
                            <input type="range" id="elementSlider" min="100" max="1000" value="300" class="w-full custom-range">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-1 text-gray-700">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–∫—Ç–æ—Ä–æ–≤: <span id="slicesValue" class="font-bold">13</span></label>
                            <input type="range" id="slicesSlider" min="3" max="40" value="13" class="w-full custom-range">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-1 text-gray-700">–°–∫–æ—Ä–æ—Å—Ç—å –∞–Ω–∏–º–∞—Ü–∏–∏: <span id="animationSpeedValue" class="font-bold">0.1</span></label>
                            <input type="range" id="animationSpeedSlider" min="0.05" max="0.5" step="0.01" value="0.1" class="w-full custom-range">
                        </div>
                    </div>
                </div>
                <div class="card p-6 rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 text-indigo-700">–ü–∞–ª–∏—Ç—Ä–∞ —Ü–≤–µ—Ç–æ–≤</h2>
                    
                    <div class="mb-6 p-4 bg-indigo-50 rounded-lg border border-indigo-100">
                        <label class="block text-sm font-bold mb-2 text-indigo-900">üé® –°–æ–∑–¥–∞—Ç—å –ø–∞–ª–∏—Ç—Ä—É –∏–∑ –∫–∞—Ä—Ç–∏–Ω—ã</label>
                        <p class="text-xs text-gray-600 mb-3">–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–æ—Ç–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "–ü–æ–¥—Å–æ–ª–Ω—É—Ö–∏"), –∏ –º—ã –∏–∑–≤–ª–µ—á–µ–º 7-9 –≥–ª–∞–≤–Ω—ã—Ö —Ü–≤–µ—Ç–æ–≤.</p>
                        <input type="file" id="imageInput" accept="image/*" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-700 cursor-pointer">
                    </div>

                    <div class="overflow-x-auto">
                        <table id="paletteTable" class="w-full border-collapse mb-4">
                            <thead>
                                <tr>
                                    <th class="border-b-2 p-3 text-left text-gray-700 w-16">–ö–ª—é—á</th>
                                    <th class="border-b-2 p-3 text-left text-gray-700">–¶–≤–µ—Ç</th>
                                    <th class="border-b-2 p-3 text-left text-gray-700 w-24">–î–µ–π—Å—Ç–≤–∏–µ</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-3">
                        <button id="addColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 transition-colors" title="–î–æ–±–∞–≤–∏—Ç—å —Ü–≤–µ—Ç">–î–æ–±–∞–≤–∏—Ç—å —Ü–≤–µ—Ç</button>
                        <button id="removeColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 transition-colors" title="–£–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ü–≤–µ—Ç">–£–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π</button>
                        <button id="changeBackgroundColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 transition-colors" title="–ò–∑–º–µ–Ω–∏—Ç—å —Ü–≤–µ—Ç —Ñ–æ–Ω–∞">–í—ã–±—Ä–∞—Ç—å —Ü–≤–µ—Ç —Ñ–æ–Ω–∞</button>
                    </div>
                </div>
            </div>
            <div class="space-y-6">
                <div class="card p-6 rounded-xl shadow-lg flex flex-col justify-center items-center">
                    
                    <div id="sourceImageContainer" class="hidden w-full mb-6 text-center relative">
                        <div class="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-indigo-600 text-white text-xs px-2 py-1 rounded-full shadow">–ò—Å—Ö–æ–¥–Ω–æ–µ —Ñ–æ—Ç–æ</div>
                        <img id="sourceImagePreview" class="max-h-40 mx-auto rounded-lg shadow-md object-contain bg-gray-100">
                    </div>

                    <div class="w-full">
                        <h2 class="text-xl font-semibold mb-4 text-indigo-700 text-center">–ö–∞–ª–µ–π–¥–æ—Å–∫–æ–ø</h2>
                        <canvas id="previewCanvas" class="mx-auto shadow-inner"></canvas>
                    </div>
                </div>
                <div class="card p-6 rounded-xl shadow-lg">
                    <div class="action-buttons">
                        <button id="generateBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="–°–æ–∑–¥–∞—Ç—å —É–∑–æ—Ä">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å</button>
                        <button id="animateBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="–ó–∞–ø—É—Å—Ç–∏—Ç—å/–æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∞–Ω–∏–º–∞—Ü–∏—é">–ê–Ω–∏–º–∏—Ä–æ–≤–∞—Ç—å</button>
                        <button id="recordBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="–ù–∞—á–∞—Ç—å/–æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–∞–ø–∏—Å—å –≤–∏–¥–µ–æ">–°—Ç–∞—Ä—Ç –∑–∞–ø–∏—Å—å</button>
                        <button id="downloadVideoBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="–°–∫–∞—á–∞—Ç—å –∑–∞–ø–∏—Å–∞–Ω–Ω–æ–µ –≤–∏–¥–µ–æ" disabled>–°–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ</button>
                        <button id="viewBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="–û—Ç–∫—Ä—ã—Ç—å —É–∑–æ—Ä">–û—Ç–∫—Ä—ã—Ç—å –ø–æ–ª–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</button>
                        <button id="saveBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —É–∑–æ—Ä">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</button>
                    </div>
                    <div id="recordTimer" class="text-center mt-2 text-gray-600 font-mono text-sm">–ó–∞–ø–∏—Å—å: 00:00</div>
                </div>
            </div>
        </div>
        <button id="home" class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 transition-colors" style="margin-top: 20px;" title="–í–µ—Ä–Ω—É—Ç—å—Å—è">‚Üê –í–µ—Ä–Ω—É—Ç—å—Å—è</button>
        <div id="imageModal" class="fixed inset-0 bg-black bg-opacity-70 hidden flex items-center justify-center p-4 z-50">
            <div class="bg-white p-6 rounded-xl max-w-[90vw] max-h-[90vh] overflow-auto">
                <canvas id="fullCanvas" class="mx-auto"></canvas>
                <div class="text-center mt-4">
                    <button id="closeModalBtn" class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 transition-colors" title="–ó–∞–∫—Ä—ã—Ç—å">–ó–∞–∫—Ä—ã—Ç—å</button>
                </div>
            </div>
        </div>
    </div>

    <script>
       const DPI = 300;
const CM_TO_INCH = 1 / 2.54;
const MAIN_CM = 15;
const MAIN_PX = Math.round(MAIN_CM * CM_TO_INCH * DPI);
const CANVAS_PX = MAIN_PX;
const MOBILE_RECORDING_PX = 1280;
const MAX_RECORDING_DURATION = 60;
let ANIMATION_SPEED = 0.1;
let backgroundColor = [255, 255, 255, 1]; 

const DEFAULT_PALETTE = {
    '1': [245, 245, 220, 1],
    '2': [0, 0, 0, 1],
    '3': [255, 255, 0, 1],
    '4': [255, 0, 255, 1]
};

const AVAILABLE_COLORS = [
    [245, 245, 220, 1],
    [255, 255, 0, 1],
    [0, 0, 0, 1],
    [255, 0, 255, 1],
    [144, 238, 144, 1]
];

let colorIndex = 0;
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

class KaleidoGenerator {
    constructor(size_px, palette, mode = 'Lines', sectors = 12, elements = 300, slices = 13) {
        this.size = size_px;
        this.palette = Object.values(palette);
        this.mode = mode;
        this.sectors = sectors;
        this.elements = Math.min(elements, 500);
        this.slices = slices;
        this.branch_settings = {
            size: 150,
            angle: 0.4,
            scale: 0.67,
            iterations: Math.max(1, Math.floor(elements / 100)),
            offset: 0,
            spiral_density: 0.05,
        };
        this.elementsData = [];
        this.initElements();
    }

    initElements() {
        this.elementsData = [];
        const angle = 360 / this.sectors;
        if (this.mode === 'Lines') {
            for (let i = 0; i < this.elements; i++) {
                this.elementsData.push({
                    r1: Math.random(),
                    theta1: (Math.random() * angle - angle / 2) * Math.PI / 180,
                    r2: Math.random(),
                    theta2: (Math.random() * angle - angle / 2) * Math.PI / 180,
                    colorIdx: Math.floor(Math.random() * this.palette.length),
                    lineWidth: Math.floor(Math.random() * 4) + 1
                });
            }
        } else if (this.mode === 'Dots') {
            for (let i = 0; i < this.elements; i++) {
                this.elementsData.push({
                    r: Math.random(),
                    theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                    colorIdx: Math.floor(Math.random() * this.palette.length),
                    size_dot: Math.random() * 6 + 2
                });
            }
        } else if (this.mode === 'Shapes') {
            for (let i = 0; i < this.elements; i++) {
                this.elementsData.push({
                    r: Math.random(),
                    theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                    colorIdx: Math.floor(Math.random() * this.palette.length),
                    size_sq: Math.random() * 15 + 5
                });
            }
        } else if (this.mode === 'Mixed') {
            for (let i = 0; i < this.elements; i++) {
                const type = ['Lines', 'Dots', 'Shapes'][Math.floor(Math.random() * 3)];
                if (type === 'Lines') {
                    this.elementsData.push({
                        type: 'Lines',
                        r1: Math.random(),
                        theta1: (Math.random() * angle - angle / 2) * Math.PI / 180,
                        r2: Math.random(),
                        theta2: (Math.random() * angle - angle / 2) * Math.PI / 180,
                        colorIdx: Math.floor(Math.random() * this.palette.length),
                        lineWidth: Math.floor(Math.random() * 4) + 1
                    });
                } else if (type === 'Dots') {
                    this.elementsData.push({
                        type: 'Dots',
                        r: Math.random(),
                        theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                        colorIdx: Math.floor(Math.random() * this.palette.length),
                        size_dot: Math.random() * 6 + 2
                    });
                } else {
                    this.elementsData.push({
                        type: 'Shapes',
                        r: Math.random(),
                        theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                        colorIdx: Math.floor(Math.random() * this.palette.length),
                        size_sq: Math.random() * 15 + 5
                    });
                }
            }
        } else if (this.mode === 'Spiral') {
            const spiral_count = Math.floor(this.elements / 10);
            for (let i = 0; i < spiral_count; i++) {
                this.elementsData.push({
                    theta_start: (Math.random() * angle - angle / 2) * Math.PI / 180,
                    color_idx: Math.floor(Math.random() * this.palette.length)
                });
            }
        } else if (this.mode === 'Orbit') {
            const diameter = this.size;
            const a = 0.266746, b = 0.321596, c = 0.223138;
            this.elementsData = [
                { class: 'a', width: diameter * a, top: (diameter/2 - (diameter*a/2)) * 0.60, left: diameter/2 - (diameter*a/2), blink: 'blink-lightest', speed: 5*a, delay: 2*a },
                { class: 'a', width: diameter * a, top: (diameter/2 - (diameter*a/2)) * 1.22, left: (diameter/2 - (diameter*a/2)) * 0.65, blink: 'blink-lightest', speed: 5*a, delay: 1*a },
                { class: 'a', width: diameter * a, top: (diameter/2 - (diameter*a/2)) * 1.22, right: (diameter/2 - (diameter*a/2)) * 0.65, blink: 'blink-lightest', speed: 5*a, delay: 1*a },
                { class: 'b', width: diameter * b, top: (diameter/2 - (diameter*b/2)) * 0.52, left: diameter*b/7, blink: 'blink-lightest', speed: 5*b, delay: 1*b },
                { class: 'b', width: diameter * b, top: (diameter/2 - (diameter*b/2)) * 0.52, right: diameter*b/7, blink: 'blink-lightest', speed: 5*b, delay: 1*b },
                { class: 'b', width: diameter * b, bottom: 0, left: diameter/2 - (diameter*b/2), blink: 'blink', speed: 5*b, delay: 2*b },
                { class: 'c', width: diameter * c, top: diameter*c/15, left: diameter*c * 1.23, blink: 'blink-lightest', speed: 6*c, delay: 3*c },
                { class: 'c', width: diameter * c, top: diameter*c/15, right: diameter*c * 1.23, blink: 'blink-lightest', speed: 6*c, delay: 2*c },
                { class: 'c', width: diameter * c, bottom: diameter*c/2.3, left: diameter*c * 0.55, blink: 'blink-lightest', speed: 6*c, delay: 4*c },
                { class: 'c', width: diameter * c, bottom: diameter*c * 1.3, left: diameter*c * 0.05, blink: 'blink-lightest', speed: 6*c, delay: 3*c },
                { class: 'c', width: diameter * c, bottom: diameter*c/2.3, right: diameter*c * 0.55, blink: 'blink-lightest', speed: 6*c, delay: 2*c },
                { class: 'c', width: diameter * c, bottom: diameter*c * 1.3, right: diameter*c * 0.05, blink: 'blink-lightest', speed: 6*c, delay: 3*c },
                { class: 'center', width: diameter * a, top: diameter/2 - (diameter*a/2), left: diameter/2 - (diameter*a/2), blink: 'blink', speed: 3, delay: 0 },
                { class: 'tile-cover', width: diameter, top: 0, left: 0, blink: 'blink', speed: 3, delay: 1 },
                { class: 'tile-back', width: diameter, top: 0, left: 0, blink: 'blink', speed: 5, delay: 2 },
            ];
        } else if (this.mode === 'DotToShape') {
            for (let i = 0; i < this.elements; i++) {
                this.elementsData.push({
                    r: Math.random(),
                    theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                    colorIdx: Math.floor(Math.random() * this.palette.length),
                    size_dot: Math.random() * 6 + 2,
                    size_sq: Math.random() * 15 + 5
                });
            }
        } else if (this.mode === 'DotsToMixed') {
            for (let i = 0; i < this.elements; i++) {
                const type = ['Lines', 'Dots', 'Shapes'][Math.floor(Math.random() * 3)];
                this.elementsData.push({
                    r: Math.random(),
                    theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                    colorIdx: Math.floor(Math.random() * this.palette.length),
                    size_dot: Math.random() * 6 + 2,
                    type: type,
                    r1: type === 'Lines' ? Math.random() : null,
                    theta1: type === 'Lines' ? (Math.random() * angle - angle / 2) * Math.PI / 180 : null,
                    r2: type === 'Lines' ? Math.random() : null,
                    theta2: type === 'Lines' ? (Math.random() * angle - angle / 2) * Math.PI / 180 : null,
                    lineWidth: type === 'Lines' ? Math.floor(Math.random() * 4) + 1 : null,
                    size_sq: type === 'Shapes' ? Math.random() * 15 + 5 : null
                });
            }
        }
    }

    generate(canvas, animate = false, animationTime = 0) {
        const ctx = canvas.getContext('2d');
        canvas.width = this.size;
        canvas.height = this.size;
        ctx.fillStyle = `rgba(${backgroundColor[0]}, ${backgroundColor[1]}, ${backgroundColor[2]}, ${backgroundColor[3]})`;
        ctx.fillRect(0, 0, this.size, this.size);
        ctx.globalAlpha = animate ? 0.9 : 1.0;
        const main = this._makeKaleidoSquare(animate, animationTime);
        ctx.drawImage(main, 0, 0);
        ctx.globalAlpha = 1.0;
    }

    _interpolateColor(color1, color2, factor) {
        return [
            Math.round(color1[0] * (1 - factor) + color2[0] * factor),
            Math.round(color1[1] * (1 - factor) + color2[1] * factor),
            Math.round(color1[2] * (1 - factor) + color2[2] * factor),
            color1[3] * (1 - factor) + color2[3] * factor
        ];
    }

    _makeTrianglifyPattern(width, height, t) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        const cell_size = 50;
        for (let i = 0; i < width; i += cell_size) {
            for (let j = 0; j < height; j += cell_size) {
                const points = [
                    [i, j],
                    [i + cell_size, j],
                    [i + cell_size, j + cell_size],
                    [i, j + cell_size],
                ];
                const color1 = this.palette[Math.floor(Math.random() * this.palette.length)];
                const color2 = this.palette[Math.floor(Math.random() * this.palette.length)];
                const factor = t ? (Math.sin(t + i * 0.1 + j * 0.1) + 1) / 2 : 0;
                ctx.fillStyle = `rgba(${this._interpolateColor(color1, color2, factor).join(',')})`;
                ctx.beginPath();
                ctx.moveTo(points[0][0], points[0][1]);
                ctx.lineTo(points[1][0], points[1][1]);
                ctx.lineTo(points[2][0], points[2][1]);
                ctx.fill();
                ctx.fillStyle = `rgba(${this._interpolateColor(color2, color1, factor).join(',')})`;
                ctx.beginPath();
                ctx.moveTo(points[0][0], points[0][1]);
                ctx.lineTo(points[2][0], points[2][1]);
                ctx.lineTo(points[3][0], points[3][1]);
                ctx.fill();
            }
        }
        return canvas;
    }

    _makeKaleidoSquare(animate, animationTime) {
        const canvas = document.createElement('canvas');
        canvas.width = this.size;
        canvas.height = this.size;
        const ctx = canvas.getContext('2d');
        const radius = this.size / 2;
        const angle = 360 / this.sectors;
        const cx = radius, cy = radius;
        const t = animate ? animationTime * ANIMATION_SPEED : 0;
        const rotationOffset = Math.sin(t) * 0.4;

        if (this.mode === 'Lines') {
            for (let i = 0; i < this.elementsData.length; i++) {
                const data = this.elementsData[i];
                const color = this.palette[data.colorIdx];
                const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                ctx.strokeStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                const x1 = cx + data.r1 * radius * Math.cos(data.theta1 + thetaOffset);
                const y1 = cy + data.r1 * radius * Math.sin(data.theta1 + thetaOffset);
                const x2 = cx + data.r2 * radius * Math.cos(data.theta2 + thetaOffset);
                const y2 = cy + data.r2 * radius * Math.sin(data.theta2 + thetaOffset);
                ctx.lineWidth = data.lineWidth * (1 + Math.sin(t + i * 0.3) * 0.8);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        } else if (this.mode === 'Dots') {
            for (let i = 0; i < this.elementsData.length; i++) {
                const data = this.elementsData[i];
                const color = this.palette[data.colorIdx];
                const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                ctx.beginPath();
                ctx.arc(x, y, size_dot, 0, 2 * Math.PI);
                ctx.fill();
            }
        } else if (this.mode === 'Shapes') {
            for (let i = 0; i < this.elementsData.length; i++) {
                const data = this.elementsData[i];
                const color = this.palette[data.colorIdx];
                const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                const size_sq = data.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8);
                ctx.fillRect(x - size_sq, y - size_sq, size_sq * 2, size_sq * 2);
            }
        } else if (this.mode === 'Mixed') {
            for (let i = 0; i < this.elementsData.length; i++) {
                const data = this.elementsData[i];
                const color = this.palette[data.colorIdx];
                const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                ctx.strokeStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                if (data.type === 'Lines') {
                    const x1 = cx + data.r1 * radius * Math.cos(data.theta1 + thetaOffset);
                    const y1 = cy + data.r1 * radius * Math.sin(data.theta1 + thetaOffset);
                    const x2 = cx + data.r2 * radius * Math.cos(data.theta2 + thetaOffset);
                    const y2 = cy + data.r2 * radius * Math.sin(data.theta2 + thetaOffset);
                    ctx.lineWidth = data.lineWidth * (1 + Math.sin(t + i * 0.3) * 0.8);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                } else if (data.type === 'Dots') {
                    const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                    const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                    const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                    ctx.beginPath();
                    ctx.arc(x, y, size_dot, 0, 2 * Math.PI);
                    ctx.fill();
                } else {
                    const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                    const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                    const size_sq = data.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8);
                    ctx.fillRect(x - size_sq, y - size_sq, size_sq * 2, size_sq * 2);
                }
            }
        } else if (this.mode === 'Spiral') {
            const s = this.branch_settings;
            for (let i = 0; i < this.elementsData.length; i++) {
                let theta_start = this.elementsData[i].theta_start + t * 0.3;
                let color_idx = this.elementsData[i].color_idx;
                const next_color_idx = (color_idx + 1) % this.palette.length;
                for (let r = 0; r < radius; r += 2) {
                    const theta = theta_start + r * s.spiral_density;
                    const x = cx + r * Math.cos(theta);
                    const y = cy + r * Math.sin(theta);
                    const colorFactor = (Math.sin(t + r * 0.02) + 1) / 2;
                    const r_col = Math.round(this.palette[color_idx][0] * (1 - colorFactor) + this.palette[next_color_idx][0] * colorFactor);
                    const g_col = Math.round(this.palette[color_idx][1] * (1 - colorFactor) + this.palette[next_color_idx][1] * colorFactor);
                    const b_col = Math.round(this.palette[color_idx][2] * (1 - colorFactor) + this.palette[next_color_idx][2] * colorFactor);
                    const a_col = this.palette[color_idx][3] * (1 - colorFactor) + this.palette[next_color_idx][3] * colorFactor;
                    const width = Math.max(2, 4 + Math.sin(r * 0.03 + t) * 5);
                    ctx.fillStyle = `rgba(${r_col}, ${g_col}, ${b_col}, ${a_col})`;
                    ctx.beginPath();
                    ctx.arc(x, y, width, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
        } else if (this.mode === 'Orbit') {
            const diameter = this.size;
            for (const config of this.elementsData) {
                const width = config.width;
                const height = width;
                let x = config.left !== undefined ? config.left : diameter - config.right - width;
                let y = config.top !== undefined ? config.top : diameter - config.bottom - height;
                x = cx + (x - diameter/2) * (1 + Math.sin(t) * 0.3);
                y = cy + (y - diameter/2) * (1 + Math.cos(t) * 0.3);
                const opacity = config.blink === 'blink' ? 0.5 + 0.5 * Math.sin(t / config.speed) :
                                config.blink === 'blink-lighter' ? 0.3 + 0.2 * Math.sin(t / config.speed) :
                                0.375 + 0.375 * Math.sin(t / config.speed);
                const pattern = this._makeTrianglifyPattern(width, height, t);
                ctx.globalAlpha = opacity;
                ctx.drawImage(pattern, x, y, width, height);
                ctx.globalAlpha = 1;
                ctx.strokeStyle = `rgba(0, 0, 255, ${0.5 + Math.sin(t) * 0.5})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(x + width / 2, y + height / 2, width / 2, 0, 2 * Math.PI);
                ctx.stroke();
            }
        } else if (this.mode === 'DotToShape') {
            for (let i = 0; i < this.elementsData.length; i++) {
                const data = this.elementsData[i];
                const color = this.palette[data.colorIdx];
                const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                const size_sq = data.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8);
                const shapeFactor = (Math.sin(t * 2) + 1) / 2;
                const size = size_dot * (1 - shapeFactor) + size_sq * shapeFactor;
                const cornerRadius = size * (1 - shapeFactor);
                ctx.beginPath();
                ctx.moveTo(x - size + cornerRadius, y - size);
                ctx.lineTo(x + size - cornerRadius, y - size);
                ctx.arcTo(x + size, y - size, x + size, y - size + cornerRadius, cornerRadius);
                ctx.lineTo(x + size, y + size - cornerRadius);
                ctx.arcTo(x + size, y + size, x + size - cornerRadius, y + size, cornerRadius);
                ctx.lineTo(x - size + cornerRadius, y + size);
                ctx.arcTo(x - size, y + size, x - size, y + size - cornerRadius, cornerRadius);
                ctx.lineTo(x - size, y - size + cornerRadius);
                ctx.arcTo(x - size, y - size, x - size + cornerRadius, y - size, cornerRadius);
                ctx.closePath();
                ctx.fill();
            }
        } else if (this.mode === 'DotsToMixed') {
            for (let i = 0; i < this.elementsData.length; i++) {
                const data = this.elementsData[i];
                const color = this.palette[data.colorIdx];
                const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                ctx.strokeStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                const shapeFactor = (Math.sin(t * 2) + 1) / 2;
                if (shapeFactor < 0.5) {
                    const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                    ctx.beginPath();
                    ctx.arc(x, y, size_dot * (1 - shapeFactor * 2), 0, 2 * Math.PI);
                    ctx.fill();
                } else {
                    if (data.type === 'Lines') {
                        const x1 = cx + data.r1 * radius * Math.cos(data.theta1 + thetaOffset);
                        const y1 = cy + data.r1 * radius * Math.sin(data.theta1 + thetaOffset);
                        const x2 = cx + data.r2 * radius * Math.cos(data.theta2 + thetaOffset);
                        const y2 = cy + data.r2 * radius * Math.sin(data.theta2 + thetaOffset);
                        ctx.lineWidth = data.lineWidth * (1 + Math.sin(t + i * 0.3) * 0.8) * (shapeFactor * 2 - 1);
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    } else if (data.type === 'Dots') {
                        const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8) * (shapeFactor * 2 - 1);
                        ctx.beginPath();
                        ctx.arc(x, y, size_dot, 0, 2 * Math.PI);
                        ctx.fill();
                    } else {
                        const size_sq = data.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8) * (shapeFactor * 2 - 1);
                        ctx.fillRect(x - size_sq, y - size_sq, size_sq * 2, size_sq * 2);
                    }
                }
            }
        }

        const full = document.createElement('canvas');
        full.width = this.size;
        full.height = this.size;
        const fullCtx = full.getContext('2d');
        fullCtx.fillStyle = `rgba(${backgroundColor[0]}, ${backgroundColor[1]}, ${backgroundColor[2]}, ${backgroundColor[3]})`;
        fullCtx.fillRect(0, 0, this.size, this.size);
        for (let i = 0; i < this.sectors; i++) {
            fullCtx.save();
            fullCtx.translate(cx, cy);
            fullCtx.rotate((angle * i + rotationOffset) * Math.PI / 180);
            if (i % 2 === 1) {
                fullCtx.scale(-1, 1);
            }
            fullCtx.drawImage(canvas, -cx, -cy);
            fullCtx.restore();
        }
        return full;
    }
}

let palette = loadPalette();
let currentImage = null;
let isAnimating = false;
let isFullAnimating = false;
let isRecording = false;
let animationFrameId = null;
let fullAnimationFrameId = null;
let startTime = null;
let fullStartTime = null;
let generator = null;
let mediaRecorder = null;
let recordedChunks = [];
let recordTimerId = null;
let recordStartTime = null;

function loadPalette() {
    const generatedColors = localStorage.getItem('generatedColors');
    if (generatedColors) {
        try {
            const colors = JSON.parse(generatedColors);
            if (Array.isArray(colors) && colors.every(c => /^#[0-9A-Fa-f]{6}$/.test(c))) {
                const newPalette = {};
                colors.forEach((color, index) => {
                    const rgb = hexToRgb(color);
                    newPalette[(index + 1).toString()] = [...rgb, 1];
                });
                localStorage.setItem('palette', JSON.stringify(newPalette));
                return newPalette;
            }
        } catch (e) {
            console.error('Error parsing generatedColors:', e);
        }
    }
    const saved = localStorage.getItem('palette');
    if (saved) {
        try {
            const json = JSON.parse(saved);
            if (Object.keys(json).every(k => Array.isArray(json[k]) && json[k].length === 4 && json[k].slice(0, 3).every(c => Number.isInteger(c) && c >= 0 && c <= 255) && json[k][3] >= 0 && json[k][3] <= 1)) {
                return json;
            }
        } catch (e) {
            console.error('Error parsing saved palette:', e);
        }
    }
    return DEFAULT_PALETTE;
}

function loadBackgroundColor() {
    const saved = localStorage.getItem('backgroundColor');
    if (saved) {
        try {
            const color = JSON.parse(saved);
            if (Array.isArray(color) && color.length === 4 && color.slice(0, 3).every(c => Number.isInteger(c) && c >= 0 && c <= 255) && color[3] >= 0 && color[3] <= 1) {
                backgroundColor = color;
            }
        } catch (e) {
            console.error('Error parsing saved background color:', e);
        }
    }
}

function savePalette() {
    localStorage.setItem('palette', JSON.stringify(palette));
}

function updatePaletteTable() {
    const tbody = document.querySelector('#paletteTable tbody');
    tbody.innerHTML = '';
    Object.entries(palette).forEach(([key, color], index) => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td class="border-b p-3 text-center text-gray-700">${key}</td>
            <td class="border-b p-3">
                <button class="color-btn" style="background-color: rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]});" title="–ò–∑–º–µ–Ω–∏—Ç—å —Ü–≤–µ—Ç"></button>
            </td>
            <td class="border-b p-3">
                <button class="delete-btn" title="–£–¥–∞–ª–∏—Ç—å —Ü–≤–µ—Ç">–£–¥–∞–ª–∏—Ç—å</button>
            </td>
        `;
        row.querySelector('.color-btn').addEventListener('click', () => changeColor(index));
        row.querySelector('.delete-btn').addEventListener('click', () => removeSpecificColor(key));
        tbody.appendChild(row);
    });
}

function addColor() {
    if (Object.keys(palette).length >= 20) {
        alert('–ú–∞–∫—Å–∏–º—É–º 20 —Ü–≤–µ—Ç–æ–≤!');
        return;
    }
    const newKey = (Object.keys(palette).length + 1).toString();
    palette[newKey] = AVAILABLE_COLORS[colorIndex % AVAILABLE_COLORS.length];
    colorIndex++;
    updatePaletteTable();
    savePalette();
}

function removeColor() {
    if (Object.keys(palette).length <= 1) {
        alert('–ú–∏–Ω–∏–º—É–º 1 —Ü–≤–µ—Ç!');
        return;
    }
    const keys = Object.keys(palette);
    delete palette[keys[keys.length - 1]];
    updatePaletteTable();
    savePalette();
}

function removeSpecificColor(key) {
    if (Object.keys(palette).length <= 1) {
        alert('–ú–∏–Ω–∏–º—É–º 1 —Ü–≤–µ—Ç!');
        return;
    }
    delete palette[key];
    const newPalette = {};
    Object.values(palette).forEach((color, index) => {
        newPalette[(index + 1).toString()] = color;
    });
    palette = newPalette;
    updatePaletteTable();
    savePalette();
}

function changeColor(row) {
    const key = Object.keys(palette)[row];
    const modal = document.createElement('div');
    modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
    modal.innerHTML = `
        <div class="bg-white p-6 rounded-lg max-w-sm w-full">
            <h3 class="text-lg font-semibold mb-4">–í—ã–±–æ—Ä —Ü–≤–µ—Ç–∞ –¥–ª—è –∫–ª—é—á–∞ ${key}</h3>
            <input type="color" id="colorPicker" value="${rgbToHex(palette[key])}" class="w-full h-12 mb-4">
            <label class="block text-sm font-medium mb-1">–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å: <span id="opacityValue">${palette[key][3]}</span></label>
            <input type="range" id="opacitySlider" min="0" max="1" step="0.01" value="${palette[key][3]}" class="w-full mb-4">
            <div class="flex justify-end gap-3">
                <button id="cancelBtn" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">–û—Ç–º–µ–Ω–∞</button>
                <button id="saveColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    document.getElementById('opacitySlider').addEventListener('input', (e) => {
        document.getElementById('opacityValue').textContent = e.target.value;
    });
    document.getElementById('saveColorBtn').addEventListener('click', () => {
        const color = hexToRgb(document.getElementById('colorPicker').value);
        const opacity = parseFloat(document.getElementById('opacitySlider').value);
        palette[key] = [...color, opacity];
        updatePaletteTable();
        savePalette();
        document.body.removeChild(modal);
    });
    document.getElementById('cancelBtn').addEventListener('click', () => {
        document.body.removeChild(modal);
    });
}

function changeBackgroundColor() {
    const modal = document.createElement('div');
    modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
    modal.innerHTML = `
        <div class="bg-white p-6 rounded-lg max-w-sm w-full">
            <h3 class="text-lg font-semibold mb-4">–í—ã–±–æ—Ä —Ü–≤–µ—Ç–∞ —Ñ–æ–Ω–∞</h3>
            <input type="color" id="backgroundColorPicker" value="${rgbToHex(backgroundColor)}" class="w-full h-12 mb-4">
            <label class="block text-sm font-medium mb-1">–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å: <span id="backgroundOpacityValue">${backgroundColor[3]}</span></label>
            <input type="range" id="backgroundOpacitySlider" min="0" max="1" step="0.01" value="${backgroundColor[3]}" class="w-full mb-4">
            <div class="flex justify-end gap-3">
                <button id="cancelBackgroundBtn" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">–û—Ç–º–µ–Ω–∞</button>
                <button id="saveBackgroundColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    document.getElementById('backgroundOpacitySlider').addEventListener('input', (e) => {
        document.getElementById('backgroundOpacityValue').textContent = e.target.value;
    });
    document.getElementById('saveBackgroundColorBtn').addEventListener('click', () => {
        const color = hexToRgb(document.getElementById('backgroundColorPicker').value);
        const opacity = parseFloat(document.getElementById('backgroundOpacitySlider').value);
        backgroundColor = [...color, opacity];
        localStorage.setItem('backgroundColor', JSON.stringify(backgroundColor));
        document.body.removeChild(modal);
        generate();
    });
    document.getElementById('cancelBackgroundBtn').addEventListener('click', () => {
        document.body.removeChild(modal);
    });
}

function rgbToHex([r, g, b]) {
    return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
}

function hexToRgb(hex) {
    const bigint = parseInt(hex.slice(1), 16);
    return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
}

function formatTime(seconds) {
    const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
    const secs = (seconds % 60).toString().padStart(2, '0');
    return `${mins}:${secs}`;
}

function updateRecordTimer() {
    if (isRecording) {
        const elapsed = Math.floor((Date.now() - recordStartTime) / 1000);
        document.getElementById('recordTimer').textContent = `–ó–∞–ø–∏—Å—å: ${formatTime(elapsed)}`;
        if (elapsed >= MAX_RECORDING_DURATION) {
            stopRecording();
            alert(`–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑–∞–ø–∏—Å–∏ (${MAX_RECORDING_DURATION} —Å–µ–∫—É–Ω–¥) –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞.`);
        }
    }
}

function resetRecordTimer() {
    document.getElementById('recordTimer').textContent = '–ó–∞–ø–∏—Å—å: 00:00';
    if (recordTimerId) {
        clearInterval(recordTimerId);
        recordTimerId = null;
    }
}

// --------- NEW: Image Color Extraction Logic ---------

document.getElementById('imageInput').addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
            // Show preview
            const previewContainer = document.getElementById('sourceImageContainer');
            const previewImg = document.getElementById('sourceImagePreview');
            previewImg.src = img.src;
            previewContainer.classList.remove('hidden');

            // Extract colors
            const extractedPalette = extractPaletteFromImage(img, 9); // Extract up to 9 colors
            applyExtractedPalette(extractedPalette);
            generate(); // Auto-generate after loading
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
});

function extractPaletteFromImage(image, maxColors) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // Scale down for performance (max 100px)
    const scale = Math.min(1, 100 / Math.max(image.width, image.height));
    canvas.width = image.width * scale;
    canvas.height = image.height * scale;
    
    ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
    
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
    const colorCounts = {};
    const quantization = 24; // Combine similar colors

    for (let i = 0; i < imageData.length; i += 4) {
        const r = Math.floor(imageData[i] / quantization) * quantization;
        const g = Math.floor(imageData[i + 1] / quantization) * quantization;
        const b = Math.floor(imageData[i + 2] / quantization) * quantization;
        const a = imageData[i + 3];

        // Skip transparent or very white/black pixels (optional filter for better vibrancy)
        if (a < 128) continue;
        
        const key = `${r},${g},${b}`;
        colorCounts[key] = (colorCounts[key] || 0) + 1;
    }

    // Sort by frequency
    const sortedColors = Object.keys(colorCounts).sort((a, b) => colorCounts[b] - colorCounts[a]);
    
    // Select distinct colors
    const distinctColors = [];
    const minDistance = 60; // Minimum distance between colors to be considered distinct

    for (const colorStr of sortedColors) {
        if (distinctColors.length >= maxColors) break;

        const [r, g, b] = colorStr.split(',').map(Number);
        
        let isDistinct = true;
        for (const existing of distinctColors) {
            const dist = Math.sqrt(
                Math.pow(r - existing[0], 2) +
                Math.pow(g - existing[1], 2) +
                Math.pow(b - existing[2], 2)
            );
            if (dist < minDistance) {
                isDistinct = false;
                break;
            }
        }

        if (isDistinct) {
            distinctColors.push([r, g, b, 1]);
        }
    }
    
    // Ensure we have at least some colors, if not, take top ones even if similar
    if (distinctColors.length < 3) {
         for (const colorStr of sortedColors) {
            if (distinctColors.length >= 7) break;
            const [r, g, b] = colorStr.split(',').map(Number);
            distinctColors.push([r, g, b, 1]);
         }
    }

    return distinctColors;
}

function applyExtractedPalette(colors) {
    palette = {};
    colors.forEach((color, index) => {
        palette[(index + 1).toString()] = color;
    });
    updatePaletteTable();
    savePalette();
}

// -----------------------------------------------------

function generate() {
    stopAnimation();
    stopFullAnimation();
    stopRecording();
    const modeMap = {
        '–õ–∏–Ω–∏–∏': 'Lines',
        '–¢–æ—á–∫–∏': 'Dots',
        '–§–∏–≥—É—Ä—ã': 'Shapes',
        '–°–º–µ—à–∞–Ω–Ω—ã–π': 'Mixed',
        '–°–ø–∏—Ä–∞–ª—å': 'Spiral',
        '–û—Ä–±–∏—Ç—ã': 'Orbit',
        '–¢–æ—á–∫–∏ –≤ –§–∏–≥—É—Ä—ã': 'DotToShape',
        '–¢–æ—á–∫–∏ –≤ –°–º–µ—à–∞–Ω–Ω—ã–π': 'DotsToMixed'
    };
    const mode = modeMap[document.getElementById('modeCombo').value];
    const elements = parseInt(document.getElementById('elementSlider').value);
    const slices = parseInt(document.getElementById('slicesSlider').value);
    generator = new KaleidoGenerator(MAIN_PX, palette, mode, 12, elements, slices);
    const canvas = document.getElementById('previewCanvas');
    canvas.width = CANVAS_PX;
    canvas.height = CANVAS_PX;
    generator.generate(canvas);
    currentImage = canvas;
}

function animate() {
    if (!currentImage || !generator) {
        alert('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ —É–∑–æ—Ä!');
        return;
    }
    isAnimating = !isAnimating;
    const animateBtn = document.getElementById('animateBtn');
    if (isAnimating) {
        animateBtn.textContent = '–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å';
        animateBtn.classList.add('active');
        startTime = Date.now();
        requestAnimationFrame(animateLoop);
    } else {
        animateBtn.textContent = '–ê–Ω–∏–º–∏—Ä–æ–≤–∞—Ç—å';
        animateBtn.classList.remove('active');
        cancelAnimationFrame(animationFrameId);
    }
}

function animateLoop() {
    if (!isAnimating || !generator) {
        return;
    }
    const canvas = document.getElementById('previewCanvas');
    if (!canvas) {
        stopAnimation();
        return;
    }
    const ctx = canvas.getContext('2d');
    if (!ctx) {
        stopAnimation();
        return;
    }
    canvas.width = isRecording && isMobile ? MOBILE_RECORDING_PX : CANVAS_PX;
    canvas.height = isRecording && isMobile ? MOBILE_RECORDING_PX : CANVAS_PX;
    const elapsedTime = (Date.now() - startTime) / 1000;
    generator.size = isRecording && isMobile ? MOBILE_RECORDING_PX : CANVAS_PX;
    generator.generate(canvas, true, elapsedTime);
    generator.size = CANVAS_PX;
    currentImage = canvas;
    animationFrameId = requestAnimationFrame(animateLoop);
}

function stopAnimation() {
    if (isAnimating) {
        isAnimating = false;
        const animateBtn = document.getElementById('animateBtn');
        animateBtn.textContent = '–ê–Ω–∏–º–∏—Ä–æ–≤–∞—Ç—å';
        animateBtn.classList.remove('active');
        cancelAnimationFrame(animationFrameId);
    }
}

function openFullImage() {
    if (!currentImage || !generator) {
        alert('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ —É–∑–æ—Ä!');
        return;
    }
    stopAnimation();
    const modal = document.getElementById('imageModal');
    const fullCanvas = document.getElementById('fullCanvas');
    fullCanvas.width = CANVAS_PX;
    fullCanvas.height = CANVAS_PX;
    const gen = new KaleidoGenerator(MAIN_PX, palette,
        document.getElementById('modeCombo').value === '–õ–∏–Ω–∏–∏' ? 'Lines' :
        document.getElementById('modeCombo').value === '–¢–æ—á–∫–∏' ? 'Dots' :
        document.getElementById('modeCombo').value === '–§–∏–≥—É—Ä—ã' ? 'Shapes' :
        document.getElementById('modeCombo').value === '–°–º–µ—à–∞–Ω–Ω—ã–π' ? 'Mixed' :
        document.getElementById('modeCombo').value === '–°–ø–∏—Ä–∞–ª—å' ? 'Spiral' :
        document.getElementById('modeCombo').value === '–û—Ä–±–∏—Ç—ã' ? 'Orbit' :
        document.getElementById('modeCombo').value === '–¢–æ—á–∫–∏ –≤ –§–∏–≥—É—Ä—ã' ? 'DotToShape' :
        'DotsToMixed',
        12,
        parseInt(document.getElementById('elementSlider').value),
        parseInt(document.getElementById('slicesSlider').value)
    );
    isFullAnimating = true;
    fullStartTime = Date.now();
    gen.generate(fullCanvas, true, 0);
    modal.classList.add('show');
    requestAnimationFrame(() => animateFullLoop(gen));
}

function animateFullLoop(generator) {
    if (!isFullAnimating || !generator) {
        return;
    }
    const fullCanvas = document.getElementById('fullCanvas');
    if (!fullCanvas) {
        stopFullAnimation();
        return;
    }
    const ctx = fullCanvas.getContext('2d');
    if (!ctx) {
        stopFullAnimation();
        return;
    }
    fullCanvas.width = CANVAS_PX;
    const elapsedTime = (Date.now() - fullStartTime) / 1000;
    generator.generate(fullCanvas, true, elapsedTime);
    fullAnimationFrameId = requestAnimationFrame(() => animateFullLoop(generator));
}

function stopFullAnimation() {
    if (isFullAnimating) {
        isFullAnimating = false;
        cancelAnimationFrame(fullAnimationFrameId);
    }
}

function save() {
    stopAnimation();
    if (!currentImage || !generator) {
        alert('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ —É–∑–æ—Ä!');
        return;
    }
    const fullCanvas = document.createElement('canvas');
    fullCanvas.width = CANVAS_PX;
    fullCanvas.height = CANVAS_PX;
    const gen = new KaleidoGenerator(MAIN_PX, palette,
        document.getElementById('modeCombo').value === '–õ–∏–Ω–∏–∏' ? 'Lines' :
        document.getElementById('modeCombo').value === '–¢–æ—á–∫–∏' ? 'Dots' :
        document.getElementById('modeCombo').value === '–§–∏–≥—É—Ä—ã' ? 'Shapes' :
        document.getElementById('modeCombo').value === '–°–º–µ—à–∞–Ω–Ω—ã–π' ? 'Mixed' :
        document.getElementById('modeCombo').value === '–°–ø–∏—Ä–∞–ª—å' ? 'Spiral' :
        document.getElementById('modeCombo').value === '–û—Ä–±–∏—Ç—ã' ? 'Orbit' :
        document.getElementById('modeCombo').value === '–¢–æ—á–∫–∏ –≤ –§–∏–≥—É—Ä—ã' ? 'DotToShape' :
        'DotsToMixed',
        12,
        parseInt(document.getElementById('elementSlider').value),
        parseInt(document.getElementById('slicesSlider').value)
    );
    gen.generate(fullCanvas);
    const link = document.createElement('a');
    link.download = '–∫–∞–ª–µ–π–¥–æ—Å–∫–æ–ø.png';
    link.href = fullCanvas.toDataURL('image/png');
    link.click();
}

function startStopRecording() {
    if (!currentImage || !generator) {
        alert('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ —É–∑–æ—Ä!');
        return;
    }
    const recordBtn = document.getElementById('recordBtn');
    const downloadVideoBtn = document.getElementById('downloadVideoBtn');
    const mimeType = MediaRecorder.isTypeSupported('video/mp4;codecs=avc1.4D401E') ? 'video/mp4;codecs=avc1.4D401E' : 'video/webm;codecs=vp9';
    const fileExtension = mimeType.startsWith('video/mp4') ? 'mp4' : 'webm';
    if (!isRecording) {
        if (!MediaRecorder.isTypeSupported(mimeType)) {
            alert(`–§–æ—Ä–º–∞—Ç ${fileExtension.toUpperCase()} –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤–∞—à–∏–º –±—Ä–∞—É–∑–µ—Ä–æ–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π –±—Ä–∞—É–∑–µ—Ä, –Ω–∞–ø—Ä–∏–º–µ—Ä Chrome.`);
            return;
        }
        if (!isAnimating) {
            isAnimating = true;
            startTime = Date.now();
            requestAnimationFrame(animateLoop);
            document.getElementById('animateBtn').textContent = '–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å';
            document.getElementById('animateBtn').classList.add('active');
        }
        recordedChunks = [];
        const canvas = document.getElementById('previewCanvas');
        canvas.width = isMobile ? MOBILE_RECORDING_PX : CANVAS_PX;
        canvas.height = isMobile ? MOBILE_RECORDING_PX : CANVAS_PX;
        const stream = canvas.captureStream(isMobile ? 30 : 60);
        try {
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: mimeType,
                videoBitsPerSecond: isMobile ? 10000000 : 20000000
            });
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            mediaRecorder.onstop = () => {
                downloadVideoBtn.disabled = recordedChunks.length === 0;
                resetRecordTimer();
            };
            mediaRecorder.onerror = (event) => {
                console.error('MediaRecorder error:', event.error);
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø–∏—Å–∏ –≤–∏–¥–µ–æ: ' + event.error.message);
                stopRecording();
            };
            mediaRecorder.start();
            isRecording = true;
            recordBtn.textContent = '–°—Ç–æ–ø –∑–∞–ø–∏—Å—å';
            recordBtn.classList.add('active');
            recordStartTime = Date.now();
            recordTimerId = setInterval(updateRecordTimer, 1000);
        } catch (e) {
            console.error('Failed to start recording:', e);
            alert('–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å. –§–æ—Ä–º–∞—Ç MP4 –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –±—Ä–∞—É–∑–µ—Ä Chrome.');
        }
    } else {
        mediaRecorder.stop();
        isRecording = false;
        recordBtn.textContent = '–°—Ç–∞—Ä—Ç –∑–∞–ø–∏—Å—å';
        recordBtn.classList.remove('active');
    }
}

function downloadVideo() {
    if (recordedChunks.length === 0) {
        alert('–ù–µ—Ç –∑–∞–ø–∏—Å–∞–Ω–Ω–æ–≥–æ –≤–∏–¥–µ–æ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è!');
        return;
    }
    const mimeType = MediaRecorder.isTypeSupported('video/mp4;codecs=avc1.4D401E') ? 'video/mp4' : 'video/webm';
    const fileExtension = mimeType.startsWith('video/mp4') ? 'mp4' : 'webm';
    const blob = new Blob(recordedChunks, { type: mimeType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `–∫–∞–ª–µ–π–¥–æ—Å–∫–æ–ø.${fileExtension}`;
    link.click();
    URL.revokeObjectURL(url);
    recordedChunks = [];
    document.getElementById('downloadVideoBtn').disabled = true;
}

document.getElementById('elementSlider').addEventListener('input', (e) => {
    document.getElementById('elementValue').textContent = e.target.value;
    stopAnimation();
    stopFullAnimation();
    stopRecording();
});

document.getElementById('slicesSlider').addEventListener('input', (e) => {
    document.getElementById('slicesValue').textContent = e.target.value;
    stopAnimation();
    stopFullAnimation();
    stopRecording();
});

document.getElementById('animationSpeedSlider').addEventListener('input', (e) => {
    ANIMATION_SPEED = parseFloat(e.target.value);
    document.getElementById('animationSpeedValue').textContent = ANIMATION_SPEED.toFixed(2);
});

document.getElementById('modeCombo').addEventListener('change', () => {
    const selectedValue = document.getElementById('modeCombo').value;
    if (selectedValue === 'Crystal') {
        window.location.href = 'kalei.html';
    } else if (selectedValue === 'Sphere') {
        window.location.href = 'test.html';
    } else if (selectedValue === 'Kovrov') {
        window.location.href = 'kovrov.html';
    } else {
        stopAnimation();
        stopFullAnimation();
        stopRecording();
    }
});

document.getElementById('addColorBtn').addEventListener('click', () => {
    addColor();
    stopAnimation();
    stopFullAnimation();
    stopRecording();
});

document.getElementById('removeColorBtn').addEventListener('click', () => {
    removeColor();
    stopAnimation();
    stopFullAnimation();
    stopRecording();
});

document.getElementById('generateBtn').addEventListener('click', generate);
document.getElementById('animateBtn').addEventListener('click', animate);
document.getElementById('recordBtn').addEventListener('click', startStopRecording);
document.getElementById('downloadVideoBtn').addEventListener('click', downloadVideo);
document.getElementById('viewBtn').addEventListener('click', openFullImage);
document.getElementById('saveBtn').addEventListener('click', save);
document.getElementById('closeModalBtn').addEventListener('click', () => {
    stopFullAnimation();
    document.getElementById('imageModal').classList.remove('show');
});
document.getElementById('home').addEventListener('click', () => {
    stopAnimation();
    stopFullAnimation();
    stopRecording();
    window.location.href = 'index.html';
});
document.getElementById('changeBackgroundColorBtn').addEventListener('click', changeBackgroundColor);

function stopRecording() {
    if (isRecording) {
        mediaRecorder.stop();
        isRecording = false;
        document.getElementById('recordBtn').textContent = '–°—Ç–∞—Ä—Ç –∑–∞–ø–∏—Å—å';
        document.getElementById('recordBtn').classList.remove('active');
        document.getElementById('downloadVideoBtn').disabled = recordedChunks.length === 0;
        resetRecordTimer();
    }
}

updatePaletteTable();
loadBackgroundColor();
    </script>
</body>
</html>
