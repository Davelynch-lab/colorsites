<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –°–∏–≥–Ω–∞—Ç—É—Ä Mini</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #0f172a;
            color: #e2e8f0;
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* Glassmorphism */
        .glass-card {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        /* Sliders */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #facc15; /* Yellow thumb for signature theme */
            cursor: pointer;
            margin-top: -5px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #334155;
            border-radius: 2px;
        }

        canvas {
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            border-radius: 12px;
        }

        .blob {
            position: absolute;
            filter: blur(50px);
            z-index: -1;
            opacity: 0.3;
        }
        
        .color-chip:hover {
            transform: translateY(-2px) scale(1.1);
        }
    </style>
</head>
<body class="antialiased pb-10">

    <div class="blob bg-yellow-600 w-64 h-64 rounded-full top-10 left-10"></div>
    <div class="blob bg-indigo-600 w-72 h-72 rounded-full bottom-20 right-10"></div>

    <div class="container mx-auto p-4 max-w-5xl relative z-10">
        
        <header class="text-center mb-6 pt-4">
            <h1 class="text-3xl md:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-yellow-200 via-orange-300 to-amber-200 tracking-tight mb-1">
                Signatura<span class="font-light text-white">Dobra</span>
            </h1>
            <p class="text-slate-400 text-xs md:text-sm">–°–æ–∑–¥–∞–Ω–∏–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏—Ö —Å–∏–≥–Ω–∞—Ç—É—Ä</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-6">
            
            <div class="lg:col-span-4 space-y-4">
                
                <div class="glass-card p-5 rounded-xl">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-lg font-bold text-white">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h2>
                        <span id="modeDisplay" class="text-[10px] font-mono text-yellow-200 bg-yellow-900/40 px-2 py-0.5 rounded">–õ–∏–Ω–∏–∏</span>
                    </div>
                    
                    <div class="space-y-4">
                        <select id="modeCombo" class="w-full bg-slate-800 border border-slate-600 text-white text-sm rounded-lg p-2.5 focus:border-yellow-500 outline-none">
                            <option>–õ–∏–Ω–∏–∏</option>
                            <option>–¢–æ—á–∫–∏</option>
                            <option>–§–∏–≥—É—Ä—ã</option>
                            <!-- <option>–°–º–µ—à–∞–Ω–Ω—ã–π</option>
                            <option>–°–ø–∏—Ä–∞–ª—å</option>
                            <option>–û—Ä–±–∏—Ç—ã</option> -->
                            <option>–¢–æ—á–∫–∏ –≤ –§–∏–≥—É—Ä—ã</option>
                        </select>

                        <div class="space-y-1">
                            <div class="flex justify-between text-xs text-slate-400">
                                <span>–°–ª–æ–∂–Ω–æ—Å—Ç—å</span> <span id="elementValue" class="text-yellow-500 font-mono">300</span>
                            </div>
                            <input type="range" id="elementSlider" min="50" max="600" value="300" class="w-full">
                        </div>

                        <div class="space-y-1">
                            <div class="flex justify-between text-xs text-slate-400">
                                <span>–õ—É—á–∏</span> <span id="slicesValue" class="text-yellow-500 font-mono">13</span>
                            </div>
                            <input type="range" id="slicesSlider" min="3" max="30" value="13" class="w-full">
                        </div>

                        <div class="space-y-1">
                            <div class="flex justify-between text-xs text-slate-400">
                                <span>–°–∫–æ—Ä–æ—Å—Ç—å</span> <span id="animationSpeedValue" class="text-yellow-500 font-mono">0.1</span>
                            </div>
                            <input type="range" id="animationSpeedSlider" min="0.05" max="0.5" step="0.01" value="0.1" class="w-full">
                        </div>
                    </div>
                </div>

                <div class="glass-card p-5 rounded-xl">
                    <h2 class="text-lg font-bold text-white mb-3">–¶–≤–µ—Ç–∞</h2>
                    
                    <div class="mb-3 relative group">
                        <input type="file" id="imageInput" accept="image/*" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-20">
                        <div class="border-2 border-dashed border-slate-600 rounded-lg p-3 text-center group-hover:border-yellow-500 transition-colors">
                            <span class="text-xl">üì∑</span>
                            <span class="text-xs text-slate-400 block mt-1">–ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–æ—Ç–æ –¥–ª—è –ø–∞–ª–∏—Ç—Ä—ã</span>
                        </div>
                    </div>
                    
                    <div id="paletteContainer" class="flex flex-wrap gap-2 min-h-[40px] mb-3"></div>

                    <div class="grid grid-cols-2 gap-2">
                        <button id="addColorBtn" class="bg-slate-700 hover:bg-slate-600 text-xs text-white py-2 rounded transition-colors">+ –¶–≤–µ—Ç</button>
                        <button id="changeBackgroundColorBtn" class="bg-slate-700 hover:bg-slate-600 text-xs text-white py-2 rounded transition-colors">üé® –§–æ–Ω</button>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-8 space-y-4">
                <div class="glass-card p-4 rounded-xl flex flex-col items-center relative overflow-hidden">
                    <div id="recordTimer" class="absolute top-4 right-4 z-20 font-mono text-red-500 font-bold opacity-0 transition-opacity text-sm bg-black/50 px-2 rounded">REC 00:00</div>
                    
                    <div class="w-full max-w-[500px] aspect-square relative flex items-center justify-center bg-slate-900/50 rounded-lg border border-slate-700/50 shadow-inner">
                         <canvas id="previewCanvas" class="max-w-full max-h-full object-contain rounded-lg"></canvas>
                    </div>
                </div>

                <div class="glass-card p-4 rounded-xl">
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-2">
                        <button id="generateBtn" class="col-span-2 md:col-span-1 bg-gradient-to-r from-yellow-600 to-orange-600 hover:from-yellow-500 hover:to-orange-500 text-white font-bold py-2.5 px-4 rounded-lg shadow-lg transform active:scale-95 transition-all text-sm">
                            üí´ –°–æ–∑–¥–∞—Ç—å
                        </button>
                        
                        <button id="animateBtn" class="bg-slate-700 hover:bg-slate-600 text-white font-medium py-2.5 px-4 rounded-lg transition-colors text-sm border border-slate-600">
                            ‚ñ∂ –ê–Ω–∏–º–∞—Ü–∏—è
                        </button>
                        
                        <button id="recordBtn" class="bg-slate-700 hover:bg-slate-600 text-white font-medium py-2.5 px-4 rounded-lg transition-colors text-sm border border-slate-600 flex items-center justify-center gap-2 group">
                            <span class="w-2 h-2 rounded-full bg-red-500 group-hover:animate-pulse"></span> REC
                        </button>

                        <button id="downloadVideoBtn" class="bg-slate-800 text-slate-500 py-2.5 px-4 rounded-lg border border-slate-700 cursor-not-allowed transition-colors text-sm" disabled>
                            üì• –í–∏–¥–µ–æ
                        </button>

                        <button id="viewBtn" class="col-span-1 bg-slate-700 hover:bg-slate-600 text-white py-2.5 px-4 rounded-lg transition-colors text-sm border border-slate-600">
                           üîç Full
                        </button>

                        <button id="saveBtn" class="col-span-1 bg-slate-700 hover:bg-slate-600 text-white py-2.5 px-4 rounded-lg transition-colors text-sm border border-slate-600">
                           üíæ PNG
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="imageModal" class="fixed inset-0 bg-black/95 backdrop-blur-xl hidden flex items-center justify-center z-50 transition-opacity duration-300 opacity-0">
        <div class="relative w-full h-full flex flex-col items-center justify-center p-2">
            <canvas id="fullCanvas" class="max-h-[80vh] max-w-[95vw] object-contain shadow-2xl rounded-lg border border-white/10"></canvas>
            <button id="closeModalBtn" class="mt-4 bg-white/10 hover:bg-white/20 text-white px-6 py-2 rounded-full backdrop-blur-md transition-all text-sm border border-white/10">
                –ó–∞–∫—Ä—ã—Ç—å –ø—Ä–æ—Å–º–æ—Ç—Ä
            </button>
        </div>
    </div>

    <div id="sourceImageContainer" class="hidden"><img id="sourceImagePreview"></div>

    <script>
        // CONFIG
        const DPI = 2; // Reduced slightly for performance in mini version
        const CANVAS_SIZE = 800; // Fixed internal resolution
        let ANIMATION_SPEED = 0.1;
        let backgroundColor = [15, 23, 42, 1];

        // WATERMARK CONFIG
        const WATERMARK_TEXT = "¬©signatura_dobra";
        // Light yellow: rgb(255, 255, 224), low opacity
        const WATERMARK_COLOR = "rgba(255, 255, 224, 0.18)"; 

        const DEFAULT_PALETTE = {
            '1': [250, 204, 21, 1],   // Yellow
            '2': [249, 115, 22, 1],   // Orange
            '3': [234, 179, 8, 1],    // Dark Yellow
            '4': [255, 255, 255, 1]   // White
        };

        const AVAILABLE_COLORS = [
            [255, 255, 224, 1], [255, 215, 0, 1], [255, 140, 0, 1], [240, 248, 255, 1]
        ];

        let colorIndex = 0;
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent);

        // --- CORE GENERATOR CLASS ---
        class KaleidoGenerator {
            constructor(size_px, palette, mode = 'Lines', sectors = 12, elements = 300) {
                this.size = size_px;
                this.palette = Object.values(palette);
                this.mode = mode;
                this.sectors = sectors;
                this.elements = Math.min(elements, 500);
                this.elementsData = [];
                this.initElements();
            }

            initElements() {
                this.elementsData = [];
                const angle = 360 / this.sectors;
                
                // Unified generation logic for brevity in mini version
                for (let i = 0; i < this.elements; i++) {
                    const base = {
                        r: Math.random(),
                        theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                        colorIdx: Math.floor(Math.random() * this.palette.length),
                        size: Math.random() * 10 + 2,
                        r2: Math.random(),
                        theta2: (Math.random() * angle - angle / 2) * Math.PI / 180,
                        width: Math.random() * 3 + 1
                    };
                    
                    // Specific logic adjustments
                    if (this.mode === 'Spiral') {
                        base.theta_start = (Math.random() * angle - angle / 2) * Math.PI / 180;
                    }
                    this.elementsData.push(base);
                }
            }

            // INTERNAL: Draw the single wedge content
            _makeKaleidoSquare(animate, animationTime) {
                const canvas = document.createElement('canvas');
                canvas.width = this.size;
                canvas.height = this.size;
                const ctx = canvas.getContext('2d');
                const radius = this.size / 2;
                const cx = radius, cy = radius;
                const t = animate ? animationTime * ANIMATION_SPEED : 0;

                // Draw based on mode
                this.elementsData.forEach((d, i) => {
                    const color = this.palette[d.colorIdx];
                    const nextColor = this.palette[(d.colorIdx + 1) % this.palette.length];
                    const factor = (Math.sin(t + i * 0.3) + 1) / 2;
                    
                    // Simple color interpolation
                    const r = Math.round(color[0] * (1-factor) + nextColor[0] * factor);
                    const g = Math.round(color[1] * (1-factor) + nextColor[1] * factor);
                    const b = Math.round(color[2] * (1-factor) + nextColor[2] * factor);
                    const a = color[3];
                    const style = `rgba(${r},${g},${b},${a})`;
                    
                    ctx.fillStyle = style;
                    ctx.strokeStyle = style;
                    ctx.lineWidth = d.width;

                    const thetaOffset = Math.sin(t + i * 0.2) * 0.3;

                    if (this.mode === 'Lines' || this.mode === 'Mixed' && i % 3 === 0) {
                        ctx.beginPath();
                        ctx.moveTo(cx + d.r * radius * Math.cos(d.theta + thetaOffset), cy + d.r * radius * Math.sin(d.theta + thetaOffset));
                        ctx.lineTo(cx + d.r2 * radius * Math.cos(d.theta2 + thetaOffset), cy + d.r2 * radius * Math.sin(d.theta2 + thetaOffset));
                        ctx.stroke();
                    } else if (this.mode === 'Dots' || this.mode === 'Mixed' && i % 3 === 1) {
                        ctx.beginPath();
                        ctx.arc(cx + d.r * radius * Math.cos(d.theta + thetaOffset), cy + d.r * radius * Math.sin(d.theta + thetaOffset), d.size, 0, Math.PI*2);
                        ctx.fill();
                    } else if (this.mode === 'Shapes' || this.mode === 'Mixed') {
                        const x = cx + d.r * radius * Math.cos(d.theta + thetaOffset);
                        const y = cy + d.r * radius * Math.sin(d.theta + thetaOffset);
                        ctx.fillRect(x - d.size, y - d.size, d.size*2, d.size*2);
                    } else if (this.mode === 'Spiral') {
                        // Simplified spiral
                         for (let rad = 0; rad < radius; rad += 5) {
                            const th = d.theta_start + rad * 0.05 + t * 0.5;
                            ctx.beginPath();
                            ctx.arc(cx + rad * Math.cos(th), cy + rad * Math.sin(th), Math.max(1, 3 + Math.sin(rad*0.1)*2), 0, Math.PI*2);
                            ctx.fill();
                         }
                    }
                    // Add other modes logic as needed (simplified for Mini)
                });
                return canvas;
            }

            // WATERMARK FUNCTION
            _drawWatermark(ctx, width, height) {
                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.rotate(-Math.PI / 4); // 45 degree angle
                ctx.translate(-width / 2, -height / 2);

                ctx.font = `600 ${width / 35}px 'Inter', sans-serif`; // Responsive font size
                ctx.fillStyle = WATERMARK_COLOR;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                const stepX = width / 3; 
                const stepY = height / 5;
                
                // Draw grid pattern covering area even after rotation
                for (let x = -width; x < width * 2; x += stepX) {
                    for (let y = -height; y < height * 2; y += stepY) {
                        ctx.fillText(WATERMARK_TEXT, x, y);
                    }
                }
                ctx.restore();
            }

            generate(canvas, animate = false, animationTime = 0) {
                const ctx = canvas.getContext('2d');
                // Ensure dimensions match internal logic
                canvas.width = this.size;
                canvas.height = this.size;

                // 1. Draw Background
                ctx.fillStyle = `rgba(${backgroundColor[0]}, ${backgroundColor[1]}, ${backgroundColor[2]}, ${backgroundColor[3]})`;
                ctx.fillRect(0, 0, this.size, this.size);

                // 2. Generate Slice
                const wedge = this._makeKaleidoSquare(animate, animationTime);

                // 3. Draw Kaleidoscope Pattern (Kaleido logic)
                const radius = this.size / 2;
                const angle = 360 / this.sectors;
                const t = animate ? animationTime * ANIMATION_SPEED : 0;
                const rotationOffset = Math.sin(t) * 0.2;

                const patternCanvas = document.createElement('canvas');
                patternCanvas.width = this.size;
                patternCanvas.height = this.size;
                const pCtx = patternCanvas.getContext('2d');

                // Draw pattern onto a temp canvas first
                for (let i = 0; i < this.sectors; i++) {
                    pCtx.save();
                    pCtx.translate(radius, radius);
                    pCtx.rotate((angle * i + rotationOffset) * Math.PI / 180);
                    if (i % 2 === 1) pCtx.scale(-1, 1);
                    pCtx.drawImage(wedge, -radius, -radius);
                    pCtx.restore();
                }

                // Draw pattern to main canvas
                ctx.drawImage(patternCanvas, 0, 0);

                // 4. DRAW WATERMARK ON TOP (Protection Layer)
                this._drawWatermark(ctx, this.size, this.size);
            }
        }

        // --- APP STATE ---
        let palette = DEFAULT_PALETTE;
        let generator = null;
        let isAnimating = false;
        let animationFrameId = null;
        let startTime = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordTimerId = null;
        let recordStartTime = null;
        let isRecording = false;

        // --- UI FUNCTIONS ---
        function updatePaletteUI() {
            const container = document.getElementById('paletteContainer');
            container.innerHTML = '';
            Object.entries(palette).forEach(([key, color]) => {
                const chip = document.createElement('div');
                chip.className = 'color-chip relative w-8 h-8 rounded-full cursor-pointer border border-white/30 shadow-sm';
                chip.style.backgroundColor = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]})`;
                
                chip.onclick = () => {
                   const newHex = prompt("–í–≤–µ–¥–∏—Ç–µ HEX —Ü–≤–µ—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä #FF0000):");
                   if(newHex && /^#[0-9A-F]{6}$/i.test(newHex)) {
                       const bigint = parseInt(newHex.substring(1), 16);
                       const r = (bigint >> 16) & 255;
                       const g = (bigint >> 8) & 255;
                       const b = bigint & 255;
                       palette[key] = [r, g, b, 1];
                       updatePaletteUI();
                       generate();
                   }
                };
                
                // Right click to delete
                chip.oncontextmenu = (e) => {
                    e.preventDefault();
                    if(Object.keys(palette).length > 1) {
                        delete palette[key];
                        updatePaletteUI();
                        generate();
                    }
                };

                container.appendChild(chip);
            });
        }

        function generate() {
            stopAnimation();
            const modeMap = {
                '–õ–∏–Ω–∏–∏': 'Lines', '–¢–æ—á–∫–∏': 'Dots', '–§–∏–≥—É—Ä—ã': 'Shapes', '–°–º–µ—à–∞–Ω–Ω—ã–π': 'Mixed',
                '–°–ø–∏—Ä–∞–ª—å': 'Spiral', '–û—Ä–±–∏—Ç—ã': 'Orbit', '–¢–æ—á–∫–∏ –≤ –§–∏–≥—É—Ä—ã': 'DotToShape'
            };
            const mode = modeMap[document.getElementById('modeCombo').value] || 'Lines';
            document.getElementById('modeDisplay').textContent = document.getElementById('modeCombo').value;
            
            const elements = parseInt(document.getElementById('elementSlider').value);
            const slices = parseInt(document.getElementById('slicesSlider').value);

            generator = new KaleidoGenerator(CANVAS_SIZE, palette, mode, slices, elements);
            const canvas = document.getElementById('previewCanvas');
            // Preview size
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            generator.generate(canvas);
        }

        function animate() {
            if (!generator) return;
            const btn = document.getElementById('animateBtn');
            
            if (isAnimating) {
                isAnimating = false;
                cancelAnimationFrame(animationFrameId);
                btn.textContent = "‚ñ∂ –ê–Ω–∏–º–∞—Ü–∏—è";
                btn.classList.remove('bg-red-600');
                btn.classList.add('bg-slate-700');
            } else {
                isAnimating = true;
                startTime = Date.now();
                btn.textContent = "‚èπ –°—Ç–æ–ø";
                btn.classList.remove('bg-slate-700');
                btn.classList.add('bg-red-600');
                animateLoop();
            }
        }

        function animateLoop() {
            if (!isAnimating) return;
            const canvas = document.getElementById('previewCanvas');
            const time = (Date.now() - startTime) / 1000;
            generator.generate(canvas, true, time);
            animationFrameId = requestAnimationFrame(animateLoop);
        }

        function stopAnimation() {
            if (isAnimating) animate(); // Toggles off
        }

        // --- RECORDING ---
        function toggleRecording() {
            const btn = document.getElementById('recordBtn');
            const timer = document.getElementById('recordTimer');
            const downBtn = document.getElementById('downloadVideoBtn');

            if (isRecording) {
                // STOP
                if (mediaRecorder) mediaRecorder.stop();
                isRecording = false;
                clearInterval(recordTimerId);
                btn.innerHTML = '<span class="w-2 h-2 rounded-full bg-red-500 group-hover:animate-pulse"></span> REC';
                btn.classList.replace('bg-red-600', 'bg-slate-700');
                timer.classList.add('opacity-0');
                
                // Stop animation if it was started by recorder
                if(isAnimating) animate(); 

            } else {
                // START
                if (!isAnimating) animate(); // Force animation
                recordedChunks = [];
                const canvas = document.getElementById('previewCanvas');
                const stream = canvas.captureStream(30);
                
                try {
                    const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' : 'video/webm';
                    mediaRecorder = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 5000000 });
                    
                    mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
                    mediaRecorder.onstop = () => {
                        downBtn.disabled = false;
                        downBtn.classList.remove('cursor-not-allowed', 'bg-slate-800', 'text-slate-500');
                        downBtn.classList.add('bg-green-600', 'text-white', 'hover:bg-green-500');
                    };

                    mediaRecorder.start();
                    isRecording = true;
                    recordStartTime = Date.now();
                    
                    btn.innerHTML = '‚èπ –°—Ç–æ–ø';
                    btn.classList.replace('bg-slate-700', 'bg-red-600');
                    timer.classList.remove('opacity-0');
                    
                    recordTimerId = setInterval(() => {
                        const s = Math.floor((Date.now() - recordStartTime)/1000);
                        const m = Math.floor(s/60).toString().padStart(2,'0');
                        const sc = (s%60).toString().padStart(2,'0');
                        timer.textContent = `REC ${m}:${sc}`;
                        if(s > 60) toggleRecording(); // Max 1 min
                    }, 1000);

                } catch (e) {
                    alert("–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∑–∞–ø–∏—Å—å Canvas.");
                    isRecording = false;
                }
            }
        }

        // --- EXPORT ---
        function downloadVideo() {
            if (recordedChunks.length === 0) return;
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `signatura_${Date.now()}.webm`;
            a.click();
        }

        function savePNG() {
            const canvas = document.getElementById('previewCanvas');
            const link = document.createElement('a');
            link.download = `signatura_${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        // --- FULL SCREEN ---
        function openFull() {
            const modal = document.getElementById('imageModal');
            const fCanvas = document.getElementById('fullCanvas');
            modal.classList.remove('hidden');
            setTimeout(() => modal.classList.remove('opacity-0'), 10);
            
            // Generate high res static frame
            const tempGen = new KaleidoGenerator(1200, palette, generator.mode, generator.sectors, generator.elements);
            tempGen.elementsData = generator.elementsData; // Copy pattern
            tempGen.generate(fCanvas);
        }

        // --- EVENT LISTENERS ---
        document.getElementById('elementSlider').oninput = (e) => {
            document.getElementById('elementValue').textContent = e.target.value;
            generate();
        };
        document.getElementById('slicesSlider').oninput = (e) => {
            document.getElementById('slicesValue').textContent = e.target.value;
            generate();
        };
        document.getElementById('animationSpeedSlider').oninput = (e) => {
            ANIMATION_SPEED = parseFloat(e.target.value);
            document.getElementById('animationSpeedValue').textContent = e.target.value;
        };
        document.getElementById('modeCombo').onchange = generate;
        document.getElementById('addColorBtn').onclick = () => {
            if(Object.keys(palette).length < 8) {
                palette[Date.now()] = AVAILABLE_COLORS[colorIndex++ % 4];
                updatePaletteUI();
                generate();
            }
        };
        document.getElementById('generateBtn').onclick = generate;
        document.getElementById('animateBtn').onclick = animate;
        document.getElementById('recordBtn').onclick = toggleRecording;
        document.getElementById('downloadVideoBtn').onclick = downloadVideo;
        document.getElementById('saveBtn').onclick = savePNG;
        document.getElementById('viewBtn').onclick = openFull;
        document.getElementById('closeModalBtn').onclick = () => {
             document.getElementById('imageModal').classList.add('opacity-0');
             setTimeout(() => document.getElementById('imageModal').classList.add('hidden'), 300);
        };

        // Image extraction logic (simplified)
        document.getElementById('imageInput').onchange = (e) => {
            const file = e.target.files[0];
            if(file) {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const img = new Image();
                    img.onload = () => {
                        // Dummy palette extraction for mini version - just randomized variation
                        // In full version this does K-means or histogram analysis
                        palette = {};
                        for(let i=0; i<5; i++) {
                            palette[i] = [Math.random()*255|0, Math.random()*255|0, Math.random()*255|0, 1];
                        }
                        updatePaletteUI();
                        generate();
                    };
                    img.src = evt.target.result;
                };
                reader.readAsDataURL(file);
            }
        };

        // INIT
        updatePaletteUI();
        setTimeout(generate, 100);

    </script>
</body>
</html>
