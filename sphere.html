<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∫–∞–ª–µ–π–¥–æ—Å–∫–æ–ø–æ–≤ –≤ 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.138.0/build/three.module.js",
                "OrbitControls": "https://unpkg.com/three@0.138.0/examples/jsm/controls/OrbitControls.js"
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap');

        body {
            background: radial-gradient(circle at top left, #1e1b4b, #0f172a, #000000);
            background-attachment: fixed;
            min-height: 100vh;
            font-family: 'Inter', sans-serif;
            color: #e2e8f0;
        }

        /* –°–∫—Ä–æ–ª–ª–±–∞—Ä */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #0f172a; 
        }
        ::-webkit-scrollbar-thumb {
            background: #4c1d95; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6d28d9; 
        }

        #previewContainer, #fullContainer {
            width: 100%;
            /* –£–±—Ä–∞–ª–∏ max-width –¥–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç–∏ –≤ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–π –∫–æ–ª–æ–Ω–∫–µ */
            aspect-ratio: 1/1;
            margin: auto;
            position: relative;
        }
        
        #previewContainer::after {
            content: '';
            position: absolute;
            inset: -2px;
            background: linear-gradient(45deg, #7c3aed, #2563eb, #db2777);
            z-index: -1;
            border-radius: 50%;
            filter: blur(20px);
            opacity: 0.4;
            animation: pulse-glow 4s infinite alternate;
        }

        @keyframes pulse-glow {
            0% { opacity: 0.3; filter: blur(20px); }
            100% { opacity: 0.6; filter: blur(30px); }
        }

        #fullContainer {
            max-width: 800px;
        }

        canvas {
            border-radius: 50%; /* –î–µ–ª–∞–µ–º –∫–∞–Ω–≤–∞—Å –∫—Ä—É–≥–ª—ã–º –¥–ª—è —Å—Ñ–µ—Ä—ã */
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            width: 100% !important;
            height: auto !important;
        }
        
        /* –°—Ç–∏–ª–∏–∑–∞—Ü–∏—è Glassmorphism –∫–∞—Ä—Ç–æ—á–µ–∫ */
        .glass-card {
            background: rgba(255, 255, 255, 0.07);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s, box-shadow 0.3s, border-color 0.3s;
        }
        
        .glass-card:hover {
            border-color: rgba(255, 255, 255, 0.2);
            box-shadow: 0 10px 40px -10px rgba(0,0,0,0.5);
        }

        .color-btn {
            width: 100%;
            height: 40px;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .color-btn:hover {
            transform: scale(1.05);
            border-color: white;
        }

        .delete-btn {
            background: rgba(239, 68, 68, 0.2);
            color: #fca5a5;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            border: 1px solid rgba(239, 68, 68, 0.3);
            transition: all 0.3s;
        }
        .delete-btn:hover {
            background: rgba(239, 68, 68, 0.8);
            color: white;
        }

        /* –ö–∞—Å—Ç–æ–º–Ω—ã–µ –∏–Ω–ø—É—Ç—ã */
        input[type="range"] {
            -webkit-appearance: none;
            background: transparent;
            height: 6px;
            border-radius: 5px;
            background: rgba(255,255,255,0.1);
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #a855f7;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid #fff;
            box-shadow: 0 0 10px rgba(168, 85, 247, 0.5);
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            background: #d8b4fe;
        }

        select {
            background-color: rgba(0,0,0,0.3) !important;
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
        }
        select option {
            background-color: #1e1b4b;
            color: white;
        }

        #imageModal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            z-index: 50;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        #imageModal.show {
            display: flex;
        }

        details summary {
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 600;
            color: #e9d5ff;
            padding: 0.5rem;
            list-style: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        details summary::after {
            content: '+';
            font-size: 1.5rem;
            line-height: 1;
            transition: transform 0.3s;
        }
        details[open] summary::after {
            transform: rotate(45deg);
        }
        
        details p, details ul {
            margin-top: 0.5rem;
            color: #94a3b8;
            line-height: 1.6;
        }

        /* –ö–Ω–æ–ø–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π */
        .btn-primary {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }
        .btn-primary:hover {
            filter: brightness(1.1);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.6);
        }
        .btn-primary:active {
            transform: translateY(0);
        }
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: #e2e8f0;
            transition: all 0.3s;
        }
        .btn-secondary:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.3);
        }

        #animateBtn.active, #recordBtn.active {
            background: linear-gradient(135deg, #f43f5e 0%, #e11d48 100%);
            box-shadow: 0 0 15px rgba(244, 63, 94, 0.5);
            animation: pulse-red 2s infinite;
        }
        
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(225, 29, 72, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(225, 29, 72, 0); }
            100% { box-shadow: 0 0 0 0 rgba(225, 29, 72, 0); }
        }

        .action-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 1rem;
        }
        .action-buttons button {
            width: 100%;
            padding: 0.75rem;
            font-size: 0.9rem;
            border-radius: 12px;
            font-weight: 500;
        }
    </style>
</head>
<body class="antialiased">
    <div class="container mx-auto p-4 sm:p-6 md:p-8 max-w-[1600px]">
        
        <div class="text-center mb-8">
            <h1 class="text-4xl sm:text-6xl font-extrabold bg-clip-text text-transparent bg-gradient-to-r from-indigo-400 via-purple-400 to-pink-400 mb-2 drop-shadow-lg tracking-tight">
                3D KALEIDOSCOPE
            </h1>
            <p class="text-indigo-200/60 text-lg font-light tracking-wider">GENERATOR & ANIMATOR</p>
        </div>

        <div class="grid grid-cols-1 xl:grid-cols-4 gap-8 items-start">
            
            <div class="xl:col-span-1 space-y-6 order-2 xl:order-1">
                <details class="glass-card p-5 rounded-2xl">
                    <summary>–ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è</summary>
                    <div class="pl-4 pt-2 border-l-2 border-indigo-500/30 ml-2 mt-2">
                        <ul class="list-none space-y-2 text-sm">
                            <li>‚ú® <strong>–í—ã–±–æ—Ä:</strong> –¢–∏–ø –≥–µ–æ–º–µ—Ç—Ä–∏–∏.</li>
                            <li>üé® <strong>–ü–∞–ª–∏—Ç—Ä–∞:</strong> –°–≤–æ–∏ —Ü–≤–µ—Ç–∞.</li>
                            <li>üöÄ <strong>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è:</strong> –°–æ–∑–¥–∞—Ç—å —É–∑–æ—Ä.</li>
                            <li>üé• <strong>–ú–µ–¥–∏–∞:</strong> –ó–∞–ø–∏—Å—å –≤–∏–¥–µ–æ/—Ñ–æ—Ç–æ.</li>
                        </ul>
                    </div>
                </details>

                <div class="glass-card p-6 rounded-2xl">
                    <h2 class="text-lg font-semibold mb-4 text-indigo-200">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h2>
                    <div class="action-buttons flex flex-col gap-3">
                        <button id="generateBtn" class="btn-primary text-white">‚ú® –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å</button>
                        <button id="animateBtn" class="btn-primary text-white">‚ñ∂ –ê–Ω–∏–º–∏—Ä–æ–≤–∞—Ç—å</button>
                        <button id="recordBtn" class="btn-secondary text-white">‚è∫ –ó–∞–ø–∏—Å—å</button>
                        <button id="downloadVideoBtn" class="btn-secondary text-white" disabled>üíæ –°–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ</button>
                        <button id="viewBtn" class="btn-secondary text-white">üëÅÔ∏è –ù–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω</button>
                        <button id="saveBtn" class="btn-secondary text-white">üì∑ –°–∫—Ä–∏–Ω—à–æ—Ç</button>
                    </div>
                    <div class="mt-4 text-center">
                        <span id="recordTimer" class="text-indigo-300 font-mono text-sm bg-black/20 px-3 py-1 rounded-md">–ó–∞–ø–∏—Å—å: 00:00</span>
                    </div>
                </div>
            </div>

            <div class="xl:col-span-2 order-1 xl:order-2 sticky top-4 z-10">
                <div class="glass-card p-1 rounded-full flex justify-center items-center relative overflow-hidden group shadow-2xl border-2 border-white/10">
                    <div class="absolute top-0 left-0 w-full h-full bg-gradient-to-b from-indigo-500/10 to-purple-500/10 pointer-events-none rounded-full"></div>
                    
                    <div class="w-full relative">
                         <div id="previewContainer"></div>
                         <div class="absolute bottom-6 left-0 w-full text-center pointer-events-none opacity-0 group-hover:opacity-100 transition-opacity duration-500">
                             <span class="text-xs text-indigo-200/80 bg-black/40 px-3 py-1 rounded-full backdrop-blur-md">–í—Ä–∞—â–∞–π—Ç–µ –º—ã—à–∫–æ–π</span>
                         </div>
                    </div>
                </div>
            </div>

            <div class="xl:col-span-1 space-y-6 order-3 xl:order-3">
                
                <div class="glass-card p-6 rounded-2xl">
                    <h2 class="text-xl font-semibold mb-6 text-indigo-200 border-b border-white/10 pb-2">–ì–µ–æ–º–µ—Ç—Ä–∏—è</h2>
                    <div class="space-y-6">
                        <div>
                            <label class="block text-sm font-medium mb-2 text-indigo-300">–¢–∏–ø —É–∑–æ—Ä–∞</label>
                            <select id="modeCombo" class="w-full p-3 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition-all outline-none cursor-pointer">
                                <option>–õ–∏–Ω–∏–∏</option>
                                <option>–¢–æ—á–∫–∏</option>
                                <option>–§–∏–≥—É—Ä—ã</option>
                                <option>–°–º–µ—à–∞–Ω–Ω—ã–π</option>
                                <option>–°–ø–∏—Ä–∞–ª—å</option>
                                <option>–û—Ä–±–∏—Ç—ã</option>
                                <option>–¢–æ—á–∫–∏ –≤ –§–∏–≥—É—Ä—ã</option>
                                <option>–¢–æ—á–∫–∏ –≤ –°–º–µ—à–∞–Ω–Ω—ã–π</option>
                                <option value="Crystal">–ö—Ä–∏—Å—Ç–∞–ª–ª–∏—á–µ—Å–∫–æ–µ (–∏–∑–±—Ä–∞–Ω–Ω–æ–µ)</option>
                            </select>
                        </div>
                        
                        <div class="space-y-4">
                            <div>
                                <div class="flex justify-between mb-2">
                                    <label class="text-sm font-medium text-gray-400">–≠–ª–µ–º–µ–Ω—Ç—ã</label>
                                    <span id="elementValue" class="text-sm font-bold text-indigo-300">300</span>
                                </div>
                                <input type="range" id="elementSlider" min="100" max="1000" value="300" class="w-full">
                            </div>
                            
                            <div>
                                <div class="flex justify-between mb-2">
                                    <label class="text-sm font-medium text-gray-400">–°–µ–∫—Ç–æ—Ä–∞</label>
                                    <span id="slicesValue" class="text-sm font-bold text-indigo-300">13</span>
                                </div>
                                <input type="range" id="slicesSlider" min="3" max="40" value="13" class="w-full">
                            </div>

                            <div>
                                <div class="flex justify-between mb-2">
                                    <label class="text-sm font-medium text-gray-400">–°–∫–æ—Ä–æ—Å—Ç—å</label>
                                    <span id="animationSpeedValue" class="text-sm font-bold text-indigo-300">0.1</span>
                                </div>
                                <input type="range" id="animationSpeedSlider" min="0.05" max="0.5" step="0.01" value="0.1" class="w-full">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="glass-card p-6 rounded-2xl">
                    <div class="flex justify-between items-center mb-4 border-b border-white/10 pb-2">
                         <h2 class="text-xl font-semibold text-indigo-200">–ü–∞–ª–∏—Ç—Ä–∞</h2>
                    </div>
                   
                    <div class="overflow-hidden rounded-lg border border-white/10 mb-4 bg-black/20 max-h-40 overflow-y-auto custom-scrollbar">
                        <table id="paletteTable" class="w-full">
                            <thead>
                                <tr class="bg-white/5 text-left text-xs uppercase tracking-wider text-gray-400 sticky top-0 bg-[#1e1b4b]">
                                    <th class="p-3 font-medium">ID</th>
                                    <th class="p-3 font-medium">–¶–≤–µ—Ç</th>
                                    <th class="p-3 font-medium text-right">–î–µ–π—Å—Ç–≤–∏–µ</th>
                                </tr>
                            </thead>
                            <tbody class="text-sm divide-y divide-white/5"></tbody>
                        </table>
                    </div>

                    <div class="flex flex-col gap-2">
                        <div class="grid grid-cols-2 gap-2">
                             <button id="addColorBtn" class="btn-secondary py-2 px-2 rounded-lg text-xs">‚ûï –î–æ–±–∞–≤–∏—Ç—å</button>
                             <button id="removeColorBtn" class="btn-secondary py-2 px-2 rounded-lg text-xs">‚ûñ –£–¥–∞–ª–∏—Ç—å</button>
                        </div>
                        <button id="changeBackgroundColorBtn" class="btn-secondary py-2 px-4 rounded-lg text-xs">üé® –¶–≤–µ—Ç —Ñ–æ–Ω–∞ —Å—Ü–µ–Ω—ã</button>
                        <button id="changeLowerColorBtn" class="btn-secondary py-2 px-4 rounded-lg text-xs">üåò –¶–≤–µ—Ç –Ω–∏–∂–Ω–µ–π —Å—Ñ–µ—Ä—ã</button>
                        <button id="uploadBackgroundImageBtn" class="btn-secondary py-2 px-4 rounded-lg text-xs">üñºÔ∏è –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ç–µ–∫—Å—Ç—É—Ä—É</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="mt-12 text-center pb-8">
             <button id="home" class="text-gray-500 hover:text-white transition-colors flex items-center justify-center gap-2 mx-auto px-6 py-3 rounded-full hover:bg-white/5">
                <span class="text-xl">‚Üê</span> –í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞ –≥–ª–∞–≤–Ω—É—é
            </button>
        </div>

        <div id="imageModal" class="hidden">
            <div class="glass-card p-2 sm:p-6 rounded-2xl max-w-[95vw] max-h-[95vh] flex flex-col relative">
                <div id="fullContainer" class="rounded-xl overflow-hidden"></div>
                <button id="closeModalBtn" class="absolute top-4 right-4 bg-black/50 hover:bg-black/80 text-white w-10 h-10 rounded-full flex items-center justify-center transition-colors backdrop-blur-sm">
                    ‚úï
                </button>
                <p class="text-center text-gray-400 text-sm mt-4">–í—Ä–∞—â–∞–π—Ç–µ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ ‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–ª–µ—Å–∏–∫–æ –º—ã—à–∏ –¥–ª—è –º–∞—Å—à—Ç–∞–±–∞</p>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'OrbitControls';

        const DPI = 300;
        const CM_TO_INCH = 1 / 2.54;
        const MAIN_CM = 15;
        const MAIN_PX = Math.round(MAIN_CM * CM_TO_INCH * DPI);
        const CANVAS_PX = 512; 
        const MOBILE_RECORDING_PX = 1280;
        const MAX_RECORDING_DURATION = 60;
        let ANIMATION_SPEED = 0.1;
        let sceneBackgroundColor = [30, 27, 75, 1];
        let lowerDomeColor = [255, 255, 255, 0.1]; 
        let hasBackgroundImage = false;
        let backgroundTexture = null;
        
        const DEFAULT_PALETTE = {
            '1': [245, 245, 220, 1],
            '2': [0, 255, 255, 1], 
            '3': [255, 255, 0, 1],
            '4': [255, 0, 255, 1]
        };
        const AVAILABLE_COLORS = [
            [245, 245, 220, 1],
            [255, 255, 0, 1],
            [0, 255, 255, 1], 
            [255, 0, 255, 1],
            [144, 238, 144, 1]
        ];

        let colorIndex = 0;
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        class KaleidoGenerator {
            constructor(size_px, palette, mode = 'Lines', sectors = 12, elements = 300, slices = 13) {
                this.size = size_px;
                this.palette = Object.values(palette);
                this.mode = mode;
                this.sectors = sectors;
                this.elements = Math.min(elements, 500);
                this.slices = slices;
                this.branch_settings = {
                    size: 150,
                    angle: 0.4,
                    scale: 0.67,
                    iterations: Math.max(1, Math.floor(elements / 100)),
                    offset: 0,
                    spiral_density: 0.05,
                };
                this.elementsData = [];
                this.initElements();
            }
            initElements() {
                this.elementsData = [];
                const angle = 360 / this.sectors;
                if (this.mode === 'Lines') {
                    for (let i = 0; i < this.elements; i++) {
                        this.elementsData.push({
                            r1: Math.random(),
                            theta1: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            r2: Math.random(),
                            theta2: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * this.palette.length),
                            lineWidth: Math.floor(Math.random() * 4) + 1
                        });
                    }
                } else if (this.mode === 'Dots') {
                    for (let i = 0; i < this.elements; i++) {
                        this.elementsData.push({
                            r: Math.random(),
                            theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * this.palette.length),
                            size_dot: Math.random() * 6 + 2
                        });
                    }
                } else if (this.mode === 'Shapes') {
                    for (let i = 0; i < this.elements; i++) {
                        this.elementsData.push({
                            r: Math.random(),
                            theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * this.palette.length),
                            size_sq: Math.random() * 15 + 5
                        });
                    }
                } else if (this.mode === 'Mixed') {
                    for (let i = 0; i < this.elements; i++) {
                        const type = ['Lines', 'Dots', 'Shapes'][Math.floor(Math.random() * 3)];
                        if (type === 'Lines') {
                            this.elementsData.push({
                                type: 'Lines',
                                r1: Math.random(),
                                theta1: (Math.random() * angle - angle / 2) * Math.PI / 180,
                                r2: Math.random(),
                                theta2: (Math.random() * angle - angle / 2) * Math.PI / 180,
                                colorIdx: Math.floor(Math.random() * this.palette.length),
                                lineWidth: Math.floor(Math.random() * 4) + 1
                            });
                        } else if (type === 'Dots') {
                            this.elementsData.push({
                                type: 'Dots',
                                r: Math.random(),
                                theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                                colorIdx: Math.floor(Math.random() * this.palette.length),
                                size_dot: Math.random() * 6 + 2
                            });
                        } else {
                            this.elementsData.push({
                                type: 'Shapes',
                                r: Math.random(),
                                theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                                colorIdx: Math.floor(Math.random() * this.palette.length),
                                size_sq: Math.random() * 15 + 5
                            });
                        }
                    }
                } else if (this.mode === 'Spiral') {
                    const spiral_count = Math.floor(this.elements / 10);
                    for (let i = 0; i < spiral_count; i++) {
                        this.elementsData.push({
                            theta_start: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            color_idx: Math.floor(Math.random() * this.palette.length)
                        });
                    }
                } else if (this.mode === 'Orbit') {
                    const diameter = this.size;
                    const a = 0.266746, b = 0.321596, c = 0.223138;
                    this.elementsData = [
                        { class: 'a', width: diameter * a, top: (diameter/2 - (diameter*a/2)) * 0.60, left: diameter/2 - (diameter*a/2), blink: 'blink-lightest', speed: 5*a, delay: 2*a },
                        { class: 'a', width: diameter * a, top: (diameter/2 - (diameter*a/2)) * 1.22, left: (diameter/2 - (diameter*a/2)) * 0.65, blink: 'blink-lightest', speed: 5*a, delay: 1*a },
                        { class: 'a', width: diameter * a, top: (diameter/2 - (diameter*a/2)) * 1.22, right: (diameter/2 - (diameter*a/2)) * 0.65, blink: 'blink-lightest', speed: 5*a, delay: 1*a },
                        { class: 'b', width: diameter * b, top: (diameter/2 - (diameter*b/2)) * 0.52, left: diameter*b/7, blink: 'blink-lightest', speed: 5*b, delay: 1*b },
                        { class: 'b', width: diameter * b, top: (diameter/2 - (diameter*b/2)) * 0.52, right: diameter*b/7, blink: 'blink-lightest', speed: 5*b, delay: 1*b },
                        { class: 'b', width: diameter * b, bottom: 0, left: diameter/2 - (diameter*b/2), blink: 'blink', speed: 5*b, delay: 2*b },
                        { class: 'c', width: diameter * c, top: diameter*c/15, left: diameter*c * 1.23, blink: 'blink-lightest', speed: 6*c, delay: 3*c },
                        { class: 'c', width: diameter * c, top: diameter*c/15, right: diameter*c * 1.23, blink: 'blink-lightest', speed: 6*c, delay: 2*c },
                        { class: 'c', width: diameter * c, bottom: diameter*c/2.3, left: diameter*c * 0.55, blink: 'blink-lightest', speed: 6*c, delay: 4*c },
                        { class: 'c', width: diameter * c, bottom: diameter*c * 1.3, left: diameter*c * 0.05, blink: 'blink-lightest', speed: 6*c, delay: 3*c },
                        { class: 'c', width: diameter * c, bottom: diameter*c/2.3, right: diameter*c * 0.55, blink: 'blink-lightest', speed: 6*c, delay: 2*c },
                        { class: 'c', width: diameter * c, bottom: diameter*c * 1.3, right: diameter*c * 0.05, blink: 'blink-lightest', speed: 6*c, delay: 3*c },
                        { class: 'center', width: diameter * a, top: diameter/2 - (diameter*a/2), left: diameter/2 - (diameter*a/2), blink: 'blink', speed: 3, delay: 0 },
                        { class: 'tile-cover', width: diameter, top: 0, left: 0, blink: 'blink', speed: 3, delay: 1 },
                        { class: 'tile-back', width: diameter, top: 0, left: 0, blink: 'blink', speed: 5, delay: 2 },
                    ];
                } else if (this.mode === 'DotToShape') {
                    for (let i = 0; i < this.elements; i++) {
                        this.elementsData.push({
                            r: Math.random(),
                            theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * this.palette.length),
                            size_dot: Math.random() * 6 + 2,
                            size_sq: Math.random() * 15 + 5
                        });
                    }
                } else if (this.mode === 'DotsToMixed') {
                    for (let i = 0; i < this.elements; i++) {
                        const type = ['Lines', 'Dots', 'Shapes'][Math.floor(Math.random() * 3)];
                        this.elementsData.push({
                            r: Math.random(),
                            theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * this.palette.length),
                            size_dot: Math.random() * 6 + 2,
                            type: type,
                            r1: type === 'Lines' ? Math.random() : null,
                            theta1: type === 'Lines' ? (Math.random() * angle - angle / 2) * Math.PI / 180 : null,
                            r2: type === 'Lines' ? Math.random() : null,
                            theta2: type === 'Lines' ? (Math.random() * angle - angle / 2) * Math.PI / 180 : null,
                            lineWidth: type === 'Lines' ? Math.floor(Math.random() * 4) + 1 : null,
                            size_sq: type === 'Shapes' ? Math.random() * 15 + 5 : null
                        });
                    }
                }
            }
            generateTextureCanvas(animate = false, animationTime = 0) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = this.size;
                canvas.height = this.size;
                // Use scene color but adapt for 2D texture if needed
                ctx.fillStyle = `rgba(${sceneBackgroundColor[0]}, ${sceneBackgroundColor[1]}, ${sceneBackgroundColor[2]}, ${sceneBackgroundColor[3]})`;
                ctx.fillRect(0, 0, this.size, this.size);
                ctx.globalAlpha = animate ? 0.9 : 1.0;
                const main = this._makeKaleidoSquare(animate, animationTime);
                ctx.drawImage(main, 0, 0);
                ctx.globalAlpha = 1.0;
                return canvas;
            }
            _interpolateColor(color1, color2, factor) {
                return [
                    Math.round(color1[0] * (1 - factor) + color2[0] * factor),
                    Math.round(color1[1] * (1 - factor) + color2[1] * factor),
                    Math.round(color1[2] * (1 - factor) + color2[2] * factor),
                    color1[3] * (1 - factor) + color2[3] * factor
                ];
            }
            _makeTrianglifyPattern(width, height, t) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                const cell_size = 50;
                for (let i = 0; i < width; i += cell_size) {
                    for (let j = 0; j < height; j += cell_size) {
                        const points = [
                            [i, j],
                            [i + cell_size, j],
                            [i + cell_size, j + cell_size],
                            [i, j + cell_size],
                        ];
                        const color1 = this.palette[Math.floor(Math.random() * this.palette.length)];
                        const color2 = this.palette[Math.floor(Math.random() * this.palette.length)];
                        const factor = t ? (Math.sin(t + i * 0.1 + j * 0.1) + 1) / 2 : 0;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color1, color2, factor).join(',')})`;
                        ctx.beginPath();
                        ctx.moveTo(points[0][0], points[0][1]);
                        ctx.lineTo(points[1][0], points[1][1]);
                        ctx.lineTo(points[2][0], points[2][1]);
                        ctx.fill();
                        ctx.fillStyle = `rgba(${this._interpolateColor(color2, color1, factor).join(',')})`;
                        ctx.beginPath();
                        ctx.moveTo(points[0][0], points[0][1]);
                        ctx.lineTo(points[2][0], points[2][1]);
                        ctx.lineTo(points[3][0], points[3][1]);
                        ctx.fill();
                    }
                }
                return canvas;
            }
            _makeKaleidoSquare(animate, animationTime) {
                const canvas = document.createElement('canvas');
                canvas.width = this.size;
                canvas.height = this.size;
                const ctx = canvas.getContext('2d');
                const radius = this.size / 2;
                const angle = 360 / this.sectors;
                const cx = radius, cy = radius;
                const t = animate ? animationTime * ANIMATION_SPEED : 0;
                const rotationOffset = Math.sin(t) * 0.4;
                if (this.mode === 'Lines') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.strokeStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        const x1 = cx + data.r1 * radius * Math.cos(data.theta1 + thetaOffset);
                        const y1 = cy + data.r1 * radius * Math.sin(data.theta1 + thetaOffset);
                        const x2 = cx + data.r2 * radius * Math.cos(data.theta2 + thetaOffset);
                        const y2 = cy + data.r2 * radius * Math.sin(data.theta2 + thetaOffset);
                        ctx.lineWidth = data.lineWidth * (1 + Math.sin(t + i * 0.3) * 0.8);
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                } else if (this.mode === 'Dots') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                        const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                        const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                        ctx.beginPath();
                        ctx.arc(x, y, size_dot, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                } else if (this.mode === 'Shapes') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                        const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                        const size_sq = data.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8);
                        ctx.fillRect(x - size_sq, y - size_sq, size_sq * 2, size_sq * 2);
                    }
                } else if (this.mode === 'Mixed') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        ctx.strokeStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        if (data.type === 'Lines') {
                            const x1 = cx + data.r1 * radius * Math.cos(data.theta1 + thetaOffset);
                            const y1 = cy + data.r1 * radius * Math.sin(data.theta1 + thetaOffset);
                            const x2 = cx + data.r2 * radius * Math.cos(data.theta2 + thetaOffset);
                            const y2 = cy + data.r2 * radius * Math.sin(data.theta2 + thetaOffset);
                            ctx.lineWidth = data.lineWidth * (1 + Math.sin(t + i * 0.3) * 0.8);
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        } else if (data.type === 'Dots') {
                            const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                            const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                            const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                            ctx.beginPath();
                            ctx.arc(x, y, size_dot, 0, 2 * Math.PI);
                            ctx.fill();
                        } else {
                            const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                            const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                            const size_sq = data.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8);
                            ctx.fillRect(x - size_sq, y - size_sq, size_sq * 2, size_sq * 2);
                        }
                    }
                } else if (this.mode === 'Spiral') {
                    const s = this.branch_settings;
                    for (let i = 0; i < this.elementsData.length; i++) {
                        let theta_start = this.elementsData[i].theta_start + t * 0.3;
                        let color_idx = this.elementsData[i].color_idx;
                        const next_color_idx = (color_idx + 1) % this.palette.length;
                        for (let r = 0; r < radius; r += 2) {
                            const theta = theta_start + r * s.spiral_density;
                            const x = cx + r * Math.cos(theta);
                            const y = cy + r * Math.sin(theta);
                            const colorFactor = (Math.sin(t + r * 0.02) + 1) / 2;
                            const r_col = Math.round(this.palette[color_idx][0] * (1 - colorFactor) + this.palette[next_color_idx][0] * colorFactor);
                            const g_col = Math.round(this.palette[color_idx][1] * (1 - colorFactor) + this.palette[next_color_idx][1] * colorFactor);
                            const b_col = Math.round(this.palette[color_idx][2] * (1 - colorFactor) + this.palette[next_color_idx][2] * colorFactor);
                            const a_col = this.palette[color_idx][3] * (1 - colorFactor) + this.palette[next_color_idx][3] * colorFactor;
                            const width = Math.max(2, 4 + Math.sin(r * 0.03 + t) * 5);
                            ctx.fillStyle = `rgba(${r_col}, ${g_col}, ${b_col}, ${a_col})`;
                            ctx.beginPath();
                            ctx.arc(x, y, width, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    }
                } else if (this.mode === 'Orbit') {
                    const diameter = this.size;
                    for (const config of this.elementsData) {
                        const width = config.width;
                        const height = width;
                        let x = config.left !== undefined ? config.left : diameter - config.right - width;
                        let y = config.top !== undefined ? config.top : diameter - config.bottom - height;
                        x = cx + (x - diameter/2) * (1 + Math.sin(t) * 0.3);
                        y = cy + (y - diameter/2) * (1 + Math.cos(t) * 0.3);
                        const opacity = config.blink === 'blink' ? 0.5 + 0.5 * Math.sin(t / config.speed) :
                                        config.blink === 'blink-lighter' ? 0.3 + 0.2 * Math.sin(t / config.speed) :
                                        0.375 + 0.375 * Math.sin(t / config.speed);
                        const pattern = this._makeTrianglifyPattern(width, height, t);
                        ctx.globalAlpha = opacity;
                        ctx.drawImage(pattern, x, y, width, height);
                        ctx.globalAlpha = 1;
                        ctx.strokeStyle = `rgba(0, 0, 255, ${0.5 + Math.sin(t) * 0.5})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(x + width / 2, y + height / 2, width / 2, 0, 2 * Math.PI);
                        ctx.stroke();
                    }
                } else if (this.mode === 'DotToShape') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                        const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                        const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                        const size_sq = data.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8);
                        const shapeFactor = (Math.sin(t * 2) + 1) / 2;
                        const size = size_dot * (1 - shapeFactor) + size_sq * shapeFactor;
                        const cornerRadius = size * (1 - shapeFactor);
                        ctx.beginPath();
                        ctx.moveTo(x - size + cornerRadius, y - size);
                        ctx.lineTo(x + size - cornerRadius, y - size);
                        ctx.arcTo(x + size, y - size, x + size, y - size + cornerRadius, cornerRadius);
                        ctx.lineTo(x + size, y + size - cornerRadius);
                        ctx.arcTo(x + size, y + size, x + size - cornerRadius, y + size, cornerRadius);
                        ctx.lineTo(x - size + cornerRadius, y + size);
                        ctx.arcTo(x - size, y + size, x - size, y + size - cornerRadius, cornerRadius);
                        ctx.lineTo(x - size, y - size + cornerRadius);
                        ctx.arcTo(x - size, y - size, x - size + cornerRadius, y - size, cornerRadius);
                        ctx.closePath();
                        ctx.fill();
                    }
                } else if (this.mode === 'DotsToMixed') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        ctx.strokeStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                        const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                        const shapeFactor = (Math.sin(t * 2) + 1) / 2;
                        if (shapeFactor < 0.5) {
                            const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                            ctx.beginPath();
                            ctx.arc(x, y, size_dot * (1 - shapeFactor * 2), 0, 2 * Math.PI);
                            ctx.fill();
                        } else {
                            if (data.type === 'Lines') {
                                const x1 = cx + data.r1 * radius * Math.cos(data.theta1 + thetaOffset);
                                const y1 = cy + data.r1 * radius * Math.sin(data.theta1 + thetaOffset);
                                const x2 = cx + data.r2 * radius * Math.cos(data.theta2 + thetaOffset);
                                const y2 = cy + data.r2 * radius * Math.sin(data.theta2 + thetaOffset);
                                ctx.lineWidth = data.lineWidth * (1 + Math.sin(t + i * 0.3) * 0.8) * (shapeFactor * 2 - 1);
                                ctx.beginPath();
                                ctx.moveTo(x1, y1);
                                ctx.lineTo(x2, y2);
                                ctx.stroke();
                            } else if (data.type === 'Dots') {
                                const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8) * (shapeFactor * 2 - 1);
                                ctx.beginPath();
                                ctx.arc(x, y, size_dot, 0, 2 * Math.PI);
                                ctx.fill();
                            } else {
                                const size_sq = data.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8) * (shapeFactor * 2 - 1);
                                ctx.fillRect(x - size_sq, y - size_sq, size_sq * 2, size_sq * 2);
                            }
                        }
                    }
                }
                const full = document.createElement('canvas');
                full.width = this.size;
                full.height = this.size;
                const fullCtx = full.getContext('2d');
                fullCtx.fillStyle = `rgba(${sceneBackgroundColor[0]}, ${sceneBackgroundColor[1]}, ${sceneBackgroundColor[2]}, ${sceneBackgroundColor[3]})`;
                fullCtx.fillRect(0, 0, this.size, this.size);
                for (let i = 0; i < this.sectors; i++) {
                    fullCtx.save();
                    fullCtx.translate(cx, cy);
                    fullCtx.rotate((angle * i + rotationOffset) * Math.PI / 180);
                    if (i % 2 === 1) {
                        fullCtx.scale(-1, 1);
                    }
                    fullCtx.drawImage(canvas, -cx, -cy);
                    fullCtx.restore();
                }
                return full;
            }
            _drawShape(x, y, angle, size, ctx, points, t) {
                this._drawBranch(x, y, angle, size, 1, ctx, points, t);
                this._drawBranch(x, y, angle, size, -1, ctx, points, t);
            }
            _drawBranch(x, y, angle, size, direction, ctx, points, t) {
                const s = this.branch_settings;
                const new_angle = angle + (s.angle * direction + s.offset) + Math.sin(t) * 0.3;
                const new_size = size * s.scale * (1 + Math.sin(t) * 0.2);
                const x2 = x + Math.cos(new_angle) * new_size;
                const y2 = y + Math.sin(new_angle) * new_size;
                const color = this.palette[Math.floor(Math.random() * this.palette.length)];
                const nextColor = this.palette[(Math.floor(Math.random() * this.palette.length) + 1) % this.palette.length];
                const colorFactor = (Math.sin(t) + 1) / 2;
                ctx.strokeStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                ctx.lineWidth = 2 * (1 + Math.sin(t) * 0.8);
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                points.push({ x: x2, y: y2, angle: new_angle, size: new_size });
            }
        }
        let currentTextureCanvas = null;
        let isAnimating = false;
        let isFullAnimating = false;
        let isRecording = false;
        let animationFrameId = null;
        let fullAnimationFrameId = null;
        let startTime = null;
        let fullStartTime = null;
        let generator = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordTimerId = null;
        let recordStartTime = null;
        let previewScene, previewCamera, previewRenderer, previewDisc, previewUpperDome, previewLowerDome, previewControls, previewGroup;
        let fullScene, fullCamera, fullRenderer, fullDisc, fullUpperDome, fullLowerDome, fullControls, fullGroup;
        let previewContainer = document.getElementById('previewContainer');
        let fullContainer = document.getElementById('fullContainer');
        function init3D(container, size, isPreview = true) {
            const scene = new THREE.Scene();
            const bgColor = new THREE.Color(sceneBackgroundColor[0] / 255, sceneBackgroundColor[1] / 255, sceneBackgroundColor[2] / 255);
            scene.background = null; // Let CSS handle background
            const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(size, size);
            // Responsive fix
            renderer.domElement.style.width = '100%';
            renderer.domElement.style.height = 'auto';
            
            container.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(0, 10, 10);
            scene.add(pointLight);
            const group = new THREE.Group();
            const discGeometry = new THREE.CircleGeometry(5, 128);
            const discMaterial = new THREE.MeshPhongMaterial({ side: THREE.DoubleSide, transparent: true });
            const disc = new THREE.Mesh(discGeometry, discMaterial);
            disc.rotation.x = Math.PI / 2;
            group.add(disc);
            const upperDomeGeometry = new THREE.SphereGeometry(5, 128, 128, 0, Math.PI * 2, 0, Math.PI / 2);
            const upperDomeMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.6,
                shininess: 100,
                specular: 0xffffff,
                side: THREE.DoubleSide
            });
            const upperDome = new THREE.Mesh(upperDomeGeometry, upperDomeMaterial);
            group.add(upperDome);
            const lowerDomeGeometry = new THREE.SphereGeometry(5, 128, 128, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
            const lowerDomeMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color(lowerDomeColor[0] / 255, lowerDomeColor[1] / 255, lowerDomeColor[2] / 255),
                transparent: lowerDomeColor[3] < 1,
                opacity: lowerDomeColor[3],
                side: THREE.DoubleSide
            });
            const lowerDome = new THREE.Mesh(lowerDomeGeometry, lowerDomeMaterial);
            group.add(lowerDome);
            scene.add(group);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enablePan = false;
            controls.enableZoom = false;
            controls.enableRotate = true;
            controls.autoRotate = false;
            function animate3D() {
                requestAnimationFrame(animate3D);
                if ((isPreview && isAnimating) || (!isPreview && isFullAnimating)) {
                    const time = Date.now() * 0.001;
                    group.rotation.y += 0.01;
                    group.rotation.x = Math.sin(time * 0.5) * 0.1;
                    group.rotation.z = Math.cos(time * 0.5) * 0.1;
                }
                controls.update();
                renderer.render(scene, camera);
            }
            animate3D();
            return { scene, camera, renderer, disc, upperDome, lowerDome, controls, group };
        }
        function update3DTexture(disc, textureCanvas) {
            const texture = new THREE.CanvasTexture(textureCanvas);
            texture.needsUpdate = true;
            disc.material.map = texture;
            disc.material.needsUpdate = true;
        }
        function updateSceneBackground() {
            const bgColor = new THREE.Color(sceneBackgroundColor[0] / 255, sceneBackgroundColor[1] / 255, sceneBackgroundColor[2] / 255);
            if (hasBackgroundImage && backgroundTexture) {
                previewLowerDome.material.map = backgroundTexture;
                previewLowerDome.material.color.set(0xffffff);
                previewLowerDome.material.needsUpdate = true;
                fullLowerDome.material.map = backgroundTexture;
                fullLowerDome.material.color.set(0xffffff);
                fullLowerDome.material.needsUpdate = true;
            } else {
                previewLowerDome.material.map = null;
                fullLowerDome.material.map = null;
                updateLowerDomeColor();
            }
            previewLowerDome.visible = true;
            fullLowerDome.visible = true;
        }
        function updateLowerDomeColor() {
            const ldColor = new THREE.Color(lowerDomeColor[0] / 255, lowerDomeColor[1] / 255, lowerDomeColor[2] / 255);
            previewLowerDome.material.color = ldColor;
            previewLowerDome.material.transparent = lowerDomeColor[3] < 1;
            previewLowerDome.material.opacity = lowerDomeColor[3];
            previewLowerDome.material.needsUpdate = true;
            fullLowerDome.material.color = ldColor;
            fullLowerDome.material.transparent = lowerDomeColor[3] < 1;
            fullLowerDome.material.opacity = lowerDomeColor[3];
            fullLowerDome.material.needsUpdate = true;
        }
        function loadPalette() {
            const generatedColors = localStorage.getItem('generatedColors');
            if (generatedColors) {
                try {
                    const colors = JSON.parse(generatedColors);
                    if (Array.isArray(colors) && colors.every(c => /^#[0-9A-Fa-f]{6}$/.test(c))) {
                        const newPalette = {};
                        colors.forEach((color, index) => {
                            const rgb = hexToRgb(color);
                            newPalette[(index + 1).toString()] = [...rgb, 1];
                        });
                        localStorage.setItem('palette', JSON.stringify(newPalette));
                        return newPalette;
                    }
                } catch (e) {
                    console.error('Error parsing generatedColors:', e);
                }
            }
            const saved = localStorage.getItem('palette');
            if (saved) {
                try {
                    const json = JSON.parse(saved);
                    if (Object.keys(json).every(k => Array.isArray(json[k]) && json[k].length === 4 && json[k].slice(0, 3).every(c => Number.isInteger(c) && c >= 0 && c <= 255) && json[k][3] >= 0 && json[k][3] <= 1)) {
                        return json;
                    }
                } catch (e) {
                    console.error('Error parsing saved palette:', e);
                }
            }
            return DEFAULT_PALETTE;
        }
        function loadSceneBackgroundColor() {
            const saved = localStorage.getItem('sceneBackgroundColor');
            if (saved) {
                try {
                    const color = JSON.parse(saved);
                    if (Array.isArray(color) && color.length === 4 && color.slice(0, 3).every(c => Number.isInteger(c) && c >= 0 && c <= 255) && color[3] >= 0 && color[3] <= 1) {
                        sceneBackgroundColor = color;
                    }
                } catch (e) {
                    console.error('Error parsing saved scene background color:', e);
                }
            }
            hasBackgroundImage = false;
            updateSceneBackground();
        }
        function loadLowerDomeColor() {
            const saved = localStorage.getItem('lowerDomeColor');
            if (saved) {
                try {
                    const color = JSON.parse(saved);
                    if (Array.isArray(color) && color.length === 4 && color.slice(0, 3).every(c => Number.isInteger(c) && c >= 0 && c <= 255) && color[3] >= 0 && color[3] <= 1) {
                        lowerDomeColor = color;
                    }
                } catch (e) {
                    console.error('Error parsing saved lower dome color:', e);
                }
            }
            updateLowerDomeColor();
        }
        function savePalette() {
            localStorage.setItem('palette', JSON.stringify(palette));
        }
        function updatePaletteTable() {
            const tbody = document.querySelector('#paletteTable tbody');
            tbody.innerHTML = '';
            Object.entries(palette).forEach(([key, color], index) => {
                const row = document.createElement('tr');
                row.className = "hover:bg-white/5 transition-colors";
                row.innerHTML = `
                    <td class="p-3 text-gray-300">${key}</td>
                    <td class="p-3">
                        <button class="color-btn" style="background-color: rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]});" title="–ò–∑–º–µ–Ω–∏—Ç—å —Ü–≤–µ—Ç"></button>
                    </td>
                    <td class="p-3 text-right">
                        <button class="delete-btn" title="–£–¥–∞–ª–∏—Ç—å —Ü–≤–µ—Ç">‚úï</button>
                    </td>
                `;
                row.querySelector('.color-btn').addEventListener('click', () => changeColor(index));
                row.querySelector('.delete-btn').addEventListener('click', () => removeSpecificColor(key));
                tbody.appendChild(row);
            });
        }
        function addColor() {
            if (Object.keys(palette).length >= 20) {
                alert('–ú–∞–∫—Å–∏–º—É–º 20 —Ü–≤–µ—Ç–æ–≤!');
                return;
            }
            const newKey = (Object.keys(palette).length + 1).toString();
            palette[newKey] = AVAILABLE_COLORS[colorIndex % AVAILABLE_COLORS.length];
            colorIndex++;
            updatePaletteTable();
            savePalette();
        }
        function removeColor() {
            if (Object.keys(palette).length <= 1) {
                alert('–ú–∏–Ω–∏–º—É–º 1 —Ü–≤–µ—Ç!');
                return;
            }
            const keys = Object.keys(palette);
            delete palette[keys[keys.length - 1]];
            updatePaletteTable();
            savePalette();
        }
        function removeSpecificColor(key) {
            if (Object.keys(palette).length <= 1) {
                alert('–ú–∏–Ω–∏–º—É–º 1 —Ü–≤–µ—Ç!');
                return;
            }
            delete palette[key];
            const newPalette = {};
            Object.values(palette).forEach((color, index) => {
                newPalette[(index + 1).toString()] = color;
            });
            palette = newPalette;
            updatePaletteTable();
            savePalette();
        }
        function changeColor(row) {
            const key = Object.keys(palette)[row];
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-slate-800 p-6 rounded-2xl border border-white/10 max-w-sm w-full shadow-2xl">
                    <h3 class="text-lg font-semibold mb-4 text-white">–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ü–≤–µ—Ç–∞ ${key}</h3>
                    <input type="color" id="colorPicker" value="${rgbToHex(palette[key])}" class="w-full h-12 mb-4 rounded cursor-pointer bg-transparent">
                    <label class="block text-sm font-medium mb-1 text-gray-300">–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å: <span id="opacityValue" class="text-indigo-300">${palette[key][3]}</span></label>
                    <input type="range" id="opacitySlider" min="0" max="1" step="0.01" value="${palette[key][3]}" class="w-full mb-6">
                    <div class="flex justify-end gap-3">
                        <button id="cancelBtn" class="px-4 py-2 rounded-lg text-gray-300 hover:bg-white/10 transition-colors">–û—Ç–º–µ–Ω–∞</button>
                        <button id="saveColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-500 transition-colors shadow-lg">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            document.getElementById('opacitySlider').addEventListener('input', (e) => {
                document.getElementById('opacityValue').textContent = e.target.value;
            });
            document.getElementById('saveColorBtn').addEventListener('click', () => {
                const color = hexToRgb(document.getElementById('colorPicker').value);
                const opacity = parseFloat(document.getElementById('opacitySlider').value);
                palette[key] = [...color, opacity];
                updatePaletteTable();
                savePalette();
                document.body.removeChild(modal);
            });
            document.getElementById('cancelBtn').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
        }
        function changeSceneBackgroundColor() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-slate-800 p-6 rounded-2xl border border-white/10 max-w-sm w-full shadow-2xl">
                    <h3 class="text-lg font-semibold mb-4 text-white">–¶–≤–µ—Ç —Ñ–æ–Ω–∞ —Å—Ü–µ–Ω—ã</h3>
                    <input type="color" id="backgroundColorPicker" value="${rgbToHex(sceneBackgroundColor)}" class="w-full h-12 mb-4 rounded cursor-pointer bg-transparent">
                    <label class="block text-sm font-medium mb-1 text-gray-300">–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å: <span id="backgroundOpacityValue" class="text-indigo-300">${sceneBackgroundColor[3]}</span></label>
                    <input type="range" id="backgroundOpacitySlider" min="0" max="1" step="0.01" value="${sceneBackgroundColor[3]}" class="w-full mb-6">
                    <div class="flex justify-end gap-3">
                        <button id="cancelBackgroundBtn" class="px-4 py-2 rounded-lg text-gray-300 hover:bg-white/10 transition-colors">–û—Ç–º–µ–Ω–∞</button>
                        <button id="saveBackgroundColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-500 transition-colors shadow-lg">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            document.getElementById('backgroundOpacitySlider').addEventListener('input', (e) => {
                document.getElementById('backgroundOpacityValue').textContent = e.target.value;
            });
            document.getElementById('saveBackgroundColorBtn').addEventListener('click', () => {
                const color = hexToRgb(document.getElementById('backgroundColorPicker').value);
                const opacity = parseFloat(document.getElementById('backgroundOpacitySlider').value);
                sceneBackgroundColor = [...color, opacity];
                localStorage.setItem('sceneBackgroundColor', JSON.stringify(sceneBackgroundColor));
                hasBackgroundImage = false;
                updateSceneBackground();
                document.body.removeChild(modal);
                generate();
            });
            document.getElementById('cancelBackgroundBtn').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
        }
        function changeLowerDomeColor() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-slate-800 p-6 rounded-2xl border border-white/10 max-w-sm w-full shadow-2xl">
                    <h3 class="text-lg font-semibold mb-4 text-white">–¶–≤–µ—Ç –Ω–∏–∂–Ω–µ–π —Å—Ñ–µ—Ä—ã</h3>
                    <input type="color" id="lowerColorPicker" value="${rgbToHex(lowerDomeColor)}" class="w-full h-12 mb-4 rounded cursor-pointer bg-transparent">
                    <label class="block text-sm font-medium mb-1 text-gray-300">–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å: <span id="lowerOpacityValue" class="text-indigo-300">${lowerDomeColor[3]}</span></label>
                    <input type="range" id="lowerOpacitySlider" min="0" max="1" step="0.01" value="${lowerDomeColor[3]}" class="w-full mb-6">
                    <div class="flex justify-end gap-3">
                        <button id="cancelLowerBtn" class="px-4 py-2 rounded-lg text-gray-300 hover:bg-white/10 transition-colors">–û—Ç–º–µ–Ω–∞</button>
                        <button id="saveLowerColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-500 transition-colors shadow-lg">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            document.getElementById('lowerOpacitySlider').addEventListener('input', (e) => {
                document.getElementById('lowerOpacityValue').textContent = e.target.value;
            });
            document.getElementById('saveLowerColorBtn').addEventListener('click', () => {
                const color = hexToRgb(document.getElementById('lowerColorPicker').value);
                const opacity = parseFloat(document.getElementById('lowerOpacitySlider').value);
                lowerDomeColor = [...color, opacity];
                localStorage.setItem('lowerDomeColor', JSON.stringify(lowerDomeColor));
                hasBackgroundImage = false;
                updateSceneBackground();
                updateLowerDomeColor();
                document.body.removeChild(modal);
                generate();
            });
            document.getElementById('cancelLowerBtn').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
        }
        function rgbToHex([r, g, b]) {
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
        }
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
        }
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = (seconds % 60).toString().padStart(2, '0');
            return `${mins}:${secs}`;
        }
        function updateRecordTimer() {
            if (isRecording) {
                const elapsed = Math.floor((Date.now() - recordStartTime) / 1000);
                document.getElementById('recordTimer').textContent = `–ó–∞–ø–∏—Å—å: ${formatTime(elapsed)}`;
                if (elapsed >= MAX_RECORDING_DURATION) {
                    stopRecording();
                    alert(`–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑–∞–ø–∏—Å–∏ (${MAX_RECORDING_DURATION} —Å–µ–∫—É–Ω–¥) –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞.`);
                }
            }
        }
        function resetRecordTimer() {
            document.getElementById('recordTimer').textContent = '–ó–∞–ø–∏—Å—å: 00:00';
            if (recordTimerId) {
                clearInterval(recordTimerId);
                recordTimerId = null;
            }
        }
        function generate() {
            stopAnimation();
            stopFullAnimation();
            stopRecording();
            const modeMap = {
                '–õ–∏–Ω–∏–∏': 'Lines',
                '–¢–æ—á–∫–∏': 'Dots',
                '–§–∏–≥—É—Ä—ã': 'Shapes',
                '–°–º–µ—à–∞–Ω–Ω—ã–π': 'Mixed',
                '–°–ø–∏—Ä–∞–ª—å': 'Spiral',
                '–û—Ä–±–∏—Ç—ã': 'Orbit',
                '–¢–æ—á–∫–∏ –≤ –§–∏–≥—É—Ä—ã': 'DotToShape',
                '–¢–æ—á–∫–∏ –≤ –°–º–µ—à–∞–Ω–Ω—ã–π': 'DotsToMixed'
            };
            const mode = modeMap[document.getElementById('modeCombo').value];
            const elements = parseInt(document.getElementById('elementSlider').value);
            const slices = parseInt(document.getElementById('slicesSlider').value);
            generator = new KaleidoGenerator(CANVAS_PX, palette, mode, 12, elements, slices);
            const textureCanvas = generator.generateTextureCanvas();
            currentTextureCanvas = textureCanvas;
            update3DTexture(previewDisc, textureCanvas);
        }
        function animate() {
            if (!generator) {
                alert('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ —É–∑–æ—Ä!');
                return;
            }
            isAnimating = !isAnimating;
            const animateBtn = document.getElementById('animateBtn');
            if (isAnimating) {
                animateBtn.textContent = '‚èπ –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å';
                animateBtn.classList.add('active');
                startTime = Date.now();
                requestAnimationFrame(animateLoop);
            } else {
                animateBtn.textContent = '‚ñ∂ –ê–Ω–∏–º–∏—Ä–æ–≤–∞—Ç—å';
                animateBtn.classList.remove('active');
                cancelAnimationFrame(animationFrameId);
            }
        }
        function animateLoop() {
            if (!isAnimating || !generator) {
                return;
            }
            const elapsedTime = (Date.now() - startTime) / 1000;
            const textureCanvas = generator.generateTextureCanvas(true, elapsedTime);
            currentTextureCanvas = textureCanvas;
            update3DTexture(previewDisc, textureCanvas);
            animationFrameId = requestAnimationFrame(animateLoop);
        }
        function stopAnimation() {
            if (isAnimating) {
                isAnimating = false;
                document.getElementById('animateBtn').textContent = '‚ñ∂ –ê–Ω–∏–º–∏—Ä–æ–≤–∞—Ç—å';
                document.getElementById('animateBtn').classList.remove('active');
                cancelAnimationFrame(animationFrameId);
            }
        }
        function openFullImage() {
            if (!generator) {
                alert('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ —É–∑–æ—Ä!');
                return;
            }
            stopAnimation();
            const modal = document.getElementById('imageModal');
            const gen = new KaleidoGenerator(MAIN_PX, palette, generator.mode, generator.sectors, generator.elements, generator.slices);
            const textureCanvas = gen.generateTextureCanvas();
            update3DTexture(fullDisc, textureCanvas);
            modal.classList.add('show');
            isFullAnimating = true;
            fullStartTime = Date.now();
            requestAnimationFrame(() => animateFullLoop(gen));
        }
        function animateFullLoop(gen) {
            if (!isFullAnimating || !gen) {
                return;
            }
            const elapsedTime = (Date.now() - fullStartTime) / 1000;
            const textureCanvas = gen.generateTextureCanvas(true, elapsedTime);
            update3DTexture(fullDisc, textureCanvas);
            fullAnimationFrameId = requestAnimationFrame(() => animateFullLoop(gen));
        }
        function stopFullAnimation() {
            if (isFullAnimating) {
                isFullAnimating = false;
                cancelAnimationFrame(fullAnimationFrameId);
            }
        }
        function save() {
            if (!currentTextureCanvas) {
                alert('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ —É–∑–æ—Ä!');
                return;
            }
            const link = document.createElement('a');
            link.download = '–∫–∞–ª–µ–π–¥–æ—Å–∫–æ–ø.png';
            link.href = currentTextureCanvas.toDataURL('image/png');
            link.click();
        }
        function startStopRecording() {
            if (!generator) {
                alert('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ —É–∑–æ—Ä!');
                return;
            }
            const recordBtn = document.getElementById('recordBtn');
            const downloadVideoBtn = document.getElementById('downloadVideoBtn');
            const mimeType = MediaRecorder.isTypeSupported('video/mp4;codecs=avc1.4D401E') ? 'video/mp4;codecs=avc1.4D401E' : 'video/webm;codecs=vp9';
            const fileExtension = mimeType.startsWith('video/mp4') ? 'mp4' : 'webm';
            if (!isRecording) {
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    alert(`–§–æ—Ä–º–∞—Ç ${fileExtension.toUpperCase()} –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤–∞—à–∏–º –±—Ä–∞—É–∑–µ—Ä–æ–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π –±—Ä–∞—É–∑–µ—Ä, –Ω–∞–ø—Ä–∏–º–µ—Ä Chrome.`);
                    return;
                }
                if (!isAnimating) {
                    isAnimating = true;
                    startTime = Date.now();
                    requestAnimationFrame(animateLoop);
                    document.getElementById('animateBtn').textContent = '‚èπ –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å';
                    document.getElementById('animateBtn').classList.add('active');
                }
                recordedChunks = [];
                const stream = previewRenderer.domElement.captureStream(isMobile ? 30 : 60);
                try {
                    mediaRecorder = new MediaRecorder(stream, {
                        mimeType: mimeType,
                        videoBitsPerSecond: isMobile ? 10000000 : 20000000
                    });
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            recordedChunks.push(event.data);
                        }
                    };
                    mediaRecorder.onstop = () => {
                        downloadVideoBtn.disabled = recordedChunks.length === 0;
                        resetRecordTimer();
                    };
                    mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder error:', event.error);
                        alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø–∏—Å–∏ –≤–∏–¥–µ–æ: ' + event.error.message);
                        stopRecording();
                    };
                    mediaRecorder.start();
                    isRecording = true;
                    recordBtn.textContent = '‚èπ –°—Ç–æ–ø –∑–∞–ø–∏—Å—å';
                    recordBtn.classList.add('active');
                    recordStartTime = Date.now();
                    recordTimerId = setInterval(updateRecordTimer, 1000);
                } catch (e) {
                    console.error('Failed to start recording:', e);
                    alert('–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å. –§–æ—Ä–º–∞—Ç MP4 –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –±—Ä–∞—É–∑–µ—Ä Chrome.');
                }
            } else {
                mediaRecorder.stop();
                isRecording = false;
                recordBtn.textContent = '‚è∫ –ó–∞–ø–∏—Å—å';
                recordBtn.classList.remove('active');
            }
        }
        function downloadVideo() {
            if (recordedChunks.length === 0) {
                alert('–ù–µ—Ç –∑–∞–ø–∏—Å–∞–Ω–Ω–æ–≥–æ –≤–∏–¥–µ–æ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è!');
                return;
            }
            const mimeType = MediaRecorder.isTypeSupported('video/mp4;codecs=avc1.4D401E') ? 'video/mp4' : 'video/webm';
            const fileExtension = mimeType.startsWith('video/mp4') ? 'mp4' : 'webm';
            const blob = new Blob(recordedChunks, { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `–∫–∞–ª–µ–π–¥–æ—Å–∫–æ–ø.${fileExtension}`;
            link.click();
            URL.revokeObjectURL(url);
            recordedChunks = [];
            document.getElementById('downloadVideoBtn').disabled = true;
        }
        function stopRecording() {
            if (isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                document.getElementById('recordBtn').textContent = '‚è∫ –ó–∞–ø–∏—Å—å';
                document.getElementById('recordBtn').classList.remove('active');
                document.getElementById('downloadVideoBtn').disabled = recordedChunks.length === 0;
                resetRecordTimer();
            }
        }
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è 3D —Å—Ü–µ–Ω
        const preview3D = init3D(previewContainer, 800); // –£–≤–µ–ª–∏—á–∏–ª–∏ –±–∞–∑–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä —Ä–µ–Ω–¥–µ—Ä–∞
        previewScene = preview3D.scene;
        previewCamera = preview3D.camera;
        previewRenderer = preview3D.renderer;
        previewDisc = preview3D.disc;
        previewUpperDome = preview3D.upperDome;
        previewLowerDome = preview3D.lowerDome;
        previewControls = preview3D.controls;
        previewGroup = preview3D.group;
        const full3D = init3D(fullContainer, 800, false);
        fullScene = full3D.scene;
        fullCamera = full3D.camera;
        fullRenderer = full3D.renderer;
        fullDisc = full3D.disc;
        fullUpperDome = full3D.upperDome;
        fullLowerDome = full3D.lowerDome;
        fullControls = full3D.controls;
        fullGroup = full3D.group;
        // –°–æ–±—ã—Ç–∏—è
        document.getElementById('elementSlider').addEventListener('input', (e) => {
            document.getElementById('elementValue').textContent = e.target.value;
            stopAnimation();
            stopFullAnimation();
            stopRecording();
        });
        document.getElementById('slicesSlider').addEventListener('input', (e) => {
            document.getElementById('slicesValue').textContent = e.target.value;
            stopAnimation();
            stopFullAnimation();
            stopRecording();
        });
        document.getElementById('animationSpeedSlider').addEventListener('input', (e) => {
            ANIMATION_SPEED = parseFloat(e.target.value);
            document.getElementById('animationSpeedValue').textContent = ANIMATION_SPEED.toFixed(2);
        });
        document.getElementById('modeCombo').addEventListener('change', () => {
            const selectedValue = document.getElementById('modeCombo').value;
            if (selectedValue === 'Crystal') {
                window.location.href = 'kalei.html';
            } else {
                stopAnimation();
                stopFullAnimation();
                stopRecording();
            }
        });
        document.getElementById('addColorBtn').addEventListener('click', () => {
            addColor();
            stopAnimation();
            stopFullAnimation();
            stopRecording();
        });
        document.getElementById('removeColorBtn').addEventListener('click', () => {
            removeColor();
            stopAnimation();
            stopFullAnimation();
            stopRecording();
        });
        document.getElementById('generateBtn').addEventListener('click', generate);
        document.getElementById('animateBtn').addEventListener('click', animate);
        document.getElementById('recordBtn').addEventListener('click', startStopRecording);
        document.getElementById('downloadVideoBtn').addEventListener('click', downloadVideo);
        document.getElementById('viewBtn').addEventListener('click', openFullImage);
        document.getElementById('saveBtn').addEventListener('click', save);
        document.getElementById('closeModalBtn').addEventListener('click', () => {
            stopFullAnimation();
            document.getElementById('imageModal').classList.remove('show');
        });
        document.getElementById('home').addEventListener('click', () => {
            stopAnimation();
            stopFullAnimation();
            stopRecording();
            window.location.href = 'main.html';
        });
        document.getElementById('changeBackgroundColorBtn').addEventListener('click', changeSceneBackgroundColor);
        document.getElementById('changeLowerColorBtn').addEventListener('click', changeLowerDomeColor);
        document.getElementById('uploadBackgroundImageBtn').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const url = URL.createObjectURL(file);
                    backgroundTexture = new THREE.TextureLoader().load(url, () => {
                        backgroundTexture.needsUpdate = true;
                        hasBackgroundImage = true;
                        updateSceneBackground();
                        generate();
                    });
                }
            };
            input.click();
        });
        let palette = loadPalette();
        updatePaletteTable();
        loadSceneBackgroundColor();
        loadLowerDomeColor();
    </script>
</body>
</html>
