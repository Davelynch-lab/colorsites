<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>16 Зрелищных Калейдоскопов – Плавный Шар</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0; height: 100vh; overflow: hidden;
      background: linear-gradient(135deg, #0a0a2e 0%, #1a1a4e 50%, #000 100%);
      cursor: grab; font-family: 'Roboto', sans-serif;
      color: white; user-select: none;
    }
    body:active { cursor: grabbing; }
    body.picking { cursor: crosshair; }
    .panel {
      position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.8); backdrop-filter: blur(20px);
      padding: 16px 20px; border-radius: 24px; display: flex; gap: 12px; align-items: center;
      box-shadow: 0 10px 50px rgba(0,0,0,0.8); z-index: 100;
      border: 1px solid rgba(255,255,255,0.1);
    }
    button {
      padding: 12px 18px; font: 600 15px/1 'Roboto', sans-serif;
      background: linear-gradient(45deg, #1a1a99, #2a2abb); color: #fff;
      border: none; border-radius: 16px; cursor: pointer; transition: all .3s ease;
      box-shadow: 0 4px 15px rgba(26,26,153,0.3);
    }
    button:hover {
      transform: scale(1.05); box-shadow: 0 8px 25px rgba(26,26,153,0.6);
      background: linear-gradient(45deg, #2a2abb, #3a3add);
    }
    button.active {
      background: linear-gradient(45deg, #3a3add, #4a4aff); box-shadow: 0 6px 20px rgba(58,58,221,0.5);
    }
    .mode-btn { padding: 10px 14px; font-size: 13px; }
    #patternList {
      display: none; position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.9); backdrop-filter: blur(20px);
      padding: 20px; border-radius: 20px; max-width: 90vw; overflow-x: auto;
      box-shadow: 0 10px 50px rgba(0,0,0,0.8); z-index: 99;
      border: 1px solid rgba(255,255,255,0.1);
    }
    #patternList.active { display: block; }
    .pattern-grid { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
    .pattern-btn {
      padding: 8px 12px; font-size: 12px; background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2); border-radius: 12px; cursor: pointer;
      transition: all .3s; min-width: 60px; text-align: center;
    }
    .pattern-btn:hover { background: rgba(255,255,255,0.3); transform: scale(1.05); }
    .pattern-btn.active { background: rgba(58,58,221,0.8); border-color: #4a4aff; }
    #colorPicker {
      position: fixed; top: 20px; right: 20px; width: 280px; height: 280px;
      background: #fff; border-radius: 16px; cursor: crosshair; z-index: 100;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6); transition: .3s; display: none;
      border: 5px solid #fff;
    }
    #colorPicker.active { display: block; }
    #colorPicker:hover { transform: scale(1.02); }
    @media (max-width: 768px) {
      .panel { flex-direction: column; gap: 8px; padding: 12px 16px; bottom: 10px; }
      button { padding: 10px 14px; font-size: 14px; }
      #patternList { bottom: 120px; padding: 16px; max-width: 95vw; }
      .pattern-grid { gap: 8px; }
      .pattern-btn { padding: 6px 8px; font-size: 11px; min-width: 50px; }
      #colorPicker { width: 240px; height: 240px; top: 10px; right: 10px; }
    }
  </style>
</head>
<body>

<div class="panel">
  <button class="mode-btn active" id="moleculeBtn">Молекула</button>
  <button class="mode-btn" id="carpetBtn">Ковёр</button>
  <button id="patternBtn">Новый узор</button>
</div>

<div id="patternList">
  <div class="pattern-grid">
    <button class="pattern-btn active" data-type="0">Звёзды</button>
    <button class="pattern-btn" data-type="1">Лотос</button>
    <button class="pattern-btn" data-type="2">Ромбы</button>
    <button class="pattern-btn" data-type="3">Круги</button>
    <button class="pattern-btn" data-type="4">Арабески</button>
    <button class="pattern-btn" data-type="5">Галактика</button>
    <button class="pattern-btn" data-type="6">Квадраты</button>
    <button class="pattern-btn" data-type="7">Треугольники</button>
    <button class="pattern-btn" data-type="8">Мандала</button>
    <button class="pattern-btn" data-type="9">Кристалл</button>
    <button class="pattern-btn" data-type="10">Волны</button>
    <button class="pattern-btn" data-type="11">Фрактал</button>
    <button class="pattern-btn" data-type="12">Пыль</button>
    <button class="pattern-btn" data-type="13">Восток</button>
    <button class="pattern-btn" data-type="14">Поле</button>
    <button class="pattern-btn" data-type="15">Вихрь</button>
    <button class="pattern-btn" data-type="16">Линии</button>
    <button class="pattern-btn" data-type="17">Точки</button>
    <button class="pattern-btn" data-type="18">Фигуры</button>
    <button class="pattern-btn" data-type="19">Смешанный</button>
    <button class="pattern-btn" data-type="20">Спираль</button>
    <button class="pattern-btn" data-type="21">Орбиты</button>
    <button class="pattern-btn" data-type="22">Точки в Фигуры</button>
    <button class="pattern-btn" data-type="23">Точки в Смешанный</button>
  </div>
</div>

<div id="colorPicker"></div>

<!-- ШЕЙДЕР ДЛЯ КОВРА (24 УЗОРА) -->
<script id="kaleido-vs" type="x-shader/x-vertex">
  uniform float time;
  uniform float seed;
  varying vec2 vUv;
  varying vec3 vNormal;
  varying vec3 vPos;

  float hash(float n) { return fract(sin(n)*43758.5453); }

  void main() {
    vUv = uv;
    vNormal = normalize(normalMatrix * normal);
    vPos = position;

    float pulse = sin(time * 1.2 + seed) * 0.015;
    vec3 pos = position * (1.0 + pulse * 0.03);

    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
  }
</script>

<script id="kaleido-fs" type="x-shader/x-fragment">
  uniform vec3 color;
  uniform float time;
  uniform float seed;
  uniform float patternType;
  varying vec2 vUv;
  varying vec3 vNormal;

  float hash(float n) { return fract(sin(n)*43758.5453); }
  float hash2(vec2 p) { return hash(dot(p, vec2(12.9898, 78.233))); }

  vec2 kaleido(vec2 uv, float segments) {
    float angle = atan(uv.y, uv.x);
    float radius = length(uv);
    angle = mod(angle, 6.28318 / segments) * segments;
    angle = min(angle, 6.28318 / segments - angle);
    return vec2(cos(angle), sin(angle)) * radius;
  }

  // === 24 УЗОРА (старые + новые из 2D) ===
  float pattern1(vec2 uv, float t, float s) { // Звёздное небо
    uv = kaleido(uv, 8.0);
    uv *= 6.0 + hash(s)*3.0;
    vec2 gv = fract(uv) - 0.5;
    float star = length(gv);
    float arms = abs(sin(atan(gv.y, gv.x)*5.0));
    star = smoothstep(0.15, 0.14, star) * smoothstep(0.4, 0.6, arms);
    float glow = smoothstep(0.3, 0.15, star);
    return star + glow * 0.4;
  }

  float pattern2(vec2 uv, float t, float s) { // Лотос
    uv = kaleido(uv, 6.0);
    uv *= 5.0 + hash(s+1.0)*4.0;
    vec2 gv = fract(uv) - 0.5;
    float flower = 0.0;
    for(float i = 0.0; i < 6.0; i++) {
      float a = i * 1.0472;
      vec2 off = vec2(cos(a), sin(a)) * 0.25;
      float petal = smoothstep(0.12, 0.08, length(gv - off));
      flower = max(flower, petal);
    }
    float center = smoothstep(0.08, 0.06, length(gv));
    return max(flower, center);
  }

  float pattern3(vec2 uv, float t, float s) { // Ромбы
    uv = kaleido(uv, 4.0);
    uv *= 7.0 + hash(s+2.0)*2.0;
    vec2 gv = fract(uv) - 0.5;
    float diamond = abs(gv.x) + abs(gv.y);
    float inner = smoothstep(0.3, 0.28, diamond);
    float border = 1.0 - smoothstep(0.32, 0.34, diamond);
    return inner * border;
  }

  float pattern4(vec2 uv, float t, float s) { // Пульсирующие круги
    uv = kaleido(uv, 8.0);
    uv *= 6.0 + hash(s+3.0)*3.0;
    vec2 gv = fract(uv) - 0.5;
    float r = length(gv);
    float ring = abs(r - 0.2);
    float circle = smoothstep(0.05, 0.04, ring);
    float pulse = sin(t * 3.0 + hash(s+4.0)*6.28) * 0.02;
    return circle + smoothstep(0.06, 0.0, abs(ring - 0.02 - pulse));
  }

  float pattern5(vec2 uv, float t, float s) { // Арабески
    uv = kaleido(uv, 10.0);
    uv *= 5.0 + hash(s+5.0)*4.0;
    vec2 gv = fract(uv) - 0.5;
    float curve = sin(gv.x * 20.0 + t * 1.5) * 0.3;
    float line = abs(gv.y - curve);
    float pattern = smoothstep(0.08, 0.06, line);
    float dot = smoothstep(0.1, 0.08, length(gv));
    return max(pattern, dot);
  }

  float pattern6(vec2 uv, float t, float s) { // Спиральная галактика
    uv = kaleido(uv, 8.0);
    float r = length(uv);
    float a = atan(uv.y, uv.x);
    float spiral = sin(r * 15.0 - a * 8.0 + t * 2.5);
    float thick = smoothstep(0.1, 0.08, abs(spiral));
    float core = smoothstep(0.3, 0.0, r);
    return thick + core * 0.5;
  }

  float pattern7(vec2 uv, float t, float s) { // Квадраты
    uv = kaleido(uv, 8.0);
    uv *= 6.0 + hash(s + 6.0) * 3.0;
    vec2 gv = fract(uv) - 0.5;
    float box = max(abs(gv.x), abs(gv.y));
    return 1.0 - smoothstep(0.4, 0.42, box);
  }

  float pattern8(vec2 uv, float t, float s) { // Треугольники
    uv = kaleido(uv, 6.0);
    uv *= 6.0 + hash(s+7.0)*3.0;
    vec2 gv = fract(uv) - 0.5;
    float tri = abs(gv.x * 1.732) + abs(gv.y);
    float shape = smoothstep(0.35, 0.34, tri);
    float fill = 1.0 - smoothstep(0.36, 0.37, tri);
    return shape * fill;
  }

  float pattern9(vec2 uv, float t, float s) { // Неоновая мандала
    uv = kaleido(uv, 12.0);
    uv *= 4.0 + hash(s+8.0)*3.0;
    vec2 gv = fract(uv) - 0.5;
    float r = length(gv);
    float ring1 = smoothstep(0.05, 0.04, abs(r - 0.15));
    float ring2 = smoothstep(0.05, 0.04, abs(r - 0.25));
    float pulse = sin(t * 4.0 + r * 10.0) * 0.5 + 0.5;
    return max(ring1, ring2) * pulse;
  }

  float pattern10(vec2 uv, float t, float s) { // Кристалл
    uv = kaleido(uv, 6.0);
    uv *= 7.0 + hash(s+9.0)*3.0;
    vec2 gv = fract(uv) - 0.5;
    float edge = max(abs(gv.x), abs(gv.y));
    float facet = smoothstep(0.2, 0.18, edge);
    float shine = pow(smoothstep(0.1, 0.0, abs(gv.x + gv.y)), 2.0);
    return facet + shine * 0.5;
  }

  float pattern11(vec2 uv, float t, float s) { // Волны времени
    uv = kaleido(uv, 6.0);
    uv *= 5.0 + hash(s+10.0)*3.0;
    vec2 gv = fract(uv) - 0.5;
    float wave = sin(gv.x * 15.0 + t * 3.0) * sin(gv.y * 15.0 + t * 2.5);
    return smoothstep(0.7, 0.8, wave);
  }

  float pattern12(vec2 uv, float t, float s) { // Фрактальный цветок
    uv = kaleido(uv, 8.0);
    uv *= 6.0 + hash(s+11.0)*3.0;
    vec2 gv = fract(uv) - 0.5;
    float f = 0.0;
    for(float i = 1.0; i < 4.0; i++) {
      vec2 off = vec2(cos(i*1.57), sin(i*1.57)) * (0.15 / i);
      f = max(f, smoothstep(0.08/i, 0.06/i, length(gv - off)));
    }
    return f;
  }

  float pattern13(vec2 uv, float t, float s) { // Космическая пыль
    uv = kaleido(uv, 10.0);
    uv *= 8.0 + hash(s+12.0)*4.0;
    vec2 gv = fract(uv) - 0.5;
    float dust = hash2(gv + s);
    float star = smoothstep(0.95, 0.98, dust);
    float glow = smoothstep(0.9, 0.95, dust);
    return star + glow * 0.3;
  }

  float pattern14(vec2 uv, float t, float s) { // Восточный узор
    uv = kaleido(uv, 8.0);
    uv *= 5.0 + hash(s+13.0)*3.0;
    vec2 gv = fract(uv) - 0.5;
    float curve1 = sin(gv.x * 18.0 + t * 1.2) * 0.25;
    float curve2 = sin(gv.y * 18.0 + t * 1.5) * 0.25;
    float line1 = abs(gv.y - curve1);
    float line2 = abs(gv.x - curve2);
    float pattern = smoothstep(0.07, 0.05, min(line1, line2));
    return pattern;
  }

  float pattern15(vec2 uv, float t, float s) { // Энергетическое поле
    uv = kaleido(uv, 4.0);
    uv *= 10.0 + hash(s+14.0)*3.0;
    vec2 gv = fract(uv) - 0.5;
    float grid = abs(sin(gv.x * 20.0) * sin(gv.y * 20.0));
    float flash = sin(t * 5.0 + length(gv) * 10.0) * 0.5 + 0.5;
    return smoothstep(0.6, 0.8, grid) * flash;
  }

  float pattern16(vec2 uv, float t, float s) { // Вихрь (улучшенная спираль)
    uv = kaleido(uv, 8.0);
    float r = length(uv);
    float a = atan(uv.y, uv.x);
    float spiral = sin(r * 20.0 - a * 10.0 + t * 3.0);
    float thick = smoothstep(0.15, 0.12, abs(spiral));
    float core = smoothstep(0.25, 0.0, r);
    return thick + core * 0.3;
  }

  float pattern17(vec2 uv, float t, float s) { // Линии
    uv = kaleido(uv, 10.0);
    uv *= 5.0 + hash(s)*2.0;
    vec2 gv = fract(uv) - 0.5;
    float line = abs(gv.y);
    return smoothstep(0.05, 0.03, line);
  }

  float pattern18(vec2 uv, float t, float s) { // Точки
    uv = kaleido(uv, 12.0);
    uv *= 6.0 + hash(s+1.0)*2.0;
    vec2 gv = fract(uv) - 0.5;
    float dot = length(gv);
    return smoothstep(0.02, 0.01, dot);
  }

  float pattern19(vec2 uv, float t, float s) { // Фигуры (квадраты)
    uv = kaleido(uv, 8.0);
    uv *= 7.0 + hash(s+2.0)*2.0;
    vec2 gv = fract(uv) - 0.5;
    float box = max(abs(gv.x), abs(gv.y));
    return smoothstep(0.3, 0.28, box);
  }

  float pattern20(vec2 uv, float t, float s) { // Смешанный
    float p1 = pattern17(uv, t, s);
    float p2 = pattern18(uv, t, s + 1.0);
    float p3 = pattern19(uv, t, s + 2.0);
    return max(p1, max(p2, p3)) * 0.8;
  }

  float pattern21(vec2 uv, float t, float s) { // Спираль
    uv = kaleido(uv, 8.0);
    float r = length(uv);
    float a = atan(uv.y, uv.x);
    float spiral = sin(r * 15.0 - a * 8.0 + t * 2.5);
    return smoothstep(0.1, 0.08, abs(spiral));
  }

  float pattern22(vec2 uv, float t, float s) { // Орбиты (круги)
    uv = kaleido(uv, 12.0);
    float r = length(uv);
    float ring = abs(r - 0.2);
    return smoothstep(0.05, 0.04, ring);
  }

  float pattern23(vec2 uv, float t, float s) { // Точки в Фигуры (морфинг)
    uv = kaleido(uv, 10.0);
    uv *= 6.0 + hash(s)*2.0;
    vec2 gv = fract(uv) - 0.5;
    float dot = length(gv);
    float box = max(abs(gv.x), abs(gv.y));
    float morph = sin(t * 3.0) * 0.5 + 0.5;
    float pat = mix(dot, box, morph);
    return smoothstep(0.15, 0.14, pat);
  }

  float pattern24(vec2 uv, float t, float s) { // Точки в Смешанный
    float p1 = pattern18(uv, t, s);
    float p2 = pattern20(uv, t, s + 1.0);
    float morph = sin(t * 3.0) * 0.5 + 0.5;
    return mix(p1, p2, morph);
  }

  float getPattern(vec2 uv, float t, float s, float type) {
    int idx = int(type);
    if(idx == 0) return pattern1(uv, t, s);
    if(idx == 1) return pattern2(uv, t, s);
    if(idx == 2) return pattern3(uv, t, s);
    if(idx == 3) return pattern4(uv, t, s);
    if(idx == 4) return pattern5(uv, t, s);
    if(idx == 5) return pattern6(uv, t, s);
    if(idx == 6) return pattern7(uv, t, s);
    if(idx == 7) return pattern8(uv, t, s);
    if(idx == 8) return pattern9(uv, t, s);
    if(idx == 9) return pattern10(uv, t, s);
    if(idx == 10) return pattern11(uv, t, s);
    if(idx == 11) return pattern12(uv, t, s);
    if(idx == 12) return pattern13(uv, t, s);
    if(idx == 13) return pattern14(uv, t, s);
    if(idx == 14) return pattern15(uv, t, s);
    if(idx == 15) return pattern16(uv, t, s);
    if(idx == 16) return pattern17(uv, t, s);
    if(idx == 17) return pattern18(uv, t, s);
    if(idx == 18) return pattern19(uv, t, s);
    if(idx == 19) return pattern20(uv, t, s);
    if(idx == 20) return pattern21(uv, t, s);
    if(idx == 21) return pattern22(uv, t, s);
    if(idx == 22) return pattern23(uv, t, s);
    if(idx == 23) return pattern24(uv, t, s);
    return pattern1(uv, t, s); // fallback
  }

  void main() {
    vec2 uv = vUv * 2.0 - 1.0;
    float pat = getPattern(uv, time, seed, patternType);
    vec3 lightDir = normalize(vec3(0.7, 1.0, 0.8));
    float diff = max(dot(vNormal, lightDir), 0.0);
    float ambient = 0.35;
    float spec = pow(max(dot(reflect(-lightDir, vNormal), normalize(vec3(0,0,1))), 0.0), 32.0) * 0.4;
    vec3 base = color;
    vec3 bright = base * 2.0;
    vec3 dark = base * 0.3;
    vec3 final = mix(dark, bright, pat);
    final = final * (ambient + diff * 0.7) + spec * bright;
    gl_FragColor = vec4(final, 1.0);
  }
</script>

<!-- ШЕЙДЕР МОЛЕКУЛЫ -->
<script id="noise" type="x-shader/x-vertex">
  vec3 mod289(vec3 x){return x-floor(x*(1./289.))*289.;}
  vec4 mod289(vec4 x){return x-floor(x*(1./289.))*289.;}
  vec4 permute(vec4 x){return mod289(((x*34.)+10.)*x);}
  vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-.85373472095314*r;}
  float snoise(vec3 v){
    const vec2 C=vec2(1./6.,1./3.); const vec4 D=vec4(0.,.5,1.,2.);
    vec3 i=floor(v+dot(v,C.yyy)); vec3 x0=v-i+dot(i,C.xxx);
    vec3 g=step(x0.yzx,x0.xyz); vec3 l=1.-g; vec3 i1=min(g.xyz,l.zxy); vec3 i2=max(g.xyz,l.zxy);
    vec3 x1=x0-i1+C.xxx; vec3 x2=x0-i2+C.yyy; vec3 x3=x0-D.yyy;
    i=mod289(i);
    vec4 p=permute(permute(permute(i.z+vec4(0.,i1.z,i2.z,1.))+
                          i.y+vec4(0.,i1.y,i2.y,1.))+
                          i.x+vec4(0.,i1.x,i2.x,1.));
    float n_=1./7.; vec3 ns=n_*D.wyz-D.xzx;
    vec4 j=p-49.*floor(p*ns.z*ns.z);
    vec4 x_=floor(j*ns.z); vec4 y_=floor(j-7.*x_);
    vec4 x=x_*ns.x+ns.yyyy; vec4 y=y_*ns.x+ns.yyyy; vec4 h=1.-abs(x)-abs(y);
    vec4 b0=vec4(x.xy,y.xy); vec4 b1=vec4(x.zw,y.zw);
    vec4 s0=floor(b0)*2.+1.; vec4 s1=floor(b1)*2.+1.; vec4 sh=-step(h,vec4(0.));
    vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy; vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;
    vec3 p0=vec3(a0.xy,h.x); vec3 p1=vec3(a0.zw,h.y); vec3 p2=vec3(a1.xy,h.z); vec3 p3=vec3(a1.zw,h.w);
    vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
    p0*=norm.x; p1*=norm.y; p2*=norm.z; p3*=norm.w;
    vec4 m=max(.5-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.);
    m=m*m; return 105.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
  }
  float pattern1(vec3 p){float a=atan(p.z,p.x), r=length(p.xz);return sin(r*12.-time*2.)*.5+.5 * sin(a*8.)*.5+.5;}
  float pattern2(vec3 p){vec3 q=abs(p); float d=max(q.x,max(q.y,q.z));return smoothstep(0.,.3,sin(d*20.-time*3.));}
  float pattern3(vec3 p){float a=atan(p.y,p.x);return sin(a*6.)*sin(length(p.xz)*8.-time)*.5+.5;}
  float pattern4(vec3 p){vec3 pp=p*3.; float tile=fract(pp.x+pp.z);float wave=sin(pp.y*10.+time*2.);return smoothstep(.4,.6,tile+wave*.2);}
  float pattern5(vec3 p){float a=atan(p.z,p.x);float r=length(p.xz);return sin(a*12. + sin(r*8. - time*2.))*0.5+0.5;}
  float pattern6(vec3 p){float a=atan(p.z,p.x);return pow(sin(a*5.)*sin(length(p.xz)*10. - time), 2.)*0.5+0.5;}
  float pattern7(vec3 p){return sin(p.x*15. + time)*sin(p.z*15. + time)*0.5+0.5;}
  float pattern8(vec3 p){vec3 pp = p * 4.0;float grid = fract(pp.x + pp.z);float diamond = abs(fract(pp.x*0.7 + pp.y*0.7) - 0.5) + abs(fract(pp.z*0.7 - pp.y*0.7) - 0.5);float star = sin(pp.x*20. + time)*sin(pp.z*20. + time)*sin(pp.y*10. + time);float pattern = smoothstep(0.4, 0.6, grid) * (1.0 - smoothstep(0.0, 0.4, diamond));return pattern * (star * 0.3 + 0.7);}
  float getPattern(vec3 p){int idx = int(patternIndex);if(idx==0)return pattern1(p);if(idx==1)return pattern2(p);if(idx==2)return pattern3(p);if(idx==3)return pattern4(p);if(idx==4)return pattern5(p);if(idx==5)return pattern6(p);if(idx==6)return pattern7(p);return pattern8(p);}
</script>

<script>
function randomSeed() { return Math.random() * 1000; }
function randomPatternType() { return Math.floor(Math.random() * 24); }

class World{
  constructor(){
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, .1, 1000);
    this.camera.position.z = 3;
    this.renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    this.renderer.setPixelRatio(devicePixelRatio);
    this.renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(this.renderer.domElement);

    this.mode = 'molecule';
    this.molecule = new Molecule(this);
    this.carpet = new Carpet(this);
    this.scene.add(this.molecule);
    this.scene.add(this.carpet);
    this.carpet.visible = false;

    // === ФИКС: Состояние вращения ===
    this.targetRotation = { x: 0, y: 0 };
    this.currentRotation = { x: 0, y: 0 };
    this.isDragging = false;
    this.autoRotate = true;

    this.setupControls();
    this.setupMouseControl();
    this.setupColorPicker();
    window.addEventListener('resize', () => this.resize());
    this.animate();
  }

  setupControls(){
    const moleculeBtn = document.getElementById('moleculeBtn');
    const carpetBtn = document.getElementById('carpetBtn');
    const patternBtn = document.getElementById('patternBtn');
    const patternList = document.getElementById('patternList');

    moleculeBtn.onclick = () => {
      this.mode = 'molecule';
      this.molecule.visible = true;
      this.carpet.visible = false;
      moleculeBtn.classList.add('active');
      carpetBtn.classList.remove('active');
      patternBtn.textContent = 'Новый узор';
      patternList.classList.remove('active');
    };

    carpetBtn.onclick = () => {
      this.mode = 'carpet';
      this.molecule.visible = false;
      this.carpet.visible = true;
      carpetBtn.classList.add('active');
      moleculeBtn.classList.remove('active');
      patternBtn.textContent = 'Выбрать узор';
      patternList.classList.add('active');
      // === ФИКС: Полная генерация при переключении ===
      this.carpet.generatePattern();
    };

    patternBtn.onclick = () => {
      if(this.mode === 'molecule') {
        this.molecule.nextPattern();
      } else {
        patternList.classList.toggle('active');
      }
    };

    // === ФИКС: При выборе узора — полный реген с новым seed ===
    document.querySelectorAll('.pattern-btn').forEach(btn => {
      btn.onclick = () => {
        document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const type = parseFloat(btn.dataset.type);
        this.carpet.setPatternTypeAndRegenerate(type);
      };
    });
  }

  setupMouseControl(){
    const dom = this.renderer.domElement;
    dom.addEventListener('mousedown', e => {
      if (document.body.classList.contains('picking')) return;
      this.isDragging = true;
      this.previousMouse = { x: e.clientX, y: e.clientY };
      this.autoRotate = false;
    });

    dom.addEventListener('mousemove', e => {
      if (!this.isDragging) return;
      const deltaX = e.clientX - this.previousMouse.x;
      const deltaY = e.clientY - this.previousMouse.y;
      this.previousMouse = { x: e.clientX, y: e.clientY };

      const rotSpeed = 0.006;
      this.targetRotation.y += deltaX * rotSpeed;
      this.targetRotation.x += deltaY * rotSpeed;
    });

    const endDrag = () => {
      this.isDragging = false;
      this.autoRotate = true;
    };
    dom.addEventListener('mouseup', endDrag);
    dom.addEventListener('mouseleave', endDrag);
  }

  setupColorPicker(){
    const picker = document.getElementById('colorPicker');
    const toggleBtn = document.createElement('button');
    toggleBtn.innerHTML = 'Palette';
    toggleBtn.style.cssText = 'position:fixed;top:20px;right:20px;z-index:101;background:#fff;border:none;border-radius:50%;width:56px;height:56px;cursor:pointer;font-weight:bold;box-shadow:0 4px 15px rgba(0,0,0,0.4);';
    document.body.appendChild(toggleBtn);

    toggleBtn.onclick = () => {
      picker.classList.toggle('active');
      document.body.classList.toggle('picking');
    };

    const canvas = document.createElement('canvas');
    canvas.width = 280; canvas.height = 280;
    const ctx = canvas.getContext('2d');
    const hueGrad = ctx.createLinearGradient(0,0,280,0);
    ['#ff0000','#ffff00','#00ff00','#00ffff','#0000ff','#ff00ff','#ff0000'].forEach((c,i)=>hueGrad.addColorStop(i/6,c));
    ctx.fillStyle = hueGrad; ctx.fillRect(0,0,280,280);

    // Append canvas to picker
    picker.appendChild(canvas);

    // Click listener on canvas
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const img = ctx.getImageData(x, y, 1, 1).data;
      const r = img[0], g = img[1], b = img[2];
      const color = (r << 16) | (g << 8) | b;
      if(this.mode === 'molecule') this.molecule.setColor(color);
      else this.carpet.setColor(color);
    });
  }

  resize(){
    const w = innerWidth, h = innerHeight;
    this.camera.aspect = w/h; this.camera.updateProjectionMatrix();
    this.renderer.setSize(w, h);
  }

  animate = () => {
    requestAnimationFrame(this.animate);
    const t = performance.now() * 0.001;

    // === ФИКС: Плавное вращение ===
    if (this.autoRotate) {
      this.targetRotation.y = t * 0.2;
    }

    // Плавная интерполяция углов
    this.currentRotation.x += (this.targetRotation.x - this.currentRotation.x) * 0.1;
    this.currentRotation.y += (this.targetRotation.y - this.currentRotation.y) * 0.1;

    this.molecule.rotation.x = this.currentRotation.x;
    this.molecule.rotation.y = this.currentRotation.y;
    this.carpet.rotation.x = this.currentRotation.x;
    this.carpet.rotation.y = this.currentRotation.y;

    this.molecule.animate(t);
    this.carpet.animate(t);
    this.renderer.render(this.scene, this.camera);
  };
}

// === ФИКС: Класс Carpet с регенерацией при смене узора ===
class Carpet extends THREE.Mesh{
  constructor(world){
    super();
    this.world = world;
    this.geometry = new THREE.SphereGeometry(1.5, 512, 256);
    this.material = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        color: { value: new THREE.Color(0x101a88) },
        seed: { value: 0 },
        patternType: { value: 0 }
      },
      vertexShader: document.getElementById('kaleido-vs').textContent,
      fragmentShader: document.getElementById('kaleido-fs').textContent
    });
  }

  generatePattern(){
    this.material.uniforms.seed.value = randomSeed();
    this.material.uniforms.patternType.value = randomPatternType();
  }

  // === НОВЫЙ МЕТОД: смена узора + новый seed ===
  setPatternTypeAndRegenerate(type) {
    this.material.uniforms.seed.value = randomSeed();
    this.material.uniforms.patternType.value = type;
  }

  setColor(hex){
    this.material.uniforms.color.value.setHex(hex);
  }

  animate(t){
    this.material.uniforms.time.value = t;
  }
}

// Molecule без изменений
class Molecule extends THREE.Object3D{
  constructor(world){ super(); this.world = world; this.radius=1.5; this.detail=40; this.pMin=0.01; this.pMax=0.08; this.patternIdx=0; this.currentColor = 0x101a88;
    const geom=new THREE.IcosahedronBufferGeometry(1,this.detail);
    const mat=new THREE.PointsMaterial({map:this.dotTex(),blending:THREE.AdditiveBlending,color:this.currentColor,depthTest:false,transparent:true,sizeAttenuation:true});
    this.setupShader(mat); this.mesh=new THREE.Points(geom,mat); this.add(this.mesh);
  }
  dotTex(size=64){ const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d'); const g=ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2); g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(.3,'rgba(200,220,255,.9)'); g.addColorStop(1,'rgba(100,140,220,0)'); ctx.fillStyle=g; ctx.fillRect(0,0,size,size); return new THREE.CanvasTexture(c); }
  setupShader(mat){ mat.onBeforeCompile=shader=>{ shader.uniforms.time={value:0}; shader.uniforms.radius={value:this.radius}; shader.uniforms.pMin={value:this.pMin}; shader.uniforms.pMax={value:this.pMax}; shader.uniforms.patternIndex={value:this.patternIdx}; shader.vertexShader=document.getElementById('noise').textContent+'\n'+shader.vertexShader; shader.vertexShader=`uniform float time;uniform float radius;uniform float pMin;uniform float pMax;uniform float patternIndex;`+shader.vertexShader; shader.vertexShader=shader.vertexShader.replace('#include <begin_vertex>',`vec3 p=position;float n=snoise(vec3(p.x*.6+time*.2,p.y*.4+time*.3,p.z*.2+time*.2));p+=n*.3;float pat=getPattern(p);float intensity=pat*.6+n*.4;float l=radius/length(p);p*=l;float s=mix(pMin,pMax,intensity);vec3 transformed=p;`); shader.vertexShader=shader.vertexShader.replace('gl_PointSize = size;','gl_PointSize = s;'); mat.userData.shader=shader; }; }
  nextPattern(){ this.patternIdx=(this.patternIdx+1)%8; if(this.mesh.material.userData.shader) this.mesh.material.userData.shader.uniforms.patternIndex.value=this.patternIdx; }
  setColor(hex){ this.currentColor = hex; this.mesh.material.color.setHex(hex); }
  animate(t){ if(this.mesh.material.userData.shader) this.mesh.material.userData.shader.uniforms.time.value=t; }
}

document.addEventListener('DOMContentLoaded', () => {
  new World();
});
</script>
</body>
</html>
