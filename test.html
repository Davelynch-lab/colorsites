<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор калейдоскопов в 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.138.0/build/three.module.js",
                "OrbitControls": "https://unpkg.com/three@0.138.0/examples/jsm/controls/OrbitControls.js"
            }
        }
    </script>
    <style>
        body {
            background: white;
            min-height: 100vh;
        }
        #previewContainer, #fullContainer {
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1/1;
            margin: auto;
        }
        #fullContainer {
            max-width: 800px;
        }
        canvas {
            border: 2px solid #e5e7eb;
            border-radius: 8px;
        }
        .color-btn {
            width: 100%;
            height: 36px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            transition: transform 0.2s;
        }
        .color-btn:hover {
            transform: scale(1.05);
        }
        .delete-btn {
            background: #e74c3c;
            color: white;
            padding: 6px;
            border-radius: 6px;
            font-size: 12px;
            transition: background 0.3s;
        }
        .delete-btn:hover {
            background: #c0392b;
        }
        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        #backgroundColorPreview {
            width: 100%;
            height: 36px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
        }
        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        }
        .custom-range::-webkit-slider-thumb {
            background: #7c3aed;
        }
        .custom-range::-moz-range-thumb {
            background: #7c3aed;
        }
        #imageModal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 50;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        #imageModal.show {
            display: flex;
        }
        details summary {
            cursor: pointer;
            font-size: 1.25rem;
            font-weight: 600;
            color: #4c1d95;
            padding: 0.5rem;
        }
        details summary:hover {
            color: #7c3aed;
        }
        details p {
            margin-top: 0.5rem;
            color: #374151;
        }
        #animateBtn, #recordBtn {
            background: linear-gradient(45deg, #7c3aed, #4c1d95);
            color: white;
            transition: transform 0.3s, background 0.3s;
        }
        #animateBtn:hover, #recordBtn:hover {
            transform: scale(1.05);
            background: linear-gradient(45deg, #9f67ff, #6b46c1);
        }
        #animateBtn.active, #recordBtn.active {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.75rem;
        }
        .action-buttons button {
            flex: 1;
            padding: 0.75rem;
            font-size: 0.9rem;
        }
    </style>
</head>
<body class="font-sans text-gray-900">
    <div class="container mx-auto p-4 sm:p-6 md:p-8 max-w-7xl">
        <details class="card p-4 rounded-xl shadow-lg mb-6">
            <summary>Инструкции</summary>
            <p>Добро пожаловать в Генератор калейдоскопов в 3D! Следуйте этим шагам:</p>
            <ul class="list-disc pl-5 mt-2">
                <li><strong>Выбор узора:</strong> Выберите тип узора (Линии, Точки, Фигуры, Смешанный, Ветви, Спираль, Орбиты, Точки в Фигуры).</li>
                <li><strong>Настройка параметров:</strong> Регулируйте количество элементов (100–1000), секторов (3–40) и скорость анимации (0.05–0.5).</li>
                <li><strong>Палитра:</strong> Добавляйте до 20 цветов, удаляйте или изменяйте их.</li>
                <li><strong>Генерация:</strong> Нажмите "Сгенерировать" для создания узора внутри 3D сферы.</li>
                <li><strong>Анимация:</strong> Нажмите "Анимировать" для запуска плавной анимации. Повторное нажатие останавливает.</li>
                <li><strong>Запись видео:</strong> Нажмите "Старт/Стоп запись" для записи анимации. Нажмите "Скачать видео" для сохранения в MP4.</li>
                <li><strong>Просмотр:</strong> Нажмите "Открыть полное изображение" для просмотра анимированного узора в 3D с возможностью вращения.</li>
                <li><strong>Сохранение:</strong> Нажмите "Сохранить изображение" для скачивания PNG (статичное изображение).</li>
                <li><strong>Возврат:</strong> Нажмите "← Вернуться" для возврата на главную.</li>
            </ul>
        </details>
        <h1 class="text-3xl sm:text-4xl font-extrabold text-center text-indigo-700 mb-8 drop-shadow-lg">Генератор калейдоскопов в 3D</h1>
        <div class="flex flex-col items-center gap-6">
            <div class="space-y-6 w-full max-w-3xl">
                <div class="card p-6 rounded-xl shadow-lg flex justify-center items-center">
                    <div>
                        <h2 class="text-xl font-semibold mb-4 text-indigo-700 text-center">Предпросмотр (3D сферы)</h2>
                        <div id="previewContainer"></div> <!-- Контейнер для 3D предпросмотра -->
                    </div>
                </div>
                <div class="card p-6 rounded-xl shadow-lg">
                    <div class="action-buttons">
                        <button id="generateBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="Создать узор">Сгенерировать</button>
                        <button id="animateBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="Запустить/остановить анимацию">Анимировать</button>
                        <button id="recordBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="Начать/остановить запись видео">Старт запись</button>
                        <button id="downloadVideoBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="Скачать записанное видео" disabled>Скачать видео</button>
                        <button id="viewBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="Открыть узор">Открыть полное изображение</button>
                        <button id="saveBtn" class="bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" title="Сохранить узор">Сохранить изображение</button>
                        <span id="recordTimer" class="text-gray-700 font-medium">Запись: 00:00</span>
                    </div>
                </div>
            </div>
            <div class="space-y-6 w-full max-w-3xl">
                <div class="card p-6 rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 text-indigo-700">Настройки узора</h2>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium mb-1 text-gray-700">Тип узора</label>
                            <select id="modeCombo" class="w-full p-3 border border-gray-300 rounded-lg bg-white focus:ring-2 focus:ring-indigo-500" title="Выберите тип узора">
                                <option>Линии</option>
                                <option>Точки</option>
                                <option>Фигуры</option>
                                <option>Смешанный</option>
                                <!-- <option>Ветви</option> -->
                                <option>Спираль</option>
                                <option>Орбиты</option>
                                <option>Точки в Фигуры</option>
                                <option>Точки в Смешанный</option>
                                <option value="Crystal"><a href="kalei.html">Кристаллическое (избранное)</a></option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-1 text-gray-700">Количество элементов: <span id="elementValue" class="font-bold">300</span></label>
                            <input type="range" id="elementSlider" min="100" max="1000" value="300" class="w-full custom-range" title="Количество элементов">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-1 text-gray-700">Количество секторов: <span id="slicesValue" class="font-bold">13</span></label>
                            <input type="range" id="slicesSlider" min="3" max="40" value="13" class="w-full custom-range" title="Количество секторов">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-1 text-gray-700">Скорость анимации: <span id="animationSpeedValue" class="font-bold">0.1</span></label>
                            <input type="range" id="animationSpeedSlider" min="0.05" max="0.5" step="0.01" value="0.1" class="w-full custom-range" title="Скорость анимации">
                        </div>
                    </div>
                </div>
                <div class="card p-6 rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 text-indigo-700">Палитра цветов</h2>
                    <div class="overflow-x-auto">
                        <table id="paletteTable" class="w-full border-collapse mb-4">
                            <thead>
                                <tr>
                                    <th class="border-b-2 p-3 text-left text-gray-700 w-16">Ключ</th>
                                    <th class="border-b-2 p-3 text-left text-gray-700">Цвет</th>
                                    <th class="border-b-2 p-3 text-left text-gray-700 w-24">Действие</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-3">
                        <button id="addColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 transition-colors" title="Добавить цвет">Добавить цвет</button>
                        <button id="removeColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 transition-colors" title="Удалить последний цвет">Удалить последний</button>
                        <button id="changeBackgroundColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 transition-colors" title="Изменить цвет фона">Выбрать цвет фона</button>
                        <button id="changeLowerColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 transition-colors" title="Изменить цвет нижней части">Выбрать цвет нижней части</button>
                        <button id="uploadBackgroundImageBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 transition-colors" title="Загрузить тексутуру">Загрузить текстуру</button>
                    </div>
                </div>
            </div>
        </div>
        <button id="home" class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 transition-colors" style="margin-top: 20px;" title="Вернуться">← Вернуться</button>
        <div id="imageModal" class="fixed inset-0 bg-black bg-opacity-70 hidden flex items-center justify-center p-4 z-50">
            <div class="bg-white p-6 rounded-xl max-w-[90vw] max-h-[90vh] overflow-auto">
                <div id="fullContainer"></div> <!-- Контейнер для полного 3D вида -->
                <div class="text-center mt-4">
                    <button id="closeModalBtn" class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 transition-colors" title="Закрыть">Закрыть</button>
                </div>
            </div>
        </div>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'OrbitControls';
        const DPI = 300;
        const CM_TO_INCH = 1 / 2.54;
        const MAIN_CM = 15;
        const MAIN_PX = Math.round(MAIN_CM * CM_TO_INCH * DPI);
        const CANVAS_PX = 512; // Увеличили для лучшей текстуры в 3D
        const MOBILE_RECORDING_PX = 1280;
        const MAX_RECORDING_DURATION = 60;
        let ANIMATION_SPEED = 0.1;
        let sceneBackgroundColor = [255, 255, 255, 1]; // По умолчанию белый цвет фона
        let lowerDomeColor = [255, 255, 255, 1]; // По умолчанию белый цвет нижней части
        let hasBackgroundImage = false;
        let backgroundTexture = null;
        const DEFAULT_PALETTE = {
            '1': [245, 245, 220, 1],
            '2': [0, 0, 0, 1],
            '3': [255, 255, 0, 1],
            '4': [255, 0, 255, 1]
        };
        const AVAILABLE_COLORS = [
            [245, 245, 220, 1],
            [255, 255, 0, 1],
            [0, 0, 0, 1],
            [255, 0, 255, 1],
            [144, 238, 144, 1]
        ];
        let colorIndex = 0;
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        class KaleidoGenerator {
            constructor(size_px, palette, mode = 'Lines', sectors = 12, elements = 300, slices = 13) {
                this.size = size_px;
                this.palette = Object.values(palette);
                this.mode = mode;
                this.sectors = sectors;
                this.elements = Math.min(elements, 500);
                this.slices = slices;
                this.branch_settings = {
                    size: 150,
                    angle: 0.4,
                    scale: 0.67,
                    iterations: Math.max(1, Math.floor(elements / 100)),
                    offset: 0,
                    spiral_density: 0.05,
                };
                this.elementsData = [];
                this.initElements();
            }
            initElements() {
                this.elementsData = [];
                const angle = 360 / this.sectors;
                if (this.mode === 'Lines') {
                    for (let i = 0; i < this.elements; i++) {
                        this.elementsData.push({
                            r1: Math.random(),
                            theta1: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            r2: Math.random(),
                            theta2: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * this.palette.length),
                            lineWidth: Math.floor(Math.random() * 4) + 1
                        });
                    }
                } else if (this.mode === 'Dots') {
                    for (let i = 0; i < this.elements; i++) {
                        this.elementsData.push({
                            r: Math.random(),
                            theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * this.palette.length),
                            size_dot: Math.random() * 6 + 2
                        });
                    }
                } else if (this.mode === 'Shapes') {
                    for (let i = 0; i < this.elements; i++) {
                        this.elementsData.push({
                            r: Math.random(),
                            theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * this.palette.length),
                            size_sq: Math.random() * 15 + 5
                        });
                    }
                } else if (this.mode === 'Mixed') {
                    for (let i = 0; i < this.elements; i++) {
                        const type = ['Lines', 'Dots', 'Shapes'][Math.floor(Math.random() * 3)];
                        if (type === 'Lines') {
                            this.elementsData.push({
                                type: 'Lines',
                                r1: Math.random(),
                                theta1: (Math.random() * angle - angle / 2) * Math.PI / 180,
                                r2: Math.random(),
                                theta2: (Math.random() * angle - angle / 2) * Math.PI / 180,
                                colorIdx: Math.floor(Math.random() * this.palette.length),
                                lineWidth: Math.floor(Math.random() * 4) + 1
                            });
                        } else if (type === 'Dots') {
                            this.elementsData.push({
                                type: 'Dots',
                                r: Math.random(),
                                theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                                colorIdx: Math.floor(Math.random() * this.palette.length),
                                size_dot: Math.random() * 6 + 2
                            });
                        } else {
                            this.elementsData.push({
                                type: 'Shapes',
                                r: Math.random(),
                                theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                                colorIdx: Math.floor(Math.random() * this.palette.length),
                                size_sq: Math.random() * 15 + 5
                            });
                        }
                    }
                } else if (this.mode === 'Spiral') {
                    const spiral_count = Math.floor(this.elements / 10);
                    for (let i = 0; i < spiral_count; i++) {
                        this.elementsData.push({
                            theta_start: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            color_idx: Math.floor(Math.random() * this.palette.length)
                        });
                    }
                } else if (this.mode === 'Orbit') {
                    const diameter = this.size;
                    const a = 0.266746, b = 0.321596, c = 0.223138;
                    this.elementsData = [
                        { class: 'a', width: diameter * a, top: (diameter/2 - (diameter*a/2)) * 0.60, left: diameter/2 - (diameter*a/2), blink: 'blink-lightest', speed: 5*a, delay: 2*a },
                        { class: 'a', width: diameter * a, top: (diameter/2 - (diameter*a/2)) * 1.22, left: (diameter/2 - (diameter*a/2)) * 0.65, blink: 'blink-lightest', speed: 5*a, delay: 1*a },
                        { class: 'a', width: diameter * a, top: (diameter/2 - (diameter*a/2)) * 1.22, right: (diameter/2 - (diameter*a/2)) * 0.65, blink: 'blink-lightest', speed: 5*a, delay: 1*a },
                        { class: 'b', width: diameter * b, top: (diameter/2 - (diameter*b/2)) * 0.52, left: diameter*b/7, blink: 'blink-lightest', speed: 5*b, delay: 1*b },
                        { class: 'b', width: diameter * b, top: (diameter/2 - (diameter*b/2)) * 0.52, right: diameter*b/7, blink: 'blink-lightest', speed: 5*b, delay: 1*b },
                        { class: 'b', width: diameter * b, bottom: 0, left: diameter/2 - (diameter*b/2), blink: 'blink', speed: 5*b, delay: 2*b },
                        { class: 'c', width: diameter * c, top: diameter*c/15, left: diameter*c * 1.23, blink: 'blink-lightest', speed: 6*c, delay: 3*c },
                        { class: 'c', width: diameter * c, top: diameter*c/15, right: diameter*c * 1.23, blink: 'blink-lightest', speed: 6*c, delay: 2*c },
                        { class: 'c', width: diameter * c, bottom: diameter*c/2.3, left: diameter*c * 0.55, blink: 'blink-lightest', speed: 6*c, delay: 4*c },
                        { class: 'c', width: diameter * c, bottom: diameter*c * 1.3, left: diameter*c * 0.05, blink: 'blink-lightest', speed: 6*c, delay: 3*c },
                        { class: 'c', width: diameter * c, bottom: diameter*c/2.3, right: diameter*c * 0.55, blink: 'blink-lightest', speed: 6*c, delay: 2*c },
                        { class: 'c', width: diameter * c, bottom: diameter*c * 1.3, right: diameter*c * 0.05, blink: 'blink-lightest', speed: 6*c, delay: 3*c },
                        { class: 'center', width: diameter * a, top: diameter/2 - (diameter*a/2), left: diameter/2 - (diameter*a/2), blink: 'blink', speed: 3, delay: 0 },
                        { class: 'tile-cover', width: diameter, top: 0, left: 0, blink: 'blink', speed: 3, delay: 1 },
                        { class: 'tile-back', width: diameter, top: 0, left: 0, blink: 'blink', speed: 5, delay: 2 },
                    ];
                } else if (this.mode === 'DotToShape') {
                    for (let i = 0; i < this.elements; i++) {
                        this.elementsData.push({
                            r: Math.random(),
                            theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * this.palette.length),
                            size_dot: Math.random() * 6 + 2,
                            size_sq: Math.random() * 15 + 5
                        });
                    }
                } else if (this.mode === 'DotsToMixed') {
                    for (let i = 0; i < this.elements; i++) {
                        const type = ['Lines', 'Dots', 'Shapes'][Math.floor(Math.random() * 3)];
                        this.elementsData.push({
                            r: Math.random(),
                            theta: (Math.random() * angle - angle / 2) * Math.PI / 180,
                            colorIdx: Math.floor(Math.random() * this.palette.length),
                            size_dot: Math.random() * 6 + 2,
                            type: type,
                            r1: type === 'Lines' ? Math.random() : null,
                            theta1: type === 'Lines' ? (Math.random() * angle - angle / 2) * Math.PI / 180 : null,
                            r2: type === 'Lines' ? Math.random() : null,
                            theta2: type === 'Lines' ? (Math.random() * angle - angle / 2) * Math.PI / 180 : null,
                            lineWidth: type === 'Lines' ? Math.floor(Math.random() * 4) + 1 : null,
                            size_sq: type === 'Shapes' ? Math.random() * 15 + 5 : null
                        });
                    }
                }
            }
            generateTextureCanvas(animate = false, animationTime = 0) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = this.size;
                canvas.height = this.size;
                ctx.fillStyle = `rgba(${sceneBackgroundColor[0]}, ${sceneBackgroundColor[1]}, ${sceneBackgroundColor[2]}, ${sceneBackgroundColor[3]})`;
                ctx.fillRect(0, 0, this.size, this.size);
                ctx.globalAlpha = animate ? 0.9 : 1.0;
                const main = this._makeKaleidoSquare(animate, animationTime);
                ctx.drawImage(main, 0, 0);
                ctx.globalAlpha = 1.0;
                return canvas;
            }
            _interpolateColor(color1, color2, factor) {
                return [
                    Math.round(color1[0] * (1 - factor) + color2[0] * factor),
                    Math.round(color1[1] * (1 - factor) + color2[1] * factor),
                    Math.round(color1[2] * (1 - factor) + color2[2] * factor),
                    color1[3] * (1 - factor) + color2[3] * factor
                ];
            }
            _makeTrianglifyPattern(width, height, t) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                const cell_size = 50;
                for (let i = 0; i < width; i += cell_size) {
                    for (let j = 0; j < height; j += cell_size) {
                        const points = [
                            [i, j],
                            [i + cell_size, j],
                            [i + cell_size, j + cell_size],
                            [i, j + cell_size],
                        ];
                        const color1 = this.palette[Math.floor(Math.random() * this.palette.length)];
                        const color2 = this.palette[Math.floor(Math.random() * this.palette.length)];
                        const factor = t ? (Math.sin(t + i * 0.1 + j * 0.1) + 1) / 2 : 0;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color1, color2, factor).join(',')})`;
                        ctx.beginPath();
                        ctx.moveTo(points[0][0], points[0][1]);
                        ctx.lineTo(points[1][0], points[1][1]);
                        ctx.lineTo(points[2][0], points[2][1]);
                        ctx.fill();
                        ctx.fillStyle = `rgba(${this._interpolateColor(color2, color1, factor).join(',')})`;
                        ctx.beginPath();
                        ctx.moveTo(points[0][0], points[0][1]);
                        ctx.lineTo(points[2][0], points[2][1]);
                        ctx.lineTo(points[3][0], points[3][1]);
                        ctx.fill();
                    }
                }
                return canvas;
            }
            _makeKaleidoSquare(animate, animationTime) {
                const canvas = document.createElement('canvas');
                canvas.width = this.size;
                canvas.height = this.size;
                const ctx = canvas.getContext('2d');
                const radius = this.size / 2;
                const angle = 360 / this.sectors;
                const cx = radius, cy = radius;
                const t = animate ? animationTime * ANIMATION_SPEED : 0;
                const rotationOffset = Math.sin(t) * 0.4;
                if (this.mode === 'Lines') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.strokeStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        const x1 = cx + data.r1 * radius * Math.cos(data.theta1 + thetaOffset);
                        const y1 = cy + data.r1 * radius * Math.sin(data.theta1 + thetaOffset);
                        const x2 = cx + data.r2 * radius * Math.cos(data.theta2 + thetaOffset);
                        const y2 = cy + data.r2 * radius * Math.sin(data.theta2 + thetaOffset);
                        ctx.lineWidth = data.lineWidth * (1 + Math.sin(t + i * 0.3) * 0.8);
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                } else if (this.mode === 'Dots') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                        const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                        const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                        ctx.beginPath();
                        ctx.arc(x, y, size_dot, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                } else if (this.mode === 'Shapes') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                        const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                        const size_sq = data.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8);
                        ctx.fillRect(x - size_sq, y - size_sq, size_sq * 2, size_sq * 2);
                    }
                } else if (this.mode === 'Mixed') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        ctx.strokeStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        if (data.type === 'Lines') {
                            const x1 = cx + data.r1 * radius * Math.cos(data.theta1 + thetaOffset);
                            const y1 = cy + data.r1 * radius * Math.sin(data.theta1 + thetaOffset);
                            const x2 = cx + data.r2 * radius * Math.cos(data.theta2 + thetaOffset);
                            const y2 = cy + data.r2 * radius * Math.sin(data.theta2 + thetaOffset);
                            ctx.lineWidth = data.lineWidth * (1 + Math.sin(t + i * 0.3) * 0.8);
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        } else if (data.type === 'Dots') {
                            const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                            const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                            const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                            ctx.beginPath();
                            ctx.arc(x, y, size_dot, 0, 2 * Math.PI);
                            ctx.fill();
                        } else {
                            const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                            const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                            const size_sq = data.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8);
                            ctx.fillRect(x - size_sq, y - size_sq, size_sq * 2, size_sq * 2);
                        }
                    }
                } else if (this.mode === 'Spiral') {
                    const s = this.branch_settings;
                    for (let i = 0; i < this.elementsData.length; i++) {
                        let theta_start = this.elementsData[i].theta_start + t * 0.3;
                        let color_idx = this.elementsData[i].color_idx;
                        const next_color_idx = (color_idx + 1) % this.palette.length;
                        for (let r = 0; r < radius; r += 2) {
                            const theta = theta_start + r * s.spiral_density;
                            const x = cx + r * Math.cos(theta);
                            const y = cy + r * Math.sin(theta);
                            const colorFactor = (Math.sin(t + r * 0.02) + 1) / 2;
                            const r_col = Math.round(this.palette[color_idx][0] * (1 - colorFactor) + this.palette[next_color_idx][0] * colorFactor);
                            const g_col = Math.round(this.palette[color_idx][1] * (1 - colorFactor) + this.palette[next_color_idx][1] * colorFactor);
                            const b_col = Math.round(this.palette[color_idx][2] * (1 - colorFactor) + this.palette[next_color_idx][2] * colorFactor);
                            const a_col = this.palette[color_idx][3] * (1 - colorFactor) + this.palette[next_color_idx][3] * colorFactor;
                            const width = Math.max(2, 4 + Math.sin(r * 0.03 + t) * 5);
                            ctx.fillStyle = `rgba(${r_col}, ${g_col}, ${b_col}, ${a_col})`;
                            ctx.beginPath();
                            ctx.arc(x, y, width, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    }
                } else if (this.mode === 'Orbit') {
                    const diameter = this.size;
                    for (const config of this.elementsData) {
                        const width = config.width;
                        const height = width;
                        let x = config.left !== undefined ? config.left : diameter - config.right - width;
                        let y = config.top !== undefined ? config.top : diameter - config.bottom - height;
                        x = cx + (x - diameter/2) * (1 + Math.sin(t) * 0.3);
                        y = cy + (y - diameter/2) * (1 + Math.cos(t) * 0.3);
                        const opacity = config.blink === 'blink' ? 0.5 + 0.5 * Math.sin(t / config.speed) :
                                        config.blink === 'blink-lighter' ? 0.3 + 0.2 * Math.sin(t / config.speed) :
                                        0.375 + 0.375 * Math.sin(t / config.speed);
                        const pattern = this._makeTrianglifyPattern(width, height, t);
                        ctx.globalAlpha = opacity;
                        ctx.drawImage(pattern, x, y, width, height);
                        ctx.globalAlpha = 1;
                        ctx.strokeStyle = `rgba(0, 0, 255, ${0.5 + Math.sin(t) * 0.5})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(x + width / 2, y + height / 2, width / 2, 0, 2 * Math.PI);
                        ctx.stroke();
                    }
                } else if (this.mode === 'DotToShape') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                        const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                        const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                        const size_sq = data.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8);
                        const shapeFactor = (Math.sin(t * 2) + 1) / 2;
                        const size = size_dot * (1 - shapeFactor) + size_sq * shapeFactor;
                        const cornerRadius = size * (1 - shapeFactor);
                        ctx.beginPath();
                        ctx.moveTo(x - size + cornerRadius, y - size);
                        ctx.lineTo(x + size - cornerRadius, y - size);
                        ctx.arcTo(x + size, y - size, x + size, y - size + cornerRadius, cornerRadius);
                        ctx.lineTo(x + size, y + size - cornerRadius);
                        ctx.arcTo(x + size, y + size, x + size - cornerRadius, y + size, cornerRadius);
                        ctx.lineTo(x - size + cornerRadius, y + size);
                        ctx.arcTo(x - size, y + size, x - size, y + size - cornerRadius, cornerRadius);
                        ctx.lineTo(x - size, y - size + cornerRadius);
                        ctx.arcTo(x - size, y - size, x - size + cornerRadius, y - size, cornerRadius);
                        ctx.closePath();
                        ctx.fill();
                    }
                } else if (this.mode === 'DotsToMixed') {
                    for (let i = 0; i < this.elementsData.length; i++) {
                        const data = this.elementsData[i];
                        const color = this.palette[data.colorIdx];
                        const nextColor = this.palette[(data.colorIdx + 1) % this.palette.length];
                        const colorFactor = (Math.sin(t + i * 0.3) + 1) / 2;
                        ctx.fillStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        ctx.strokeStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                        const thetaOffset = Math.sin(t + i * 0.3) * 0.4;
                        const x = cx + data.r * radius * Math.cos(data.theta + thetaOffset);
                        const y = cy + data.r * radius * Math.sin(data.theta + thetaOffset);
                        const shapeFactor = (Math.sin(t * 2) + 1) / 2;
                        if (shapeFactor < 0.5) {
                            const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8);
                            ctx.beginPath();
                            ctx.arc(x, y, size_dot * (1 - shapeFactor * 2), 0, 2 * Math.PI);
                            ctx.fill();
                        } else {
                            if (data.type === 'Lines') {
                                const x1 = cx + data.r1 * radius * Math.cos(data.theta1 + thetaOffset);
                                const y1 = cy + data.r1 * radius * Math.sin(data.theta1 + thetaOffset);
                                const x2 = cx + data.r2 * radius * Math.cos(data.theta2 + thetaOffset);
                                const y2 = cy + data.r2 * radius * Math.sin(data.theta2 + thetaOffset);
                                ctx.lineWidth = data.lineWidth * (1 + Math.sin(t + i * 0.3) * 0.8) * (shapeFactor * 2 - 1);
                                ctx.beginPath();
                                ctx.moveTo(x1, y1);
                                ctx.lineTo(x2, y2);
                                ctx.stroke();
                            } else if (data.type === 'Dots') {
                                const size_dot = data.size_dot * (1 + Math.sin(t + i * 0.3) * 0.8) * (shapeFactor * 2 - 1);
                                ctx.beginPath();
                                ctx.arc(x, y, size_dot, 0, 2 * Math.PI);
                                ctx.fill();
                            } else {
                                const size_sq = data.size_sq * (1 + Math.sin(t + i * 0.3) * 0.8) * (shapeFactor * 2 - 1);
                                ctx.fillRect(x - size_sq, y - size_sq, size_sq * 2, size_sq * 2);
                            }
                        }
                    }
                }
                const full = document.createElement('canvas');
                full.width = this.size;
                full.height = this.size;
                const fullCtx = full.getContext('2d');
                fullCtx.fillStyle = `rgba(${sceneBackgroundColor[0]}, ${sceneBackgroundColor[1]}, ${sceneBackgroundColor[2]}, ${sceneBackgroundColor[3]})`;
                fullCtx.fillRect(0, 0, this.size, this.size);
                for (let i = 0; i < this.sectors; i++) {
                    fullCtx.save();
                    fullCtx.translate(cx, cy);
                    fullCtx.rotate((angle * i + rotationOffset) * Math.PI / 180);
                    if (i % 2 === 1) {
                        fullCtx.scale(-1, 1);
                    }
                    fullCtx.drawImage(canvas, -cx, -cy);
                    fullCtx.restore();
                }
                return full;
            }
            _drawShape(x, y, angle, size, ctx, points, t) {
                this._drawBranch(x, y, angle, size, 1, ctx, points, t);
                this._drawBranch(x, y, angle, size, -1, ctx, points, t);
            }
            _drawBranch(x, y, angle, size, direction, ctx, points, t) {
                const s = this.branch_settings;
                const new_angle = angle + (s.angle * direction + s.offset) + Math.sin(t) * 0.3;
                const new_size = size * s.scale * (1 + Math.sin(t) * 0.2);
                const x2 = x + Math.cos(new_angle) * new_size;
                const y2 = y + Math.sin(new_angle) * new_size;
                const color = this.palette[Math.floor(Math.random() * this.palette.length)];
                const nextColor = this.palette[(Math.floor(Math.random() * this.palette.length) + 1) % this.palette.length];
                const colorFactor = (Math.sin(t) + 1) / 2;
                ctx.strokeStyle = `rgba(${this._interpolateColor(color, nextColor, colorFactor).join(',')})`;
                ctx.lineWidth = 2 * (1 + Math.sin(t) * 0.8);
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                points.push({ x: x2, y: y2, angle: new_angle, size: new_size });
            }
        }
        let currentTextureCanvas = null;
        let isAnimating = false;
        let isFullAnimating = false;
        let isRecording = false;
        let animationFrameId = null;
        let fullAnimationFrameId = null;
        let startTime = null;
        let fullStartTime = null;
        let generator = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordTimerId = null;
        let recordStartTime = null;
        let previewScene, previewCamera, previewRenderer, previewDisc, previewUpperDome, previewLowerDome, previewControls, previewGroup;
        let fullScene, fullCamera, fullRenderer, fullDisc, fullUpperDome, fullLowerDome, fullControls, fullGroup;
        let previewContainer = document.getElementById('previewContainer');
        let fullContainer = document.getElementById('fullContainer');
        function init3D(container, size, isPreview = true) {
            const scene = new THREE.Scene();
            const bgColor = new THREE.Color(sceneBackgroundColor[0] / 255, sceneBackgroundColor[1] / 255, sceneBackgroundColor[2] / 255);
            scene.background = bgColor;
            const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(size, size);
            container.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(0, 10, 10);
            scene.add(pointLight);
            const group = new THREE.Group();
            const discGeometry = new THREE.CircleGeometry(5, 128);
            const discMaterial = new THREE.MeshPhongMaterial({ side: THREE.DoubleSide, transparent: true });
            const disc = new THREE.Mesh(discGeometry, discMaterial);
            disc.rotation.x = Math.PI / 2;
            group.add(disc);
            const upperDomeGeometry = new THREE.SphereGeometry(5, 128, 128, 0, Math.PI * 2, 0, Math.PI / 2);
            const upperDomeMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.6,
                shininess: 100,
                specular: 0xffffff,
                side: THREE.DoubleSide
            });
            const upperDome = new THREE.Mesh(upperDomeGeometry, upperDomeMaterial);
            group.add(upperDome);
            const lowerDomeGeometry = new THREE.SphereGeometry(5, 128, 128, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
            const lowerDomeMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color(lowerDomeColor[0] / 255, lowerDomeColor[1] / 255, lowerDomeColor[2] / 255),
                transparent: lowerDomeColor[3] < 1,
                opacity: lowerDomeColor[3],
                side: THREE.DoubleSide
            });
            const lowerDome = new THREE.Mesh(lowerDomeGeometry, lowerDomeMaterial);
            group.add(lowerDome);
            scene.add(group);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enablePan = false;
            controls.enableZoom = false;
            controls.enableRotate = true;
            controls.autoRotate = false;
            function animate3D() {
                requestAnimationFrame(animate3D);
                if ((isPreview && isAnimating) || (!isPreview && isFullAnimating)) {
                    const time = Date.now() * 0.001;
                    group.rotation.y += 0.01;
                    group.rotation.x = Math.sin(time * 0.5) * 0.1;
                    group.rotation.z = Math.cos(time * 0.5) * 0.1;
                }
                controls.update();
                renderer.render(scene, camera);
            }
            animate3D();
            return { scene, camera, renderer, disc, upperDome, lowerDome, controls, group };
        }
        function update3DTexture(disc, textureCanvas) {
            const texture = new THREE.CanvasTexture(textureCanvas);
            texture.needsUpdate = true;
            disc.material.map = texture;
            disc.material.needsUpdate = true;
        }
        function updateSceneBackground() {
            const bgColor = new THREE.Color(sceneBackgroundColor[0] / 255, sceneBackgroundColor[1] / 255, sceneBackgroundColor[2] / 255);
            previewScene.background = bgColor;
            fullScene.background = bgColor;
            if (hasBackgroundImage && backgroundTexture) {
                previewLowerDome.material.map = backgroundTexture;
                previewLowerDome.material.color.set(0xffffff); // Сбрасываем цвет на белый, чтобы текстура отображалась без тонировки
                previewLowerDome.material.needsUpdate = true;
                fullLowerDome.material.map = backgroundTexture;
                fullLowerDome.material.color.set(0xffffff); // Сбрасываем цвет на белый, чтобы текстура отображалась без тонировки
                fullLowerDome.material.needsUpdate = true;
            } else {
                previewLowerDome.material.map = null;
                fullLowerDome.material.map = null;
                updateLowerDomeColor();
            }
            previewLowerDome.visible = true;
            fullLowerDome.visible = true;
        }
        function updateLowerDomeColor() {
            const ldColor = new THREE.Color(lowerDomeColor[0] / 255, lowerDomeColor[1] / 255, lowerDomeColor[2] / 255);
            previewLowerDome.material.color = ldColor;
            previewLowerDome.material.transparent = lowerDomeColor[3] < 1;
            previewLowerDome.material.opacity = lowerDomeColor[3];
            previewLowerDome.material.needsUpdate = true;
            fullLowerDome.material.color = ldColor;
            fullLowerDome.material.transparent = lowerDomeColor[3] < 1;
            fullLowerDome.material.opacity = lowerDomeColor[3];
            fullLowerDome.material.needsUpdate = true;
        }
        function loadPalette() {
            const generatedColors = localStorage.getItem('generatedColors');
            if (generatedColors) {
                try {
                    const colors = JSON.parse(generatedColors);
                    if (Array.isArray(colors) && colors.every(c => /^#[0-9A-Fa-f]{6}$/.test(c))) {
                        const newPalette = {};
                        colors.forEach((color, index) => {
                            const rgb = hexToRgb(color);
                            newPalette[(index + 1).toString()] = [...rgb, 1];
                        });
                        localStorage.setItem('palette', JSON.stringify(newPalette));
                        return newPalette;
                    }
                } catch (e) {
                    console.error('Error parsing generatedColors:', e);
                }
            }
            const saved = localStorage.getItem('palette');
            if (saved) {
                try {
                    const json = JSON.parse(saved);
                    if (Object.keys(json).every(k => Array.isArray(json[k]) && json[k].length === 4 && json[k].slice(0, 3).every(c => Number.isInteger(c) && c >= 0 && c <= 255) && json[k][3] >= 0 && json[k][3] <= 1)) {
                        return json;
                    }
                } catch (e) {
                    console.error('Error parsing saved palette:', e);
                }
            }
            return DEFAULT_PALETTE;
        }
        function loadSceneBackgroundColor() {
            const saved = localStorage.getItem('sceneBackgroundColor');
            if (saved) {
                try {
                    const color = JSON.parse(saved);
                    if (Array.isArray(color) && color.length === 4 && color.slice(0, 3).every(c => Number.isInteger(c) && c >= 0 && c <= 255) && color[3] >= 0 && color[3] <= 1) {
                        sceneBackgroundColor = color;
                    }
                } catch (e) {
                    console.error('Error parsing saved scene background color:', e);
                }
            }
            hasBackgroundImage = false; // Image not saved
            updateSceneBackground();
        }
        function loadLowerDomeColor() {
            const saved = localStorage.getItem('lowerDomeColor');
            if (saved) {
                try {
                    const color = JSON.parse(saved);
                    if (Array.isArray(color) && color.length === 4 && color.slice(0, 3).every(c => Number.isInteger(c) && c >= 0 && c <= 255) && color[3] >= 0 && color[3] <= 1) {
                        lowerDomeColor = color;
                    }
                } catch (e) {
                    console.error('Error parsing saved lower dome color:', e);
                }
            }
            updateLowerDomeColor();
        }
        function savePalette() {
            localStorage.setItem('palette', JSON.stringify(palette));
        }
        function updatePaletteTable() {
            const tbody = document.querySelector('#paletteTable tbody');
            tbody.innerHTML = '';
            Object.entries(palette).forEach(([key, color], index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="border-b p-3 text-center text-gray-700">${key}</td>
                    <td class="border-b p-3">
                        <button class="color-btn" style="background-color: rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]});" title="Изменить цвет"></button>
                    </td>
                    <td class="border-b p-3">
                        <button class="delete-btn" title="Удалить цвет">Удалить</button>
                    </td>
                `;
                row.querySelector('.color-btn').addEventListener('click', () => changeColor(index));
                row.querySelector('.delete-btn').addEventListener('click', () => removeSpecificColor(key));
                tbody.appendChild(row);
            });
        }
        function addColor() {
            if (Object.keys(palette).length >= 20) {
                alert('Максимум 20 цветов!');
                return;
            }
            const newKey = (Object.keys(palette).length + 1).toString();
            palette[newKey] = AVAILABLE_COLORS[colorIndex % AVAILABLE_COLORS.length];
            colorIndex++;
            updatePaletteTable();
            savePalette();
        }
        function removeColor() {
            if (Object.keys(palette).length <= 1) {
                alert('Минимум 1 цвет!');
                return;
            }
            const keys = Object.keys(palette);
            delete palette[keys[keys.length - 1]];
            updatePaletteTable();
            savePalette();
        }
        function removeSpecificColor(key) {
            if (Object.keys(palette).length <= 1) {
                alert('Минимум 1 цвет!');
                return;
            }
            delete palette[key];
            const newPalette = {};
            Object.values(palette).forEach((color, index) => {
                newPalette[(index + 1).toString()] = color;
            });
            palette = newPalette;
            updatePaletteTable();
            savePalette();
        }
        function changeColor(row) {
            const key = Object.keys(palette)[row];
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white p-6 rounded-lg max-w-sm w-full">
                    <h3 class="text-lg font-semibold mb-4">Выбор цвета для ключа ${key}</h3>
                    <input type="color" id="colorPicker" value="${rgbToHex(palette[key])}" class="w-full h-12 mb-4">
                    <label class="block text-sm font-medium mb-1">Прозрачность: <span id="opacityValue">${palette[key][3]}</span></label>
                    <input type="range" id="opacitySlider" min="0" max="1" step="0.01" value="${palette[key][3]}" class="w-full mb-4">
                    <div class="flex justify-end gap-3">
                        <button id="cancelBtn" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">Отмена</button>
                        <button id="saveColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700">Сохранить</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            document.getElementById('opacitySlider').addEventListener('input', (e) => {
                document.getElementById('opacityValue').textContent = e.target.value;
            });
            document.getElementById('saveColorBtn').addEventListener('click', () => {
                const color = hexToRgb(document.getElementById('colorPicker').value);
                const opacity = parseFloat(document.getElementById('opacitySlider').value);
                palette[key] = [...color, opacity];
                updatePaletteTable();
                savePalette();
                document.body.removeChild(modal);
            });
            document.getElementById('cancelBtn').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
        }
        function changeSceneBackgroundColor() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white p-6 rounded-lg max-w-sm w-full">
                    <h3 class="text-lg font-semibold mb-4">Выбор цвета фона</h3>
                    <input type="color" id="backgroundColorPicker" value="${rgbToHex(sceneBackgroundColor)}" class="w-full h-12 mb-4">
                    <label class="block text-sm font-medium mb-1">Прозрачность: <span id="backgroundOpacityValue">${sceneBackgroundColor[3]}</span></label>
                    <input type="range" id="backgroundOpacitySlider" min="0" max="1" step="0.01" value="${sceneBackgroundColor[3]}" class="w-full mb-4">
                    <div class="flex justify-end gap-3">
                        <button id="cancelBackgroundBtn" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">Отмена</button>
                        <button id="saveBackgroundColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700">Сохранить</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            document.getElementById('backgroundOpacitySlider').addEventListener('input', (e) => {
                document.getElementById('backgroundOpacityValue').textContent = e.target.value;
            });
            document.getElementById('saveBackgroundColorBtn').addEventListener('click', () => {
                const color = hexToRgb(document.getElementById('backgroundColorPicker').value);
                const opacity = parseFloat(document.getElementById('backgroundOpacitySlider').value);
                sceneBackgroundColor = [...color, opacity];
                localStorage.setItem('sceneBackgroundColor', JSON.stringify(sceneBackgroundColor));
                hasBackgroundImage = false;
                updateSceneBackground();
                document.body.removeChild(modal);
                generate();
            });
            document.getElementById('cancelBackgroundBtn').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
        }
        function changeLowerDomeColor() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white p-6 rounded-lg max-w-sm w-full">
                    <h3 class="text-lg font-semibold mb-4">Выбор цвета нижней части</h3>
                    <input type="color" id="lowerColorPicker" value="${rgbToHex(lowerDomeColor)}" class="w-full h-12 mb-4">
                    <label class="block text-sm font-medium mb-1">Прозрачность: <span id="lowerOpacityValue">${lowerDomeColor[3]}</span></label>
                    <input type="range" id="lowerOpacitySlider" min="0" max="1" step="0.01" value="${lowerDomeColor[3]}" class="w-full mb-4">
                    <div class="flex justify-end gap-3">
                        <button id="cancelLowerBtn" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">Отмена</button>
                        <button id="saveLowerColorBtn" class="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700">Сохранить</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            document.getElementById('lowerOpacitySlider').addEventListener('input', (e) => {
                document.getElementById('lowerOpacityValue').textContent = e.target.value;
            });
            document.getElementById('saveLowerColorBtn').addEventListener('click', () => {
                const color = hexToRgb(document.getElementById('lowerColorPicker').value);
                const opacity = parseFloat(document.getElementById('lowerOpacitySlider').value);
                lowerDomeColor = [...color, opacity];
                localStorage.setItem('lowerDomeColor', JSON.stringify(lowerDomeColor));
                hasBackgroundImage = false;
                updateSceneBackground();
                updateLowerDomeColor();
                document.body.removeChild(modal);
                generate();
            });
            document.getElementById('cancelLowerBtn').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
        }
        function rgbToHex([r, g, b]) {
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
        }
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
        }
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = (seconds % 60).toString().padStart(2, '0');
            return `${mins}:${secs}`;
        }
        function updateRecordTimer() {
            if (isRecording) {
                const elapsed = Math.floor((Date.now() - recordStartTime) / 1000);
                document.getElementById('recordTimer').textContent = `Запись: ${formatTime(elapsed)}`;
                if (elapsed >= MAX_RECORDING_DURATION) {
                    stopRecording();
                    alert(`Максимальная длительность записи (${MAX_RECORDING_DURATION} секунд) достигнута.`);
                }
            }
        }
        function resetRecordTimer() {
            document.getElementById('recordTimer').textContent = 'Запись: 00:00';
            if (recordTimerId) {
                clearInterval(recordTimerId);
                recordTimerId = null;
            }
        }
        function generate() {
            stopAnimation();
            stopFullAnimation();
            stopRecording();
            const modeMap = {
                'Линии': 'Lines',
                'Точки': 'Dots',
                'Фигуры': 'Shapes',
                'Смешанный': 'Mixed',
                'Спираль': 'Spiral',
                'Орбиты': 'Orbit',
                'Точки в Фигуры': 'DotToShape',
                'Точки в Смешанный': 'DotsToMixed'
            };
            const mode = modeMap[document.getElementById('modeCombo').value];
            const elements = parseInt(document.getElementById('elementSlider').value);
            const slices = parseInt(document.getElementById('slicesSlider').value);
            generator = new KaleidoGenerator(CANVAS_PX, palette, mode, 12, elements, slices);
            const textureCanvas = generator.generateTextureCanvas();
            currentTextureCanvas = textureCanvas;
            update3DTexture(previewDisc, textureCanvas);
        }
        function animate() {
            if (!generator) {
                alert('Сначала сгенерируйте узор!');
                return;
            }
            isAnimating = !isAnimating;
            const animateBtn = document.getElementById('animateBtn');
            if (isAnimating) {
                animateBtn.textContent = 'Остановить';
                animateBtn.classList.add('active');
                startTime = Date.now();
                requestAnimationFrame(animateLoop);
            } else {
                animateBtn.textContent = 'Анимировать';
                animateBtn.classList.remove('active');
                cancelAnimationFrame(animationFrameId);
            }
        }
        function animateLoop() {
            if (!isAnimating || !generator) {
                return;
            }
            const elapsedTime = (Date.now() - startTime) / 1000;
            const textureCanvas = generator.generateTextureCanvas(true, elapsedTime);
            currentTextureCanvas = textureCanvas;
            update3DTexture(previewDisc, textureCanvas);
            animationFrameId = requestAnimationFrame(animateLoop);
        }
        function stopAnimation() {
            if (isAnimating) {
                isAnimating = false;
                document.getElementById('animateBtn').textContent = 'Анимировать';
                document.getElementById('animateBtn').classList.remove('active');
                cancelAnimationFrame(animationFrameId);
            }
        }
        function openFullImage() {
            if (!generator) {
                alert('Сначала сгенерируйте узор!');
                return;
            }
            stopAnimation();
            const modal = document.getElementById('imageModal');
            const gen = new KaleidoGenerator(MAIN_PX, palette, generator.mode, generator.sectors, generator.elements, generator.slices);
            const textureCanvas = gen.generateTextureCanvas();
            update3DTexture(fullDisc, textureCanvas);
            modal.classList.add('show');
            isFullAnimating = true;
            fullStartTime = Date.now();
            requestAnimationFrame(() => animateFullLoop(gen));
        }
        function animateFullLoop(gen) {
            if (!isFullAnimating || !gen) {
                return;
            }
            const elapsedTime = (Date.now() - fullStartTime) / 1000;
            const textureCanvas = gen.generateTextureCanvas(true, elapsedTime);
            update3DTexture(fullDisc, textureCanvas);
            fullAnimationFrameId = requestAnimationFrame(() => animateFullLoop(gen));
        }
        function stopFullAnimation() {
            if (isFullAnimating) {
                isFullAnimating = false;
                cancelAnimationFrame(fullAnimationFrameId);
            }
        }
        function save() {
            if (!currentTextureCanvas) {
                alert('Сначала сгенерируйте узор!');
                return;
            }
            const link = document.createElement('a');
            link.download = 'калейдоскоп.png';
            link.href = currentTextureCanvas.toDataURL('image/png');
            link.click();
        }
        function startStopRecording() {
            if (!generator) {
                alert('Сначала сгенерируйте узор!');
                return;
            }
            const recordBtn = document.getElementById('recordBtn');
            const downloadVideoBtn = document.getElementById('downloadVideoBtn');
            const mimeType = MediaRecorder.isTypeSupported('video/mp4;codecs=avc1.4D401E') ? 'video/mp4;codecs=avc1.4D401E' : 'video/webm;codecs=vp9';
            const fileExtension = mimeType.startsWith('video/mp4') ? 'mp4' : 'webm';
            if (!isRecording) {
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    alert(`Формат ${fileExtension.toUpperCase()} не поддерживается вашим браузером. Попробуйте другой браузер, например Chrome.`);
                    return;
                }
                if (!isAnimating) {
                    isAnimating = true;
                    startTime = Date.now();
                    requestAnimationFrame(animateLoop);
                    document.getElementById('animateBtn').textContent = 'Остановить';
                    document.getElementById('animateBtn').classList.add('active');
                }
                recordedChunks = [];
                const stream = previewRenderer.domElement.captureStream(isMobile ? 30 : 60);
                try {
                    mediaRecorder = new MediaRecorder(stream, {
                        mimeType: mimeType,
                        videoBitsPerSecond: isMobile ? 10000000 : 20000000
                    });
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            recordedChunks.push(event.data);
                        }
                    };
                    mediaRecorder.onstop = () => {
                        downloadVideoBtn.disabled = recordedChunks.length === 0;
                        resetRecordTimer();
                    };
                    mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder error:', event.error);
                        alert('Ошибка при записи видео: ' + event.error.message);
                        stopRecording();
                    };
                    mediaRecorder.start();
                    isRecording = true;
                    recordBtn.textContent = 'Стоп запись';
                    recordBtn.classList.add('active');
                    recordStartTime = Date.now();
                    recordTimerId = setInterval(updateRecordTimer, 1000);
                } catch (e) {
                    console.error('Failed to start recording:', e);
                    alert('Не удалось начать запись. Формат MP4 может быть неподдерживаемым. Попробуйте браузер Chrome.');
                }
            } else {
                mediaRecorder.stop();
                isRecording = false;
                recordBtn.textContent = 'Старт запись';
                recordBtn.classList.remove('active');
            }
        }
        function downloadVideo() {
            if (recordedChunks.length === 0) {
                alert('Нет записанного видео для скачивания!');
                return;
            }
            const mimeType = MediaRecorder.isTypeSupported('video/mp4;codecs=avc1.4D401E') ? 'video/mp4' : 'video/webm';
            const fileExtension = mimeType.startsWith('video/mp4') ? 'mp4' : 'webm';
            const blob = new Blob(recordedChunks, { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `калейдоскоп.${fileExtension}`;
            link.click();
            URL.revokeObjectURL(url);
            recordedChunks = [];
            document.getElementById('downloadVideoBtn').disabled = true;
        }
        function stopRecording() {
            if (isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                document.getElementById('recordBtn').textContent = 'Старт запись';
                document.getElementById('recordBtn').classList.remove('active');
                document.getElementById('downloadVideoBtn').disabled = recordedChunks.length === 0;
                resetRecordTimer();
            }
        }
        // Инициализация 3D сцен
        const preview3D = init3D(previewContainer, 600);
        previewScene = preview3D.scene;
        previewCamera = preview3D.camera;
        previewRenderer = preview3D.renderer;
        previewDisc = preview3D.disc;
        previewUpperDome = preview3D.upperDome;
        previewLowerDome = preview3D.lowerDome;
        previewControls = preview3D.controls;
        previewGroup = preview3D.group;
        const full3D = init3D(fullContainer, 800, false);
        fullScene = full3D.scene;
        fullCamera = full3D.camera;
        fullRenderer = full3D.renderer;
        fullDisc = full3D.disc;
        fullUpperDome = full3D.upperDome;
        fullLowerDome = full3D.lowerDome;
        fullControls = full3D.controls;
        fullGroup = full3D.group;
        // События
        document.getElementById('elementSlider').addEventListener('input', (e) => {
            document.getElementById('elementValue').textContent = e.target.value;
            stopAnimation();
            stopFullAnimation();
            stopRecording();
        });
        document.getElementById('slicesSlider').addEventListener('input', (e) => {
            document.getElementById('slicesValue').textContent = e.target.value;
            stopAnimation();
            stopFullAnimation();
            stopRecording();
        });
        document.getElementById('animationSpeedSlider').addEventListener('input', (e) => {
            ANIMATION_SPEED = parseFloat(e.target.value);
            document.getElementById('animationSpeedValue').textContent = ANIMATION_SPEED.toFixed(2);
        });
        document.getElementById('modeCombo').addEventListener('change', () => {
            const selectedValue = document.getElementById('modeCombo').value;
            if (selectedValue === 'Crystal') {
                window.location.href = 'kalei.html';
            } else {
                stopAnimation();
                stopFullAnimation();
                stopRecording();
            }
        });
        document.getElementById('addColorBtn').addEventListener('click', () => {
            addColor();
            stopAnimation();
            stopFullAnimation();
            stopRecording();
        });
        document.getElementById('removeColorBtn').addEventListener('click', () => {
            removeColor();
            stopAnimation();
            stopFullAnimation();
            stopRecording();
        });
        document.getElementById('generateBtn').addEventListener('click', generate);
        document.getElementById('animateBtn').addEventListener('click', animate);
        document.getElementById('recordBtn').addEventListener('click', startStopRecording);
        document.getElementById('downloadVideoBtn').addEventListener('click', downloadVideo);
        document.getElementById('viewBtn').addEventListener('click', openFullImage);
        document.getElementById('saveBtn').addEventListener('click', save);
        document.getElementById('closeModalBtn').addEventListener('click', () => {
            stopFullAnimation();
            document.getElementById('imageModal').classList.remove('show');
        });
        document.getElementById('home').addEventListener('click', () => {
            stopAnimation();
            stopFullAnimation();
            stopRecording();
            window.location.href = 'index.html';
        });
        document.getElementById('changeBackgroundColorBtn').addEventListener('click', changeSceneBackgroundColor);
        document.getElementById('changeLowerColorBtn').addEventListener('click', changeLowerDomeColor);
        document.getElementById('uploadBackgroundImageBtn').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const url = URL.createObjectURL(file);
                    backgroundTexture = new THREE.TextureLoader().load(url, () => {
                        backgroundTexture.needsUpdate = true;
                        hasBackgroundImage = true;
                        updateSceneBackground();
                        generate();
                    });
                }
            };
            input.click();
        });
        let palette = loadPalette();
        updatePaletteTable();
        loadSceneBackgroundColor();
        loadLowerDomeColor();
    </script>
</body>
</html>
